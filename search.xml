<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>杭师训练赛4总结</title>
    <url>/%E6%9D%AD%E5%B8%88%E8%AE%AD%E7%BB%83%E8%B5%9B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="杭师训练赛第四场"><a href="#杭师训练赛第四场" class="headerlink" title="杭师训练赛第四场"></a>杭师训练赛第四场</h1><p>手速场<br><a id="more"></a></p>
<h2 id="A-Mental-Rotation"><a href="#A-Mental-Rotation" class="headerlink" title="A - Mental Rotation"></a><a href="http://codeforces.com/gym/102219/problem/A" target="_blank" rel="noopener">A - Mental Rotation</a></h2><div class="tabs" id="a"><ul class="nav-tabs"><li class="tab active"><a href="#a-1">题解</a></li><li class="tab"><a href="#a-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="a-1"><blockquote>
<ul>
<li>题意：给出n*n的字符矩阵和旋转序列，L表示逆时针旋转，R表示顺时针旋转，求完成整个旋转序列后的矩阵。</li>
</ul>
<ul>
<li>思路：<ul>
<li>统计逆时针旋转的次数num， 因为旋转4次相当于没有旋转，所以旋转(num%4+4)%4次即可。</li>
<li>逆时针旋转90度：a[i][j] = b[j][n-i+1] ,i,j均从1开始</li>
</ul>
</li>
</ul>
</blockquote></div><div class="tab-pane" id="a-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">string</span> op;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N][N],a[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        rep(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=n-i+<span class="number">1</span>;</span><br><span class="line">            a[i][j] = s[j][k];</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">'v'</span>) a[i][j]=<span class="string">'&gt;'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'&gt;'</span>) a[i][j]=<span class="string">'^'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'^'</span>) a[i][j]=<span class="string">'&lt;'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'&lt;'</span>) a[i][j]=<span class="string">'v'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(s,a,<span class="keyword">sizeof</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;op;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;op.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="string">'L'</span>) num++;</span><br><span class="line">        <span class="keyword">else</span> num--;</span><br><span class="line">    &#125;</span><br><span class="line">    ((num%=<span class="number">4</span>) +=<span class="number">4</span>) %= <span class="number">4</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,num) charge();</span><br><span class="line">    rep(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="B-SpongeBob-SquarePants"><a href="#B-SpongeBob-SquarePants" class="headerlink" title="B - SpongeBob SquarePants"></a><a href="http://codeforces.com/gym/102219/problem/B" target="_blank" rel="noopener">B - SpongeBob SquarePants</a></h2><div class="tabs" id="b"><ul class="nav-tabs"><li class="tab active"><a href="#b-1">题解</a></li><li class="tab"><a href="#b-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="b-1"><blockquote>
<ul>
<li>题意：给定长宽判定是否为正方形</li>
</ul>
</blockquote></div><div class="tab-pane" id="b-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,a,b;</span><br><span class="line">    rd(t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        rd(a),rd(b);</span><br><span class="line">        <span class="keyword">if</span>(a==b) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="C-I-Don’t-Want-To-Pay-For-The-Late-Jar"><a href="#C-I-Don’t-Want-To-Pay-For-The-Late-Jar" class="headerlink" title="C - I Don’t Want To Pay For The Late Jar!"></a><a href="http://codeforces.com/gym/102219/problem/C" target="_blank" rel="noopener">C - I Don’t Want To Pay For The Late Jar!</a></h2><div class="tabs" id="c"><ul class="nav-tabs"><li class="tab active"><a href="#c-1">题解</a></li><li class="tab"><a href="#c-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="c-1"><blockquote>
<ul>
<li>题意：给定d组数据，每组一个n和s，后面n行输入fi和ti，若s&gt;=ti，第i项权值为fi，否则第i项权值为fi-(ti-s)，求最大权值。</li>
</ul>
</blockquote></div><div class="tab-pane" id="c-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d,n;</span><br><span class="line">ll s,t,f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rd(d);</span><br><span class="line">    rep(_,<span class="number">1</span>,d)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;s);</span><br><span class="line">        ll ans = -inf;</span><br><span class="line">        rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;f,&amp;t);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;=s) ans = max(ans,f);</span><br><span class="line">            <span class="keyword">else</span> ans = max(ans,f-t+s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,_,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="E-Optimal-Slots"><a href="#E-Optimal-Slots" class="headerlink" title="E - Optimal Slots "></a><a href="http://codeforces.com/gym/102219/problem/E" target="_blank" rel="noopener">E - Optimal Slots </a></h2><div class="tabs" id="e"><ul class="nav-tabs"><li class="tab active"><a href="#e-1">题解</a></li><li class="tab"><a href="#e-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="e-1"><blockquote>
<ul>
<li>题意：有n个节目需要安排，每个节目占用一定单位的时间，各个节目的时间不能重合，你有T单位的时间可以使用，问最多可以安排多少时间，并且输出字典序最小的具体方案。</li>
<li>思路：<a href="http://bamboo-rat.cn/%E6%B1%82%E8%A7%A3%E8%83%8C%E5%8C%85%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">01背包求具体方案</a>。</li>
</ul>
</blockquote></div><div class="tab-pane" id="e-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n,a[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m)&amp;&amp;m)&#123;</span><br><span class="line">        clr(f,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        repd(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">            rep(j,<span class="number">0</span>,m)&#123;</span><br><span class="line">                f[i][j] = f[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=a[i])f[i][j] = max(f[i][j],f[i+<span class="number">1</span>][j-a[i]]+a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=m;</span><br><span class="line">        rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=a[i] &amp;&amp; i==n)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[n]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(j-a[i]&gt;=<span class="number">0</span> &amp;&amp; f[i][j]==f[i+<span class="number">1</span>][j-a[i]]+a[i])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">                j-=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">1</span>][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="F-Military-Class"><a href="#F-Military-Class" class="headerlink" title="F - Military Class "></a><a href="http://codeforces.com/gym/102219/problem/F" target="_blank" rel="noopener">F - Military Class </a></h2><div class="tabs" id="f"><ul class="nav-tabs"><li class="tab active"><a href="#f-1">题解</a></li><li class="tab"><a href="#f-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="f-1"><blockquote>
<ul>
<li>题意：有2n个士兵排成两行，每行都从1到n进行标记。现在要将这些士兵两两配对。给出k对关系(i,j)，第一行的i和第二行的j不能配对，问有多少种方案可以完成n组配对。（n&lt;2000,e&lt;5,k&lt;2000）</li>
</ul>
<ul>
<li>思路<ul>
<li>e&lt;5是一个关键信息，一般这种情况极大的可能是状压dp。不会状压dp的话可以先看一下这道<a href="http://bamboo-rat.cn/Corn-Fields-%E7%8A%B6%E5%8E%8Bdp%E6%A8%A1%E6%9D%BF%E9%A2%98/" target="_blank" rel="noopener">模板题</a>。</li>
<li>f[i][j]表示在处理到第2行第i个士兵时，第1行中与之距离&lt;=e的士兵的匹配情况，采用状态压缩，1表示已匹配，0表示未匹配，j的范围为[0,2^(2*e+1)-1]</li>
<li><code>f[i][j] = ∑(f[i-1][ (j^(1&lt;&lt;k)) &gt;&gt;1]) + ∑(f[i][j] += f[i-1][( (j^(1&lt;&lt;k)) &gt;&gt;1) | (1&lt;&lt;2*e)])</code>，其中j的第k位为1。</li>
<li>初态：f[1][j]=1，其中j的二进制位只有1个1。</li>
<li>终态：f[n][num]，num为j的最高e+1位全1的状态。</li>
<li>上式含义为对于第i个阶段的状态j，枚举j的第k位为1的情况A，A的答案由上一个阶段在相应位置没有1情况B转移得到，所以要先将j的第k为先置0。由于j只能包含当前状态的<code>2*e+1</code>个位置，所以上一个阶段的状态需要由j右移一位得到（可以将j描述状态的方式看作一个窗口，i到i-1相当于窗口左移，也就相当于窗口内的值右移），而最高位有0和1<code>( |(1&lt;&lt;2*e) )</code>两种情况，都要分别记入答案。</li>
</ul>
</li>
</ul>
</blockquote></div><div class="tab-pane" id="f-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f[N][N];</span><br><span class="line"><span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,e,p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;e,&amp;p);</span><br><span class="line">    rep(i,<span class="number">1</span>,p)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        mp[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sta = <span class="number">1</span>&lt;&lt;(<span class="number">2</span>*e+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=max(e+<span class="number">1</span>-n,<span class="number">0</span>);j&lt;=e;j++)</span><br><span class="line">        <span class="keyword">if</span>(!mp[<span class="number">1</span>+e-j][<span class="number">1</span>]) f[<span class="number">1</span>][<span class="number">1</span>&lt;&lt;j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sta;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">2</span>*e;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+e-k&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i+e-k&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>((j&amp;(<span class="number">1</span>&lt;&lt;k)))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp[i+e-k][i]) <span class="keyword">continue</span>;</span><br><span class="line">                    (f[i][j] += f[i<span class="number">-1</span>][(j^(<span class="number">1</span>&lt;&lt;k))&gt;&gt;<span class="number">1</span>])%=mod;  <span class="comment">//最高位为0</span></span><br><span class="line">                    (f[i][j] += f[i<span class="number">-1</span>][((j^(<span class="number">1</span>&lt;&lt;k))&gt;&gt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>*e)])%=mod;  <span class="comment">//最高位为1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>, num = sta<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,e<span class="number">-1</span>) num-=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n][num]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="H-Are-You-Safe"><a href="#H-Are-You-Safe" class="headerlink" title="H - Are You Safe? "></a><a href="http://codeforces.com/gym/102219/problem/H" target="_blank" rel="noopener">H - Are You Safe? </a></h2><div class="tabs" id="h"><ul class="nav-tabs"><li class="tab active"><a href="#h-1">题解</a></li><li class="tab"><a href="#h-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="h-1"><blockquote>
<ul>
<li>题意：给出n个点，求凸包，再给p个点，问这些点是否在凸包内。</li>
</ul>
<ul>
<li>思路<ul>
<li><a href="http://bamboo-rat.cn/%E5%87%B8%E5%8C%85%E9%9D%A2%E7%A7%AF/" target="_blank" rel="noopener">求凸包</a></li>
<li>判定点是否在凸包内：P-A得到向量x，P-B得到向量y，求x和y的叉积f。按照上述方法依次处理凸包上相邻两点，若第i次求出的叉积与第i-1次求出的叉积正负性不同，则说明点不在凸包内。</li>
<li>两向量：a=(x1,y1), b=(x2,y2)，他们的叉积为<code>x1*y2 - y1*x2</code><br><img src="../image/叉积判断点在凸包内.png" alt=""></li>
</ul>
</li>
</ul>
</blockquote></div><div class="tab-pane" id="h-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    inline Point(double x=0,double y=0):x(x),y(y)&#123;&#125;</span><br><span class="line">&#125;p[N],ch[N],p1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.x!=B.x)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A.y&lt;B.y;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> + (Point A,Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> Point(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> - (Point A,Point B)&#123;</span><br><span class="line">    <span class="keyword">return</span> Point(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; A,<span class="keyword">const</span> Point&amp; B)&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(A.x-B.x)==<span class="number">0</span>&amp;&amp;dcmp(A.y-B.y)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Point A,Point B)</span>  <span class="comment">// 计算叉积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x * B.y - A.y * B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConvexHull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>,myCmp);</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">1</span> &amp;&amp; dcmp(Cross(ch[m<span class="number">-1</span>]-ch[m<span class="number">-2</span>],p[i]-ch[m<span class="number">-2</span>]))&lt;=<span class="number">0</span>)m--;</span><br><span class="line">        ch[m++]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;k &amp;&amp; dcmp(Cross(ch[m<span class="number">-1</span>]-ch[m<span class="number">-2</span>],p[i]-ch[m<span class="number">-2</span>]))&lt;=<span class="number">0</span>)m--;</span><br><span class="line">        ch[m++]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dis</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(Point A,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    Point a1 = A-ch[<span class="number">0</span>], a2=A-ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">double</span> f = Cross(a1,a2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        a1 = A-ch[i], a2 = A-ch[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> f1=Cross(a1,a2);</span><br><span class="line">        <span class="keyword">if</span>(f1*f &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        f=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,q,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    rep(_,<span class="number">1</span>,t)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">        rep(i,<span class="number">1</span>,n)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">        rep(i,<span class="number">1</span>,q)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;p1[i].x,&amp;p1[i].y);</span><br><span class="line">        m=ConvexHull();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d\n"</span>,_);</span><br><span class="line">        rep(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.0f %.0f\n"</span>,ch[i].x,ch[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.0f %.0f is "</span>,p1[i].x,p1[i].y);</span><br><span class="line">            <span class="keyword">if</span>(check(p1[i],m)) <span class="built_in">puts</span>(<span class="string">"unsafe!"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"safe!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="I-To-Crash-Or-Not-To-Crash"><a href="#I-To-Crash-Or-Not-To-Crash" class="headerlink" title="I - To Crash Or Not To Crash"></a><a href="http://codeforces.com/gym/102219/problem/I" target="_blank" rel="noopener">I - To Crash Or Not To Crash</a></h2><div class="tabs" id="i"><ul class="nav-tabs"><li class="tab active"><a href="#i-1">题解</a></li><li class="tab"><a href="#i-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="i-1"><blockquote>
<ul>
<li>题意：给一个字符矩阵，找到’=’右边第一个不是’.’的字符</li>
</ul>
</blockquote></div><div class="tab-pane" id="i-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">        rep(j,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="string">'='</span>)&#123;</span><br><span class="line">                x=i, y=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    rep(j,y+<span class="number">1</span>,<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x][j]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,a[x][j]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You shall pass!!!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="J-Kitchen-Plates"><a href="#J-Kitchen-Plates" class="headerlink" title="J - Kitchen Plates "></a><a href="http://codeforces.com/gym/102219/problem/J" target="_blank" rel="noopener">J - Kitchen Plates </a></h2><div class="tabs" id="j"><ul class="nav-tabs"><li class="tab active"><a href="#j-1">题解</a></li><li class="tab"><a href="#j-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="j-1"><blockquote>
<ul>
<li>题意：给出5个字符的大小关系，将字符从小到大依次输出。</li>
<li>思路：数据小，直接全排列，然后判断是否有满足条件的字符对即可；数据大的话建有向图求拓扑序。</li>
</ul>
</blockquote></div><div class="tab-pane" id="j-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">5</span>)&#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">'&gt;'</span>) f[s[<span class="number">2</span>]-<span class="string">'A'</span>+<span class="number">1</span>][s[<span class="number">0</span>]-<span class="string">'A'</span>+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[s[<span class="number">0</span>]-<span class="string">'A'</span>+<span class="number">1</span>][s[<span class="number">2</span>]-<span class="string">'A'</span>+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">            rep(j,i+<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">                <span class="keyword">if</span>(f[a[j]][a[i]]) flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            rep(i,<span class="number">1</span>,<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]<span class="number">-1</span>+<span class="string">'A'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(a+<span class="number">1</span>,a+<span class="number">6</span>));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="K-Help-The-Support-Lady"><a href="#K-Help-The-Support-Lady" class="headerlink" title="K - Help The Support Lady "></a><a href="http://codeforces.com/gym/102219/problem/K" target="_blank" rel="noopener">K - Help The Support Lady </a></h2><div class="tabs" id="k"><ul class="nav-tabs"><li class="tab active"><a href="#k-1">题解</a></li><li class="tab"><a href="#k-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="k-1"><blockquote>
<ul>
<li>题意：机器人在同一时间接到了n个任务，第i个任务耗时x[i]，只要在2*x[i]的时间内完成第i个任务，这个任务的发布者就会满意，请问最多可以使多少任务发布者满意。</li>
<li>思路<ul>
<li>贪心，优先完成耗时小的任务，如果前面完成的任务总时间小于当前任务的时间，则当前任务可以满足要求，否则就把当前任务舍弃掉。</li>
<li>因为当前任务对答案的贡献为1，如果前面的任务耗时已经比当前任务多，并且采取“为了当前任务（贡献+1）而舍弃前面的任务（贡献-x，x&gt;=1）”的决策的话，对答案的贡献并不会增加，所以直接舍弃没有问题。</li>
</ul>
</li>
</ul>
</blockquote></div><div class="tab-pane" id="k-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line">ll a[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rd(t);</span><br><span class="line">    rep(_,<span class="number">1</span>,t)&#123;</span><br><span class="line">        clr(s,<span class="number">0</span>);</span><br><span class="line">        rd(n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) rd(a[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]&lt;=a[i]) ans++;</span><br><span class="line">            <span class="keyword">else</span> s[i]=s[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,_,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="本场总结"><a href="#本场总结" class="headerlink" title="本场总结"></a>本场总结</h2><blockquote>
<ul>
<li>涉及知识点：矩阵转置，小模拟，背包问题输出具体方案，状压dp，凸包，叉积，拓扑排序，贪心。</li>
</ul>
</blockquote>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><blockquote>
<p>总体来说没什么大问题，签得飞起。</p>
</blockquote>
]]></content>
      <tags>
        <tag>训练总结</tag>
      </tags>
  </entry>
  <entry>
    <title>杭师训练赛3总结</title>
    <url>/%E6%9D%AD%E5%B8%88%E8%AE%AD%E7%BB%83%E8%B5%9B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="杭师训练赛第三场"><a href="#杭师训练赛第三场" class="headerlink" title="杭师训练赛第三场"></a>杭师训练赛第三场</h1><p>数论要我死<br><a id="more"></a></p>
<h2 id="A-Jumping-Buildings"><a href="#A-Jumping-Buildings" class="headerlink" title="A - Jumping Buildings"></a><a href="http://codeforces.com/gym/102302/problem/A" target="_blank" rel="noopener">A - Jumping Buildings</a></h2><div class="tabs" id="a"><ul class="nav-tabs"><li class="tab active"><a href="#a-1">题解</a></li><li class="tab"><a href="#a-2">存在问题</a></li><li class="tab"><a href="#a-3">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="a-1"><blockquote>
<ul>
<li>题意：给出n个数，在位置i上可移动到min(i+a[i],n)且仅移动一次，若中间有大于a[i]的数a[j]，则移动到j-1，求出每个位置移动的终点。</li>
<li>思路：从后往前遍历，用递减单调栈维护右边第一个比它高的位置。</li>
</ul>
</blockquote></div><div class="tab-pane" id="a-2"><blockquote>
<ul>
<li>读错题，以为可以多次跳；</li>
</ul>
</blockquote></div><div class="tab-pane" id="a-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N],f[N],n;</span><br><span class="line"><span class="keyword">int</span> sta[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) f[i]=i;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x[i]);</span><br><span class="line">    sta[++tot]=n;</span><br><span class="line">    repd(i,n<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tot &amp;&amp; (x[sta[tot]] &lt;= x[i])) tot--;</span><br><span class="line">        <span class="keyword">int</span> y=min(i+x[i],n);</span><br><span class="line">        <span class="keyword">if</span>(x[sta[tot]]&gt;x[i] &amp;&amp; sta[tot]&lt;=y) y=sta[tot]<span class="number">-1</span>;</span><br><span class="line">        f[i] = y;</span><br><span class="line">        sta[++tot] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,f[i]-i,<span class="string">" \n"</span>[i==n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="B-Divples"><a href="#B-Divples" class="headerlink" title="B - Divples"></a><a href="http://codeforces.com/gym/102302/problem/B" target="_blank" rel="noopener">B - Divples</a></h2><div class="tabs" id="b"><ul class="nav-tabs"><li class="tab active"><a href="#b-1">题解</a></li><li class="tab"><a href="#b-2">存在问题</a></li><li class="tab"><a href="#b-3">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="b-1"><blockquote>
<ul>
<li>题意：给出a和b两个数，找出所有数c，满足a%c==0 &amp;&amp; c%b==0。(1&lt;=b&lt;=a&lt;=1e12)</li>
<li>思路：找出a的所有因数，再在里面找出所有b的倍数，排序输出即可</li>
</ul>
</blockquote></div><div class="tab-pane" id="b-2"><blockquote>
<ul>
<li>一开始想将a/b分解因式，找到所有约数，没想到这能T。。。然后老老实实sqrt(n)扫过去。</li>
</ul>
</blockquote></div><div class="tab-pane" id="b-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f[N],x[N];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">    ll c=a/b;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>) &#123;</span><br><span class="line">            f[++tot] = i;</span><br><span class="line">            f[++tot] = a/i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tot = unique(f+<span class="number">1</span>,f+<span class="number">1</span>+tot)-f<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        <span class="keyword">if</span>(f[i]%b==<span class="number">0</span>)</span><br><span class="line">            x[++cnt]=f[i];</span><br><span class="line">    sort(x+<span class="number">1</span>,x+<span class="number">1</span>+cnt);</span><br><span class="line">    rep(i,<span class="number">1</span>,cnt) dbg(x[i],i,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="C-Rectangles"><a href="#C-Rectangles" class="headerlink" title="C - Rectangles"></a><a href="http://codeforces.com/gym/102302/problem/C" target="_blank" rel="noopener">C - Rectangles</a></h2><div class="tabs" id="c"><ul class="nav-tabs"><li class="tab active"><a href="#c-1">题解</a></li><li class="tab"><a href="#c-2">存在问题</a></li><li class="tab"><a href="#c-3">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="c-1"><blockquote>
<ul>
<li>题意：给出N(&lt;=2000)个点，求这些点能组成的矩形个数，满足矩形内部和边界不包含其他点且矩形的边平行于坐标轴。</li>
<li>思路：先将x,y离散化，按y轴从下至上扫描，对于同一高度，枚举相邻点i和j，再在i和j上方分别找到第一次出现的点，看两个点的y坐标是否相等，若相等，再判断这四个点构成的矩形中是否有其他点，可用二维前缀和预处理后O(1)询问。</li>
</ul>
</blockquote></div><div class="tab-pane" id="c-2"><blockquote>
<ul>
<li>中途代错参数一直没找到（还过了15个点。。。），赛后又想了想，好像n方枚举对角顶点也不会T，费那么大力气干嘛。。。。</li>
</ul>
</blockquote></div><div class="tab-pane" id="c-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p,q; <span class="comment">// x y 坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> a[i].x&lt;a[j].x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> a[i].y&lt;a[j].y;&#125;</span><br><span class="line"><span class="keyword">int</span> bx[N],by[N],n,mx=<span class="number">0</span>,my=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vx[N],vy[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,node1&gt; mp;</span><br><span class="line"><span class="keyword">int</span> hv[<span class="number">2001</span>][<span class="number">2001</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=hv[x2][y2]-hv[x1<span class="number">-1</span>][y2]-hv[x2][y1<span class="number">-1</span>]+hv[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> num==<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        bx[++mx]=a[i].x, by[++my]=a[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(bx+<span class="number">1</span>,bx+<span class="number">1</span>+mx);</span><br><span class="line">    sort(by+<span class="number">1</span>,by+<span class="number">1</span>+my);</span><br><span class="line">    mx=unique(bx+<span class="number">1</span>,bx+<span class="number">1</span>+mx)-bx<span class="number">-1</span>;</span><br><span class="line">    my=unique(by+<span class="number">1</span>,by+<span class="number">1</span>+my)-by<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        a[i].x=lower_bound(bx+<span class="number">1</span>,bx+<span class="number">1</span>+mx,a[i].x) - bx;</span><br><span class="line">        a[i].y=lower_bound(by+<span class="number">1</span>,by+<span class="number">1</span>+my,a[i].y) - by;</span><br><span class="line">        vx[a[i].x].push_back(i);</span><br><span class="line">        vy[a[i].y].push_back(i);</span><br><span class="line">        hv[a[i].x][a[i].y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,mx) sort(vx[i].begin(),vx[i].end(),cmp2);  <span class="comment">//同x y递增</span></span><br><span class="line">    rep(i,<span class="number">1</span>,my) sort(vy[i].begin(),vy[i].end(),cmp1);  <span class="comment">//同y x递增</span></span><br><span class="line">    rep(i,<span class="number">1</span>,mx)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vx[i].size();j++)&#123;</span><br><span class="line">            mp[vx[i][j]]=(node1)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            mp[vx[i][j]].q = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,my)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vy[i].size();j++)&#123;</span><br><span class="line">            mp[vy[i][j]].p = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,mx)&#123;</span><br><span class="line">        rep(j,<span class="number">1</span>,my)&#123;</span><br><span class="line">            hv[i][j]+=(hv[i][j<span class="number">-1</span>]+hv[i<span class="number">-1</span>][j]-hv[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,my)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vy[i].size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sit1=vy[i][j],sit2=vy[i][j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x1=a[sit1].x, x2=a[sit2].x;</span><br><span class="line">            <span class="keyword">int</span> t1=mp[sit1].q, t2=mp[sit2].q;</span><br><span class="line">            <span class="keyword">if</span>(t1+<span class="number">1</span>&gt;=vx[x1].size() || t2+<span class="number">1</span>&gt;=vx[x2].size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> y1=a[vx[x1][t1+<span class="number">1</span>]].y, y2=a[vx[x2][t2+<span class="number">1</span>]].y;</span><br><span class="line">            <span class="keyword">if</span>(y1==y2 &amp;&amp; check(x1,i,x2,y2)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="D-Guessing-Messages"><a href="#D-Guessing-Messages" class="headerlink" title="D - Guessing Messages "></a><a href="http://codeforces.com/gym/102302/problem/D" target="_blank" rel="noopener">D - Guessing Messages </a></h2><div class="tabs" id="d"><ul class="nav-tabs"><li class="tab active"><a href="#d-1">题解</a></li><li class="tab"><a href="#d-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="d-1"><blockquote>
<ul>
<li>题意：给两个串a,b，问b是否是a的子序列</li>
<li>思路：扫过去即可。</li>
</ul>
</blockquote></div><div class="tab-pane" id="d-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;a.size() &amp;&amp; j&lt;b.size())&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;a.size() &amp;&amp; a[i]!=b[j]) i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=a.size()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> i++,j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==b.size()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="E-Chi’s-performance"><a href="#E-Chi’s-performance" class="headerlink" title="E - Chi’s performance"></a><a href="http://codeforces.com/gym/102302/problem/E" target="_blank" rel="noopener">E - Chi’s performance</a></h2><div class="tabs" id="e"><ul class="nav-tabs"><li class="tab active"><a href="#e-1">题解</a></li><li class="tab"><a href="#e-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="e-1"><blockquote>
<ul>
<li>题意：有n个人，每个人会一种类型的乐器v[i]，每个人有能力值p[i]，对于不同的v，按v从小到大排序，对于相同的v，顺序任意。对于相邻两个乐器，相同乐器之间贡献为0，不同乐器间的贡献为二者能力值差的绝对值，问如何排序可使贡献和最大。</li>
<li>思路：对于每个v相等的块，首尾值为：1:最大值、2:次大值、3:最小值、4:次小值时存在最优解。设f[i][j]为第i块的第一个数字为状态j时前i块的最优解。f[i][j] = max(f[i-1][p] + abs(w[i-1][k]-w[i][j]))，p!=k。复杂度为O(4^3 * tot)。</li>
</ul>
</blockquote></div><div class="tab-pane" id="e-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll v,p;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;e)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v&lt;e.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>;</span><br><span class="line">ll f[N][<span class="number">5</span>],w[N][<span class="number">5</span>],num[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        w[i][<span class="number">3</span>] = w[i][<span class="number">4</span>] = inf;</span><br><span class="line">        w[i][<span class="number">1</span>] = w[i][<span class="number">2</span>] = -inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>, sum;</span><br><span class="line">    ll pre=a[<span class="number">1</span>].v;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        tot++, sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n &amp;&amp; a[i].v==pre)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].p &gt; w[tot][<span class="number">2</span>]) w[tot][<span class="number">2</span>]=a[i].p;</span><br><span class="line">            <span class="keyword">if</span>(w[tot][<span class="number">2</span>] &gt; w[tot][<span class="number">1</span>]) swap(w[tot][<span class="number">2</span>],w[tot][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i].p &lt; w[tot][<span class="number">4</span>]) w[tot][<span class="number">4</span>]=a[i].p;</span><br><span class="line">            <span class="keyword">if</span>(w[tot][<span class="number">4</span>] &lt; w[tot][<span class="number">3</span>]) swap(w[tot][<span class="number">3</span>],w[tot][<span class="number">4</span>]);</span><br><span class="line">            i++, sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = a[i].v;</span><br><span class="line">        num[tot] = min(sum,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i].v,&amp;a[i].p);</span><br><span class="line">    prework();</span><br><span class="line">    rep(i,<span class="number">1</span>,tot)</span><br><span class="line">        rep(j,<span class="number">1</span>,num[i])</span><br><span class="line">            rep(p,<span class="number">1</span>,num[i<span class="number">-1</span>])</span><br><span class="line">                rep(k,<span class="number">1</span>,num[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p==k &amp;&amp; num[i<span class="number">-1</span>]!=<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][p] + <span class="built_in">abs</span>(w[i<span class="number">-1</span>][k]-w[i][j]) );</span><br><span class="line">                &#125;</span><br><span class="line">    ll ans=<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,num[tot]) ans = max(ans, f[tot][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="F-Drawing-cards"><a href="#F-Drawing-cards" class="headerlink" title="F - Drawing cards"></a><a href="http://codeforces.com/gym/102302/problem/F" target="_blank" rel="noopener">F - Drawing cards</a></h2><div class="tabs" id="f"><ul class="nav-tabs"><li class="tab active"><a href="#f-1">题解</a></li><li class="tab"><a href="#f-2">存在问题</a></li><li class="tab"><a href="#f-3">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="f-1"><blockquote>
<ul>
<li>题意：共1到n张纸牌，每次抽一张牌，如果抽到重复的就放回去，否则放到桌子上，并把一张新的相同的牌放进去，求第一次抽到1时桌上纸牌的期望值。</li>
<li>思路：桌上牌数可为(1~n)张且等概率出现，每种结果的概率均为1/n，E(x)=(1+2+…+n)/n</li>
</ul>
</blockquote></div><div class="tab-pane" id="f-2"><blockquote>
<ul>
<li>读错题，开局狂卡。。。</li>
</ul>
</blockquote></div><div class="tab-pane" id="f-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) ans+=(<span class="number">1.0</span>/n)*i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.9f\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="G-Left-Stack-Game"><a href="#G-Left-Stack-Game" class="headerlink" title="G - Left Stack Game"></a><a href="http://codeforces.com/gym/102302/problem/G" target="_blank" rel="noopener">G - Left Stack Game</a></h2><div class="tabs" id="g"><ul class="nav-tabs"><li class="tab active"><a href="#g-1">题解</a></li><li class="tab"><a href="#g-2">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g-1"><blockquote>
<ul>
<li>题意：给出三堆石子x,y,z，每次一堆中取1~m颗，当左边存在石子时右边不能为空，问是否先手必胜</li>
<li>思路：从y,z中各去掉一个石子后限制条件即可消除，求三堆函数的sg值，每一堆都是一个巴什博弈，最后由于y、z各剩一颗，所以上面的处理方法不会对答案有影响。</li>
</ul>
</blockquote></div><div class="tab-pane" id="g-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll x,y,z,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;m,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    ll a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    a=x%(m+<span class="number">1</span>);</span><br><span class="line">    b=(y<span class="number">-1</span>)%(m+<span class="number">1</span>);</span><br><span class="line">    c=(z<span class="number">-1</span>)%(m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>((a^b^c)?<span class="string">"Tomaz"</span>:<span class="string">"Danftito"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="H-Log-Concave-Sequences"><a href="#H-Log-Concave-Sequences" class="headerlink" title="H - Log Concave Sequences"></a><a href="http://codeforces.com/gym/102302/problem/H" target="_blank" rel="noopener">H - Log Concave Sequences</a></h2><div class="tabs" id="h"><ul class="nav-tabs"><li class="tab active"><a href="#h-1">题解</a></li><li class="tab"><a href="#h-2">存在问题</a></li><li class="tab"><a href="#h-3">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="h-1"><blockquote>
<ul>
<li>题意：给出一个n，要求用0,1,2构造长为n<1e18的串，且满足`1<i<n &&="" a[i]*a[i]="">a[i-1]*a[i+1]`，问能构造出多少种方案。</1e18的串，且满足`1<i<n></li>
</ul>
<ul>
<li>思路<ul>
<li>一眼dp题，f[i][x][y]表示当前构造第i个串，最后两个为x和y，转移方程为<code>f[i][x][y] = ∑f[i-1][z][x]，z*y&lt;=x*x</code>。但是n很大，显然不能直接推过去。</li>
<li>通过观察我们可以发现i的状态只与i-1有关，x和y的取值只有固定的9种，因此我们可以将xy取值的9中状态放入1*9的矩阵中，用矩阵快速幂进行优化。</li>
<li>矩阵a[x-1] * h = a[x] ， 其中a[x]为阶段x的答案矩阵，h为我们需要的转移矩阵。观察目标矩阵的第j个状态，若原矩阵的第i个状态满足转移条件，就将h矩阵的第j列的第i行置为1，否则为0。<br>即：将目标矩阵作为列，原矩阵作为行，每一列根据所需要的原矩阵元素赋予相应参数。<br><img src="../image/rec1.png" alt=""></li>
</ul>
</li>
</ul>
</blockquote></div><div class="tab-pane" id="h-2"><blockquote>
<ul>
<li>太久没写，当时忘记怎么构造矩阵了…</li>
</ul>
</blockquote></div><div class="tab-pane" id="h-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[<span class="number">9</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>, <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>, <span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span></span><br><span class="line">    ll h[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    rec()&#123;clr(h,<span class="number">0</span>);&#125;</span><br><span class="line">    rec <span class="keyword">operator</span> * (<span class="keyword">const</span> rec &amp;e)<span class="keyword">const</span>&#123;</span><br><span class="line">        rec ans;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">                rep(k,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">                    ans.h[i][j] = (ans.h[i][j] + h[i][k]*e.h[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;unit;</span><br><span class="line"><span class="function">rec <span class="title">qpow</span><span class="params">(rec a,ll n)</span></span>&#123;</span><br><span class="line">    rec ans;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">8</span>) ans.h[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;(<span class="number">1l</span>l)) ans = ans*a;</span><br><span class="line">        a = a*a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rep(j,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i][<span class="number">1</span>]==q[j][<span class="number">0</span>] &amp;&amp; q[i][<span class="number">0</span>]*q[j][<span class="number">1</span>]&lt;=q[j][<span class="number">0</span>]*q[j][<span class="number">0</span>])</span><br><span class="line">                unit.h[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ll n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    rec ans = qpow(unit,n<span class="number">-2</span>);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">8</span>) (res += ans.h[<span class="number">0</span>][i])%=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="J-Weird-Sanchola"><a href="#J-Weird-Sanchola" class="headerlink" title="J - Weird Sanchola"></a><a href="http://codeforces.com/gym/102302/problem/J" target="_blank" rel="noopener">J - Weird Sanchola</a></h2><div class="tabs" id="i"><ul class="nav-tabs"><li class="tab active"><a href="#i-1">题解</a></li><li class="tab"><a href="#i-2">存在问题</a></li><li class="tab"><a href="#i-3">Code</a></li></ul><div class="tab-content"><div class="tab-pane active" id="i-1"><blockquote>
<ul>
<li>题意：给出n个数，找到一个素数x，使得∑|a[i]-x|最小。</li>
<li>思路：众所周知，若需要找的x没有素数限制，当x为序列a的中位数时上式值最小。也就是说，找到离中位数最近的素数即可找到答案。</li>
</ul>
</blockquote></div><div class="tab-pane" id="i-2"><blockquote>
<ul>
<li>Miller-Robbin判素数T了，试除法过了？？？</li>
</ul>
</blockquote></div><div class="tab-pane" id="i-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n; ll x[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x[i]);</span><br><span class="line">    sort(x+<span class="number">1</span>,x+<span class="number">1</span>+n);</span><br><span class="line">    ll p=<span class="number">0</span>,num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) num1= num2 = x[n/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ll num=(x[n/<span class="number">2</span>]+x[n/<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>) num1 = num2 = num/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            num1=num/<span class="number">2</span>;</span><br><span class="line">            num2=num1+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!isprime(num1)) num1--;</span><br><span class="line">    <span class="keyword">while</span>(!isprime(num2)) num2++;</span><br><span class="line">    ll ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        ans1+=<span class="built_in">abs</span>(x[i]-num1);</span><br><span class="line">        ans2+=<span class="built_in">abs</span>(x[i]-num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,min(ans1,ans2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="本场总结"><a href="#本场总结" class="headerlink" title="本场总结"></a>本场总结</h2><blockquote>
<p>本场整体难度不高，主要涵盖的知识点有：单调栈，离散化，模拟，数学公式，素数判定，中位数，随机等概率模型，dp，矩阵快速幂，巴什博奕，sg函数，主席树（K），后缀数组（K）等，其中ABCDEFGHJ均可做。</p>
</blockquote>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><blockquote>
<p>把简单的问题复杂化，读错题，算错复杂度…总的来说，这场全程翻车，开局卡题搞心态，导致后面没有足够的时间完成本应完成的题，其中最大的问题还是<strong>读题不仔细</strong>（好像已经因为读错题翻过无数次车了…）。</p>
</blockquote>
]]></content>
      <tags>
        <tag>训练总结</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶训练-动态规划</title>
    <url>/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>线性dp，背包问题，区间dp，树形dp，环形与后效性处理，状压dp，计数类dp，数位dp，倍增优化，数据结构优化，单调队列优化，斜率优化，四边形不等式<br><a id="more"></a></p>
<h1 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h1><p>&gt;</p>
<ul>
<li>从集合角度考虑dp问题：<ul>
<li>状态表示<ul>
<li>集合</li>
<li>属性（max，min，数量。。。）</li>
</ul>
</li>
<li>状态计算 —— 集合的划分<ul>
<li>重要划分依据：“最后一步”</li>
<li>划分原则：不重不漏<br><img src="../image/dp1.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>解题步骤</p>
<ul>
<li>划分阶段</li>
<li>确定状态和状态变量</li>
<li>确定决策并写出状态转移方程</li>
<li>寻找边界条件</li>
<li>设计并实现程序<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 阶段</span><br><span class="line">    <span class="keyword">for</span> 状态</span><br><span class="line">        <span class="keyword">for</span> 决策</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>技巧</p>
<ul>
<li><p>在设计状态转移方程时，不一定要以“如何计算出一个状态”的形式给出，也可以考率“一个已知状态应该更新哪些后续阶段的未知状态”（即从某状态的入边与出边综合考虑）</p>
</li>
<li><p>在实现状态转移方程时，要注意观察决策集合的范围随着状态的变化情况。对于“决策集合中的元素只增多不减少”的情景，可以用一个临时变量来标记决策集合的当前信息，避免重复扫描</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="keyword">int</span> val=inf;</span><br><span class="line">    rep(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">        val=min(val,f[i<span class="number">-1</span>][j]); <span class="comment">//此处即为上诉情况</span></span><br><span class="line">        f[i][j]=val+<span class="built_in">abs</span>(a[i]-b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求解线性dp问题，先确定阶段，若阶段不足以表示一个状态，则可以把所需的附加信息也作为状态的维度</p>
</li>
<li><p>在确定dp状态时，要选择最小的能覆盖整个状态空间的“维度集合”，若dp状态由多个维度构成，则应检查这些维度之间能否相互导出，用尽量少的维度覆盖整个状态空间，排除冗余维度</p>
</li>
<li><p>输出方案：从终态往前推即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> i=n,j=m,k=sit;</span><br><span class="line"><span class="keyword">while</span>(i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i][j][k]==f[i<span class="number">-1</span>][j][k]) i--;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans[++tot]=i;</span><br><span class="line">        k-=w[i];</span><br><span class="line">        i--,j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> i=n,j=m,h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &amp;&amp; j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i][j]==f[i][j-i]) h++, j-=i;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        rep(k,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j] == f[k][j-i+k] + k*(gs[i]-gs[k]))&#123;</span><br><span class="line">                rep(u,k+<span class="number">1</span>,i) ans[g[u].second] = h+<span class="number">1</span>;</span><br><span class="line">                j-=i-k , i-=i-k;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//01背包</span></span><br><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="comment">//最后一个物品n的状态不是由n+1推来的</span></span><br><span class="line">    <span class="keyword">if</span>(vol&gt;=v[i] &amp;&amp; i==n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,n);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vol&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//要保证vol-v[i]不会越界</span></span><br><span class="line">    <span class="keyword">if</span>(vol-v[i]&gt;=<span class="number">0</span> &amp;&amp; f[i][vol] == f[i+<span class="number">1</span>][vol-v[i]] + w[i])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">        vol-=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时可以通过额外的算法确定dp状态的计算顺序，如贪心排序等，以确保无后效性</p>
</li>
<li><p>有时可在状态空间中运用等效手法对状态进行缩放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    rep(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;i) <span class="keyword">continue</span>;</span><br><span class="line">        f[i][j]=f[i][j-i]; <span class="comment">//缩放</span></span><br><span class="line">        rep(k,<span class="number">0</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">            f[i][j]=min(f[i][j],f[k][j-i+k] + k*(gs[i]-gs[k]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p><a href="http://bamboo-rat.cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">戳这里</a></p>
<hr>
<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><ul>
<li><p>一般表示：f[i][j]-区间[i,j]的属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 长度 <span class="number">2</span>-&gt;n</span><br><span class="line">    <span class="keyword">for</span> 左端点 <span class="number">1</span>-&gt;n-len+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> 区间断点 l-&gt;r<span class="number">-1</span></span><br><span class="line">rep(len,<span class="number">2</span>,n)&#123;</span><br><span class="line">        rep(l,<span class="number">1</span>,n-len+<span class="number">1</span>)&#123;</span><br><span class="line">            r=l+len<span class="number">-1</span>;</span><br><span class="line">            rep(k,l,r<span class="number">-1</span>)&#123;</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[l][r]+=s[r]-s[l<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在设置区间断点k时，一定要注意是否会出现k不同而子区间相同的情况，即决策的互斥性</p>
</li>
<li><p>任意选择一个位置断开，复制成2倍长度的链”的方法，是解决dp中环形结构的常用手段之一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rep(i,n+<span class="number">1</span>,<span class="number">2</span>*n)&#123;</span><br><span class="line">        op[i]=op[i-n];</span><br><span class="line">        a[i]=a[i-n];</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    rep(len,<span class="number">2</span>,n)&#123; <span class="comment">// 长度</span></span><br><span class="line">        rep(l,<span class="number">1</span>,<span class="number">2</span>*n-len+<span class="number">1</span>)&#123; <span class="comment">// 左端点</span></span><br><span class="line">            <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            rep(p,l,r<span class="number">-1</span>)&#123; <span class="comment">// 区间断点</span></span><br><span class="line">                <span class="keyword">if</span>(op[p+<span class="number">1</span>]==<span class="string">'t'</span>) &#123;</span><br><span class="line">                    f[l][r][<span class="number">0</span>]=max(f[l][r][<span class="number">0</span>],f[l][p][<span class="number">0</span>]+f[p+<span class="number">1</span>][r][<span class="number">0</span>]);</span><br><span class="line">                    f[l][r][<span class="number">1</span>]=min(f[l][r][<span class="number">1</span>],f[l][p][<span class="number">1</span>]+f[p+<span class="number">1</span>][r][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> x=f[l][p][<span class="number">0</span>],y=f[l][p][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> z=f[p+<span class="number">1</span>][r][<span class="number">0</span>],w=f[p+<span class="number">1</span>][r][<span class="number">1</span>];</span><br><span class="line">                    f[l][r][<span class="number">0</span>]=max(f[l][r][<span class="number">0</span>],max(x*z, max(x*w, max(y*z, y*w))));</span><br><span class="line">                    f[l][r][<span class="number">1</span>]=min(f[l][r][<span class="number">1</span>],min(x*z, min(x*w, min(y*z, y*w))));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于计数类的dp问题，通常一个状态的各个决策之间满足“加法原则”，而每个决策划分的几个子状态之间满足“乘法原则”。在设计状态转移方程的决策方式与划分方法时，一个状态的所有决策之间必须具有互斥性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len&lt;=n; len+=<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>; l+len<span class="number">-1</span>&lt;=n; l++)&#123;</span><br><span class="line">               <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">               <span class="keyword">if</span>(len==<span class="number">1</span>) f[l][r]=<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(s[l]==s[r])&#123;</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> k=l; k&lt;r; k+=<span class="number">2</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(s[k]==s[r])</span><br><span class="line">                           f[l][r] = ((ll)f[l][r] + (ll)f[l][k]*f[k+<span class="number">1</span>][r<span class="number">-1</span>])%mod;    </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1><ul>
<li>一般以节点从深到浅（子树从小到大，自下而上）的顺序作为DP的“阶段”</li>
<li>DP状态表示中，第一维通常是节点编号（代表以该节点为根的子树），大多时候采用递归的方式实现动态规划</li>
<li><p>对于每个节点x，先递归在它的每个子节点进行dp，回溯时，从子节点向节点x进行状态转移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y);</span><br><span class="line">        f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">        f[x][<span class="number">0</span>]+=max(f[y][<span class="number">1</span>],f[y][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">1</span>]+=h[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二次扫描换根dp：这种问题一般出现在无根树确定根节点。一般先子下而上进行树形dp，然后对整棵树进行一次dfs，自上而下进行换根计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//d:dp数组，f:答案数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dp(y);</span><br><span class="line">        <span class="keyword">if</span>(deg[y]==<span class="number">1</span>) d[x]+=e[i].w;</span><br><span class="line">        <span class="keyword">else</span> d[x]+=min(e[i].w,d[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];~i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(deg[x]==<span class="number">1</span>) f[y]=d[y]+e[i].w;</span><br><span class="line">        <span class="keyword">else</span> f[y] = d[y]+min(f[x]-min(d[y],e[i].w) , e[i].w);</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="环形dp与后效性处理"><a href="#环形dp与后效性处理" class="headerlink" title="环形dp与后效性处理"></a>环形dp与后效性处理</h1><blockquote>
<ul>
<li><strong>环形</strong><ul>
<li>在某个星球上，一天由 N 个小时构成，我们称0点到1点为第1个小时、1点到2点为第2个小时，以此类推。<br>在第 i 个小时睡觉能够恢复Ui点体力。<br>在这个星球上住着一头牛，它每天要休息B个小时。<br>它休息的这B个小时不一定连续，可以分成若干段，但是在每段的第一个小时，它需要从清醒逐渐入睡，不能恢复体力，从下一个小时开始才能睡着。<br>为了身体健康，这头牛希望遵循生物钟，每天采用相同的睡觉计划。<br>另外，因为时间是连续的，即每一天的第N个小时和下一天的第1个小时是相连的（N点等于0点），这头牛只需要在每N个小时内休息够B个小时就可以了。<br>请你帮忙给这头牛安排一个睡觉计划，使它每天恢复的体力最多。</li>
<li>此题将环中n(0)和1间断开，分别对n(0)和1点没有睡觉和正在睡觉的情况做dp，取二者最优值.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//https://www.acwing.com/activity/content/code/content/171286/</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">2</span>][N][<span class="number">10</span>],w[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        clr(f,<span class="number">-0x3f</span>);</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">            rep(j,<span class="number">0</span>,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>) f[i&amp;<span class="number">1</span>][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i&amp;<span class="number">1</span>][j][<span class="number">0</span>]=max(f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][<span class="number">0</span>],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">                    f[i&amp;<span class="number">1</span>][j][<span class="number">1</span>]=max(f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">0</span>],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=-inf;</span><br><span class="line">        ans=max(f[n&amp;<span class="number">1</span>][m][<span class="number">0</span>],f[n&amp;<span class="number">1</span>][m][<span class="number">1</span>]);</span><br><span class="line">        clr(f,<span class="number">-0x3f</span>);</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=w[<span class="number">1</span>];</span><br><span class="line">        rep(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">            rep(j,<span class="number">0</span>,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>) f[i&amp;<span class="number">1</span>][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i&amp;<span class="number">1</span>][j][<span class="number">0</span>]=max(f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][<span class="number">0</span>],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">                    f[i&amp;<span class="number">1</span>][j][<span class="number">1</span>]=max(f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">0</span>],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,f[n&amp;<span class="number">1</span>][m][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt;* **后效性处理**</span><br><span class="line">&gt;+ 当遇到状态转换有后效性时，可是尝试用列方程组并通过高斯消元求出当前阶段每一个状态的解</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">/*给定一张 N*M 的棋盘，有一个机器人处于(x,y)位置。</span></span><br><span class="line"><span class="comment">这个机器人可以进行很多轮行动，每次等概论地随机选择停在原地、向左移动一格、向右移动一格或向下移动一格。</span></span><br><span class="line"><span class="comment">当然机器人不能移出棋盘。</span></span><br><span class="line"><span class="comment">求机器人从起点走到最后一行的任意一个位置上，所需行动次数的数学期望值。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(a,i,n) printf(<span class="meta-string">"c"</span>,a,<span class="meta-string">" \n"</span>[i==n])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll linf=(<span class="number">1l</span>l&lt;&lt;<span class="number">62</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">4e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;<span class="keyword">int</span> sign=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;c=getchar();<span class="keyword">if</span>(c==<span class="string">'-'</span>)sign=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;c=getchar();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>);</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> a[N][N],f[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//主元化1</span></span><br><span class="line">        <span class="keyword">double</span> r=a[i][i];</span><br><span class="line">        a[i][i]/=r,a[i][i+<span class="number">1</span>]/=r;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m) a[i][m+<span class="number">1</span>]/=r;</span><br><span class="line">        <span class="comment">//下面其他列化0</span></span><br><span class="line">        <span class="keyword">double</span> t=a[i+<span class="number">1</span>][i];</span><br><span class="line">        a[i+<span class="number">1</span>][i]=<span class="number">0</span>, a[i+<span class="number">1</span>][i+<span class="number">1</span>]-=t*a[i][i+<span class="number">1</span>], a[i+<span class="number">1</span>][m+<span class="number">1</span>]-=t*a[i][m+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i;i--)&#123;</span><br><span class="line">        a[i<span class="number">-1</span>][m+<span class="number">1</span>]-=a[i][m+<span class="number">1</span>]*a[i<span class="number">-1</span>][i];</span><br><span class="line">        a[i<span class="number">-1</span>][i]=<span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">".4lf\n"</span>,<span class="number">2.0</span>*(n-x));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=x;i--)&#123;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">2.0</span>/<span class="number">3</span>, a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">-1.0</span>/<span class="number">3</span>, a[<span class="number">1</span>][m+<span class="number">1</span>]=f[i+<span class="number">1</span>][<span class="number">1</span>]/<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        a[m][m<span class="number">-1</span>]=<span class="number">-1.0</span>/<span class="number">3</span>, a[m][m]=<span class="number">2.0</span>/<span class="number">3</span>, a[m][m+<span class="number">1</span>]=f[i+<span class="number">1</span>][m]/<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;m;j++)</span><br><span class="line">            a[j][j<span class="number">-1</span>]=<span class="number">-1.0</span>/<span class="number">4</span>, a[j][j]=<span class="number">3.0</span>/<span class="number">4</span>, a[j][j+<span class="number">1</span>]=<span class="number">-1.0</span>/<span class="number">4</span>, a[j][m+<span class="number">1</span>]=f[i+<span class="number">1</span>][j]/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">        gauss();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) f[i][j]=a[j][m+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,f[x][y]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><p><a href="http://bamboo-rat.cn/tags/%E7%8A%B6%E5%8E%8Bdp/" target="_blank" rel="noopener">习题戳这里</a></p>
<blockquote>
<ul>
<li>三进制，主要是预处理<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,vis[N];</span><br><span class="line"><span class="keyword">int</span> three[<span class="number">11</span>],dig[<span class="number">60000</span>][<span class="number">20</span>];<span class="comment">//三进制数，每一个数的每一位（0,1,2）</span></span><br><span class="line"><span class="keyword">int</span> mp[N][N],ans,dp[<span class="number">60000</span>][<span class="number">20</span>];<span class="comment">//dp[i][j]第i种状态以j为结尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    three[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        three[i]=three[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> tem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;three[<span class="number">10</span>];i++)&#123;</span><br><span class="line">        tem=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            dig[i][j]=tem%<span class="number">3</span>;</span><br><span class="line">            tem/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    init();</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        INIT(mp,inf);INIT(dp,inf);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            mp[a<span class="number">-1</span>][b<span class="number">-1</span>]=mp[b<span class="number">-1</span>][a<span class="number">-1</span>]=min(mp[a<span class="number">-1</span>][b<span class="number">-1</span>],c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一个走的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            dp[three[i]][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=inf,flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta=<span class="number">0</span>;sta&lt;three[n];sta++)&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dig[sta][i]==<span class="number">0</span>)flag=<span class="number">0</span>;<span class="comment">//如果有0说明还有点没走过</span></span><br><span class="line">                <span class="keyword">if</span>(dp[sta][i]==inf)<span class="keyword">continue</span>;<span class="comment">//如果当前状态i点没走过，则不可用</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp[i][j]==inf||dig[sta][j]==<span class="number">2</span>)<span class="keyword">continue</span>;<span class="comment">//通过当前状态推导下一个状态，如果当前状态下j已经走过两次了，那么下一个状态必然不能再到j</span></span><br><span class="line">                    dp[sta+three[j]][j]=min(dp[sta+three[j]][j],dp[sta][i]+mp[i][j]);<span class="comment">//sta+three[j]相当于第j位+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//当存在所有点都走过的状态时就更新答案</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                ans=min(ans,dp[sta][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==inf) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><blockquote>
<ul>
<li>记忆化搜索，用f数组保存dfs中除limit外的所有状态，包括前导零标记等。</li>
</ul>
</blockquote>
<p><a href="https://www.acwing.com/solution/acwing/content/8135/" target="_blank" rel="noopener">度的数量</a><br><a href="https://www.acwing.com/solution/acwing/content/8136/" target="_blank" rel="noopener">Windy数</a><br><a href="https://www.acwing.com/solution/acwing/content/8137/" target="_blank" rel="noopener">计数问题</a><br><a href="https://www.acwing.com/solution/acwing/content/8138/" target="_blank" rel="noopener">圆形数字</a><br><a href="https://www.acwing.com/solution/acwing/content/8139/" target="_blank" rel="noopener">启示录</a><br><a href="https://www.acwing.com/solution/acwing/content/8140/" target="_blank" rel="noopener">月之迷</a></p>
]]></content>
      <categories>
        <category>进阶训练</category>
      </categories>
      <tags>
        <tag>进阶训练</tag>
      </tags>
  </entry>
  <entry>
    <title>由数据范围反推时间复杂度与算法</title>
    <url>/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 1e7 为最佳。</p>
<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>
<ul>
<li>n≤30, 指数级别, dfs+剪枝，状态压缩dp</li>
<li>n≤100 =&gt; O(n3)，floyd，dp</li>
<li>n≤1000 =&gt; O(n2)，O(n2logn)，dp，二分</li>
<li>n≤10000 =&gt; O(n∗√n)，块状链表</li>
<li>n≤100000 =&gt; O(nlogn) =&gt; 各种sort，线段树、树状数组、set/map、heap、dijkstra+heap、spfa、求凸包、求半平面交、二分</li>
<li>n≤1000000 =&gt; O(n), 以及常数较小的 O(nlogn) 算法 =&gt; hash、双指针扫描、kmp、AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa</li>
<li>n≤10000000 =&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数</li>
<li>n≤109 =&gt; O(√n)，判断质数</li>
<li>n≤1018 =&gt; O(logn)，最大公约数</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶训练-数据结构进阶</title>
    <url>/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>并查集<br><a id="more"></a></p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n==f[n]? n: f[n] = find(f[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    f[find(x)] = find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/solution/acwing/content/8221/" target="_blank" rel="noopener">并查集</a></p>
<blockquote>
<ul>
<li>带权并查集一般维护x到f[x]之间的关系</li>
</ul>
</blockquote>
<p><a href="https://www.acwing.com/solution/acwing/content/8223/" target="_blank" rel="noopener">带权并查集</a></p>
<p><a href="https://www.acwing.com/solution/acwing/content/8225/" target="_blank" rel="noopener">奇偶游戏-带权并查集</a></p>
<p><a href="https://www.acwing.com/solution/acwing/content/8226/" target="_blank" rel="noopener">食物链-扩展域并查集and种类并查集</a></p>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x += x&amp;-x) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x -= x&amp;-x) ans += c[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=s;i+=lowbit(i))</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&lt;=s;j+=lowbit(j))</span><br><span class="line">			tree[i][j]+=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i-=lowbit(i))</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;<span class="number">0</span>;j-=lowbit(j))</span><br><span class="line">			cnt+=tree[i][j];</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逆序数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        INIT(c,<span class="number">0</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">        m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        repd(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,a[i])-b;</span><br><span class="line">            ans+=query(t<span class="number">-1</span>);</span><br><span class="line">            add(t,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维偏序，维护左下角最值</span></span><br><span class="line">sort(p+<span class="number">1</span>,p+q+<span class="number">1</span>,cmp);  <span class="comment">//按其中一维排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,now;i&lt;=q;i++) &#123;</span><br><span class="line">    now=query(p[i].y)+p[i].val;</span><br><span class="line">    ans=max(ans,now);</span><br><span class="line">    add(p[i].y,now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/solution/acwing/content/8230/" target="_blank" rel="noopener">区间修改单点查询</a></p>
<p><a href="https://www.acwing.com/activity/content/code/content/97640/" target="_blank" rel="noopener">区间修改区间查询</a></p>
<p><a href="http://bamboo-rat.cn/I%20hate%20it%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC/" target="_blank" rel="noopener">区间最值</a></p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><a href="http://bamboo-rat.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="noopener">懒是第一生产力</a></p>
<p><a href="https://www.acwing.com/activity/content/code/content/98449/" target="_blank" rel="noopener">区间最大子段和</a></p>
<p><a href="https://www.acwing.com/activity/content/code/content/98562/" target="_blank" rel="noopener">区间最大公约数</a></p>
]]></content>
      <categories>
        <category>进阶训练</category>
      </categories>
      <tags>
        <tag>进阶训练</tag>
      </tags>
  </entry>
  <entry>
    <title>线性基例题</title>
    <url>/%E7%BA%BF%E6%80%A7%E5%9F%BA%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>最大异或和，第k小异或和<br><a id="more"></a></p>
<ul>
<li><p><a href="//https://www.luogu.org/problemnew/show/P3812">最大异或和</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(d) scanf(<span class="meta-string">"%d"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sll(d) scanf(<span class="meta-string">"%lld"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(d) printf(<span class="meta-string">"%d"</span>,d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pll(d) printf(<span class="meta-string">"%lld"</span>,d)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll d[N],a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    repd(i,<span class="number">51</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1l</span>l&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]) x^=d[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="comment">//"高斯消元，使得对于任意存在于线性基的二进制位i，至多只有一个b[j]满足第i位为 1。可求第k小异或和,最大就全异或"</span></span><br><span class="line">                repd(k,i<span class="number">-1</span>,<span class="number">0</span>) <span class="keyword">if</span>(d[k]&amp;&amp;(d[i]&amp;(<span class="number">1l</span>l&lt;&lt;k))) d[i]^=d[k];</span><br><span class="line">                rep(k,i+<span class="number">1</span>,<span class="number">51</span>) <span class="keyword">if</span>(d[k]&amp;(<span class="number">1l</span>l&lt;&lt;i)) d[k]^=d[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    repd(i,<span class="number">51</span>,<span class="number">0</span>) res^=d[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    S(n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        Sll(a[i]);</span><br><span class="line">        add(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Pll(ans());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3949" target="_blank" rel="noopener">第k小异或和</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(d) scanf(<span class="meta-string">"%d"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLL(d) scanf(<span class="meta-string">"%lld"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(d) printf(<span class="meta-string">"%d\n"</span>,d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL(d) printf(<span class="meta-string">"%lld\n"</span>,d)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,q,tot;</span><br><span class="line">ll a[N],d[<span class="number">100</span>],k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    repd(i,<span class="number">61</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1l</span>l&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]) x^=d[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                tot++;</span><br><span class="line">                repd(k,i<span class="number">-1</span>,<span class="number">0</span>) <span class="keyword">if</span>(d[k]&amp;&amp;(d[i]&amp;(<span class="number">1l</span>l&lt;&lt;k))) d[i]^=d[k];</span><br><span class="line">                rep(k,i+<span class="number">1</span>,<span class="number">61</span>) <span class="keyword">if</span>(d[k]&amp;(<span class="number">1l</span>l&lt;&lt;i)) d[k]^=d[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ans</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tot&lt;n)k--;<span class="comment">//当tot&lt;n时整体可异或出0，但线性基里面不会</span></span><br><span class="line">    <span class="keyword">if</span>(k&gt;=(<span class="number">1l</span>l&lt;&lt;tot))<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//超过能异或出的数的个数上限</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//k的第i位为1时，异或第i个线性基中的元素</span></span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">61</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>) ans^=d[i];</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    S(t);</span><br><span class="line">    rep(Case,<span class="number">1</span>,t)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, Case);</span><br><span class="line">        INIT(d,<span class="number">0</span>);tot=<span class="number">0</span>;</span><br><span class="line">        S(n);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            SLL(a[i]);</span><br><span class="line">            add(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        S(q);</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            SLL(k);</span><br><span class="line">            PLL(ans(k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2844" target="_blank" rel="noopener">给出一个数，求在不去重异或集合中的位置</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(d) scanf(<span class="meta-string">"%d"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLL(d) scanf(<span class="meta-string">"%lld"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(d) printf(<span class="meta-string">"%d\n"</span>,d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL(d) printf(<span class="meta-string">"%lld\n"</span>,d)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">10086</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N],d[<span class="number">100</span>],num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    x%=mod;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) (ans*=x)%=mod;</span><br><span class="line">        (x*=x)%=mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    repd(i,Size,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(x&gt;&gt;i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]) x^=d[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num++;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    S(n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        S(a[i]);</span><br><span class="line">        add(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    S(q);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,Size)</span><br><span class="line">        <span class="keyword">if</span>(d[i]) vec.push_back(i);</span><br><span class="line">    rep(i,<span class="number">0</span>,vec.size()<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span>(q&gt;&gt;vec[i] &amp; <span class="number">1</span>)</span><br><span class="line">            (ans+=(<span class="number">1</span>&lt;&lt;i))%=mod;</span><br><span class="line">    P((qpow(<span class="number">2</span>,(n-num))%mod*ans%mod+<span class="number">1</span>)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶训练-数论</title>
    <url>/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83-%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>质数，约数（反素数，除法分块），欧拉函数，同余（费马小，欧拉定理，欧拉降幂，exgcd，中国剩余定理，乘法逆元，线性同余方程，高次同余方程），矩阵快速幂，高斯消元，线性空间（生成子集，线性相关和线性无关，基底，矩阵的秩，线性基），组合数（二项式定理，多重集的排列数和组合数，卢卡斯定理，卡特兰数），容斥原理（多重集组合数），莫比乌斯函数（莫比乌斯反演），概率与数学期望，0/1分数规划，博弈论之SG函数（NIM博弈，公平组合游戏）<br><a id="more"></a></p>
<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><ul>
<li>对于一个足够大的整数N，不超过N的质数大约有N/lnN个；</li>
<li>求出L，R(1&lt;=L&lt;=R&lt;=2^31,R-L&lt;=1e6)之间相邻两个质数的差的最大值是多少。解：筛出2~sqrt(R)间所有的素数，用这些素数筛掉[L,R]之间的合数，然后扫描即可。</li>
<li>将N!分解质因数。解：N！的每个质因子都不会超过N，将每个质因子p筛出来，然后考虑阶乘N!中有多少个质因子p。N！中p的个数就等于1~N中每个数包含p的个数之和。含一个p的就是N/p个，两个p的就是N/p^2个，因为在统计2个的时候已经统计过一个的，所以直接加上即可。所以p的因子个数为<code>N/p+N/p^2+...+N/p^(lgN/lgp)</code>个，枚举每个因子即可。</li>
</ul>
</blockquote>
<h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><blockquote>
<ul>
<li>若正整数N被唯一分解为<code>N=p1^c1*p2^c2*...*pm^cm</code>，则N的正约数集合可写作：<code>{p1^b1*p2^b2*p3^b3*...*pm^bm}，其中0&lt;=bi&lt;=ci</code>;</li>
<li>N的正约数个数为<code>(c1+1)*(c2+1)*...*(cm+1)</code>;</li>
<li>N的所有正约数的和为<code>(1+p1+p1^2+...+p1^c1)*(1+p2+p2^2+...+p2^c2)*(1+p3+p3^2+...+p3^c3)*...*(1+pm+pm^2+...+pm^cm)</code>;</li>
<li>一个整数N的约数个数上届为2sqrt(N)。</li>
<li>1~N中每个数的约数个数的总和大约为NlgN。</li>
</ul>
<ul>
<li>反素数：对于任何正整数x，其约数个数记为g(x)。如果对于任意的0 &lt; i &lt; x，都有g(x)&gt;g(i)，那么x称为反质数。现给定一个数N(1&lt;=N&lt;=2e9)，求不超过N的最大反质数x。<ul>
<li>引理1: 1~N中最大的反质数，就是1~N中约数个数最多的数中最小的一个；</li>
<li>引理2：1~N中任何数的不同质因子都不会超过10个，且所有质因子的指数综合不超过30；</li>
<li>引理3：x的质因子是连续的若干个最小的质数，且指数单调递减</li>
<li>dfs尝试一次确定前10个质数的指数，并满足单调递减，总乘积不超过N，同时记录约数个数即可(以上证明详见《算法竞赛进阶指南》P140)。</li>
</ul>
</li>
<li>余数之和：给定正整数n和k，求(kmod1)+(kmod2)+(kmod3)+…+(kmodn)的值。(1&lt;=n,k&lt;=1e9).<ul>
<li>转化为<code>n*k-∑(k/i)i</code>。</li>
<li>除法分块，对于任意i∈[1,k]，k/i的值不超过2*sqrt(k)个。对于每一块最左边的元素x，与之同一块的最大元素为g(x)=k/(k/x).</li>
<li>故上式对于每一块中的<code>(k/i)*i=(k/x)*i</code>,是[x,g(x)]的以(k/x)为公差的等差数列，整个式子∑(k/i)*i就是对每一块进行等差数列求和。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><blockquote>
<ul>
<li><a href="http://bamboo-rat.cn/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8%E3%80%81%E8%AF%81%E6%98%8E%E5%8F%8A%E6%B1%82%E6%B3%95/" target="_blank" rel="noopener">欧拉函数的性质、求法</a></li>
</ul>
</blockquote>
<h1 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h1><blockquote>
<ul>
<li>基本概念：<ul>
<li>同余类：同一个集合中所有数模m同余，称他们为一个模m的同余类</li>
<li>完全剩余系：模m的同余类一共有m个，他们构成m的完全剩余系</li>
<li>简化剩余系：1~m中<strong>与m互质</strong>的数代表的同余类共有φ(m)个，他们构成m的简化剩余系。简化剩余系关于m乘法封闭，即如果a,b属于简化剩余系，则axb也属于简化剩余系。</li>
</ul>
</li>
</ul>
<ul>
<li>费马小定理：若p是质数，对于任意整数a，有a^p≡a(mod p);</li>
<li>欧拉定理：若正整数a,n互质，则a^φ(n)≡1(mod p),其中φ(n)为欧拉函数。  </li>
</ul>
<ul>
<li>欧拉定理的推论（欧拉降幂）：<ul>
<li>当正整数a,n互质，对于任意正整数b，a^b≡a^(b mod φ(n)) (mod n) </li>
<li>当a，n不互质且b&gt;φ(n)时，有a^b≡a^(b mod φ(n) + φ(n)) (mod n) </li>
</ul>
</li>
<li>扩展欧几里得：对于任意整数a,b，存在一对整数x,y，满足ax+by=gcd(a,b)。<ul>
<li>当b=0时，显然有一对整数x=1，y=0，使得<code>a*1+0*0=gcd(a,0)</code>;</li>
<li>当b&gt;0,则gcd(a,b)=gcd(b,a mod b)。假设存在一对整数x,y，满足<code>b*x+(a mod b)*y=gcd(b,a mod b)</code>，因为<code>bx+(a mod b)y=bx+(a-b(a/b))y=ay+b(x-(a/b)y)</code>，所以令x’=y,y’=x-(a/b)y，就得到了ax’+by’=gcd(a,b)。</li>
<li>对于更为一般的方程ax+by=c，它有解<strong>当且仅当d|c</strong>。我们先求出ax+by=d的一组特解x0,y0，然后同时乘上c/d，就得到了ax+by=c的一组特解(c/d)x0,(c/d)y0。<br>事实上，方程ax+by=c的通解可以表示为x=(c/d)x0+k(b/d),y=(c/d)y0-k(a/d) (k∈Z)。<br>其中k取遍整个整数集合，d=gcd(a,b)，x0,y0是ax+by=gcd(a,b)的一组特解。</li>
</ul>
</li>
<li>中国剩余定理：对于形如x≡ai(mod mi)的方程组，x=∑aiMiti，其中Mi为除mi外所有模数的倍数，ti是线性同余方程Miti≡1(mod mi)的一个解。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    LL d=exgcd(b,a%b,x,y);</span><br><span class="line">    ll z=x;x=y;y=z-y*(a/b);</span><br><span class="line">    <span class="keyword">return</span> d; <span class="comment">//返回值为gcd(a,b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><a href="http://bamboo-rat.cn/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E5%85%B7%E4%BD%93%E6%B1%82%E6%B3%95/" target="_blank" rel="noopener">乘法逆元</a></li>
</ul>
<ul>
<li><strong>线性同余方程</strong><ul>
<li>给定整数a,b,m，求一个整数x满足ax≡b(mod m)，或者给出无解。<ul>
<li>ax≡b(mod m)等价于求<code>a·x-b</code>是m的倍数，不妨设为-y倍。于是该方程可改写为<code>a·x-b=-y·m</code>，即<code>a·x+m·y=b</code>，可以用扩欧求解。</li>
<li>此线性同余方程有解当且仅当gcd(a,m)|b。</li>
<li>在有解时，用扩欧求出一组整数x0,y0，满足<code>a·x0+m·y0=gcd(a,m)</code>，然后x=x0*b/gcd(a,m)就是原线性同余方程的一个解。</li>
<li>方程的通解是所有模m/gcd(a,m)与x同余的整数。</li>
<li><a href="https://www.acwing.com/activity/content/code/content/89033/" target="_blank" rel="noopener">例题：同余方程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>高次同余方程<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">baby_step_giant_step</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Hash;Hash.clear();</span><br><span class="line">    b%=p;</span><br><span class="line">    <span class="keyword">int</span> t=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> val=(<span class="keyword">long</span> <span class="keyword">long</span>)b*power(a,j,p)%p;<span class="comment">//b*a^j</span></span><br><span class="line">        Hash[val]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="built_in">pow</span>(a,t,p);<span class="comment">//a^t</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> b==<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> val=power(a,i,p);<span class="comment">//(a^t)^i</span></span><br><span class="line">        <span class="keyword">int</span> j=Hash.find(val)==Hash.end()?<span class="number">-1</span>:Hash[val];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span> &amp;&amp; i*t-j&gt;=<span class="number">0</span>) <span class="keyword">return</span> i*t-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h1><blockquote>
<ul>
<li>构造方式：把长为n的一维向量称为“状态矩阵”，把用于与“状态矩阵”相乘的固定不变的矩阵A称为“转移矩阵”。若状态矩阵中的<strong>第x个数对下一单位时间状态矩阵中的第y个数产生影响</strong>，则把转移矩阵的<strong>第x行第y列</strong>赋予适当的系数。时间复杂度为O(n^3logT)，其中n为状态矩阵长度（一般不会很大），T为递推次数。</li>
<li>以下情况可以考虑用矩阵快速幂优化。<ul>
<li>可以抽象出一个长度为n的一维向量，该向量在每个单位时间发生一次变化。</li>
<li>变化的形式是一个线性递推（只有若干“加法”或“乘一个系数”的运算）。</li>
<li>该递推是在每个时间可能作用于不同的数据上，但本身保持不变。</li>
<li>向量变化时间（即递推次数）很长，但向量长度n不大。</li>
</ul>
</li>
<li><a href="http://bamboo-rat.cn/%E6%9D%AD%E5%B8%88%E8%AE%AD%E7%BB%83%E8%B5%9B3%E6%80%BB%E7%BB%93/#more" target="_blank" rel="noopener">例题：H</a><br><a href="https://www.acwing.com/activity/content/code/content/199311/" target="_blank" rel="noopener">取石头</a></li>
</ul>
</blockquote>
<h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><blockquote>
<ul>
<li>将增广矩阵化为简化阶梯形矩阵求解线性方程组。</li>
</ul>
<ul>
<li>步骤：<ul>
<li>将a[][i]最大的一行放到第i行</li>
<li>将a[i][i]化为1，整行除以a[i][i]</li>
<li>将a[i][i]下面一整列化为0</li>
<li>i取[1,n]</li>
<li>上三角矩阵完成后，倒回去求每一项的值</li>
</ul>
</li>
</ul>
<ul>
<li><p>若高斯消元后，存在系数全为0，常数不为0的行，则方程无解；若系数不全为0的行恰好有n个，则说明主元有n个，方程组有唯一解；若系数不全为零的行有k &lt; n个，则说明主元有k个，自由元有n-k个，方程组有无穷多个解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,r=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=i;</span><br><span class="line">        <span class="comment">//将a[][i]最大的行放上去</span></span><br><span class="line">        rep(k,i+<span class="number">1</span>,n) </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[k][i]) - <span class="built_in">fabs</span>(a[i][i]) &gt; eps) t=k;</span><br><span class="line">        <span class="keyword">if</span>(t!=i)rep(j,i,n+<span class="number">1</span>) swap(a[i][j],a[t][j]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][i]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//a[i][i]化为1</span></span><br><span class="line">        repd(j,n+<span class="number">1</span>,i) a[i][j]/=a[i][i];</span><br><span class="line">        <span class="comment">//a[i][i]左下角化为0</span></span><br><span class="line">        rep(k,i+<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[k][i]) &lt; eps)<span class="keyword">continue</span>;</span><br><span class="line">            repd(j,n+<span class="number">1</span>,i)</span><br><span class="line">                a[k][j] -= a[k][i]*a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        r++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n+<span class="number">1</span>]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不用把右上角全化为0，更新答案即可</span></span><br><span class="line">    repd(i,n,<span class="number">1</span>)</span><br><span class="line">        repd(j,i<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">            a[j][n+<span class="number">1</span>] -= a[j][i] * a[i][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://bamboo-rat.cn/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%A8%A1%E6%9D%BF/" target="_blank" rel="noopener">具体写法</a></p>
</li>
</ul>
</blockquote>
<h1 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h1><blockquote>
<ul>
<li>生成子集：给定若干个a1,a2,a3….ak，若向量b能由它们经过向量加法和标量乘法表示，称向量b能被a1,a2…ak张成。显然，a1,a2…an能张成出的所有向量构成一个线性空间，a1,a2…ak被称为这个线性空间的生成子集。</li>
<li>线性相关与线性无关：任意选择出线性空间中的若干个向量，如果其中存在一个向量能被其他向量张成，则这些向量线性相关，否则称这些向量线性无关。</li>
<li>基底：线性无关的生成子集被称为线性空间的基底，简称基。基的另一种定义是线性空间的<strong>极大线性无关子集</strong>。一个线性空间的<strong>所有基包含的向量个数都相等</strong>，这个数被称为线性空间的维数。</li>
<li>矩阵秩：所有行向量能张成的所有向量构成一个线性空间，这个线性空间的维数被称为矩阵的“行秩”，同理我们可以知道“列秩”，显然行秩等于列秩，都被称为矩阵的秩。在高斯消元后，显然简化阶梯形矩阵的所有非零行向量线性无关。于是，<strong>简化阶梯形矩阵的所有非零行向量就是该线性空间的一个基，非零行向量的个数就是矩阵的秩</strong>。</li>
</ul>
<ul>
<li><strong>线性基</strong>：这里特指异或空间的基。即给定一个线性空间，求出线性基后就可表示出这个线性空间所有的元素。<ul>
<li>给定n个0~2^m-1个整数a1,a2…an，如何求他们的线性基？我们把每个数看成m位二进制数，写成一个n行m列的01矩阵，矩阵中第i行从左到右依次是ai的第m-1,m-2…1,0位（二进制最低位）。把矩阵高斯消元即可。</li>
<li>具体求法：起初简化阶梯矩阵想x[]为全0，x[i]表示矩阵中第一个令在第i位的元素，每插入一个数ai时，扫描ai的二进制位k，如果第k位所对应的列没有元素，则令x[k]=ai；如果第k列有元素，则令ai^=x[i]，然后继续扫描ai后面的二进制位。</li>
<li>显然，ai进行插入操作后，要么进入线性基，要么被异或为0，说明已经可以被基中向量张成。证明：x1^x2…^xm=ai =&gt; x1^x2^…^xm^ai=0。</li>
<li>得到线性基后，假如线性基大小为t，那么我们可以用这些元素张成出2^t个<strong>去重异或集合</strong>，这个集合也是原异或空间选择任意个向量能张成出的最大集合（不包括0）。此外，<strong>不去重异或集合中，每个数出现2^(n-t)次</strong>。其中，<strong>最大的异或和就是将线性基中所有位都异或起来得到的结果</strong>，而最小的异或和就是线性基中的最后一个非零元素或0。<br><strong>当t &lt; n时异或空间可异或出0</strong>。</li>
<li>异或和第k小：若异或空间可异或出0，那么我们要求低k-1小的元素，因为线性基无法张成0。我们把k-1进行二进制分解，如果k-1的第j位等于1，就选取x[t-j]，最后选出的x异或起来就得到了答案。特别的，若k&gt;2^t，则无解。</li>
<li><a href="http://bamboo-rat.cn/%E7%BA%BF%E6%80%A7%E5%9F%BA%E4%BE%8B%E9%A2%98/" target="_blank" rel="noopener">例题</a></li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><blockquote>
<ul>
<li>求法：<ul>
<li>利用C(n,m)=C(n-1,m)+C(n-1,m-1)的性质可以递推求出0&lt;=y&lt;=x&lt;=n的所有组合数C(x,y)，复杂度为O(N^2);</li>
<li>组合数结果一般较大，如果题目要求出C(n,m)对一个数p取模后的值，并且1~n都存在模p的乘法逆元，则可以先计算n! mod p，再计算分母m!(n-m)! mod p的逆元，乘起来得到C(n,m) mod p，复杂度为O(n);</li>
<li>若在计算阶乘过程在把0&lt;=k&lt;=n的每个k! mod p及逆元分别保存在两个数组jc和jc_inv中，则可在O(nlgn)的预处理后，以O(1)的时间回到0&lt;=y&lt;=x&lt;=n的所有组合数<code>C(x,y) mod p=jc[x]·jc_inv[y]·jc_inv[x-y] mod p</code>。</li>
</ul>
</li>
</ul>
<ul>
<li>二项式定理：<code>(ax+by)^n=(k=0-&gt;n)∑C(n,k)·a^k·b^(n-k)·x^k·y^(n-k)</code></li>
<li>多重集的排列数：多重集是的包含重复元素的广义集合。设S={n1·a1,n2·a2,…,nk·ak}是由n1个a1,n2个a2…nk个ak组成的多重集。S的全排列个数为：n!/(n1!·n2!·n3!·…·nk!)。</li>
<li>多重集的组合数：设<strong>r&lt;=min(ni)(i∈[1,k])</strong>，从S中取出r个元素组成一个多重集（不考虑元素的顺序），产生的不同多重集的数量为：C(k+r-1,k-1)</li>
<li>卢卡斯定理:对任意正整数1&lt;=m&lt;=n，有<code>C(n,m)≡C(n mod p,m mod p) · C(n/p,m/p) (mod p)</code>。即将n和m表示为p进制数，对p进制下的每一位分别计算组合数，最后再乘起来。</li>
</ul>
<ul>
<li>卡特兰数：给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为：<code>Catn=C(2n,n)/(n+1)</code>。以下问题都与Catalan数有关：<ul>
<li>n个左括号和n个右括号组成的合法括号序列的数量为Catn</li>
<li>1,2,..,n经过一个栈，形成的合法出栈序列的数量为Catn</li>
<li>n个节点构成的不同二叉树的数量为Catn</li>
<li>在平面直角坐标系上，每一步只能向上或向右走，从(0,0)走到(n,n)并且出两个端点外不接触直线y=x的路线数量为2Cat(n-1)</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><blockquote>
<ul>
<li>设S1,S2,S3…Sn为有限集合，|S|表示集合S的大小，则：|∪Si|=∑|Si|-∑|Si ∩ Sj|+∑|Si ∩ Sj ∩ Sk|-∑|Si ∩ Sj ∩ Sk ∩Sl|+…+(-1)^(n+1)|S1 ∩ S2 ∩…∩ Sn|。</li>
<li>多重集的组合数:设S={n1·a1,n2·a2,…,nk·ak}。设n=∑ni，对于任意整数r&lt;=n，从S中取出r个元素组成一个多重集（不考虑顺序），产生的不同多重集的数量为：<code>C(k+r+1,k-1)-∑C(k+r-ni-2,k-1)+∑C(k+r-ni-nj-3,k-1)-...+(-1)^k·C(k+r-∑ni-（k+1）,k-1)</code></li>
<li><a href="https://www.acwing.com/problem/content/216/" target="_blank" rel="noopener">Devu与鲜花</a>:Devu有N个盒子，第i个盒子中有Ai枝花。同一个盒子内的花颜色相同，不同盒子内的花颜色不同。Devu要从这些盒子中选出M枝花组成一束，求共有多少种方案。若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。结果需对109+7取模之后方可输出。此题等价于多重集S中选出M个原色能产生的不同多重集的数量。</li>
</ul>
</blockquote>
<h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h1><blockquote>
<ul>
<li>将N分解质因数N=p1^c1·p2^c2·p3^c3…pm^cm。当N包含相等的质因子时，μ(N)=0；当N的所有质因子各不相同时，若N有偶数个质因子，μ(N)=1，若N有奇数个质因子，μ(N)=-1。</li>
<li>若只求一项莫比乌斯函数，则分解质因数即可计算。若求1~N的每一项莫比乌斯函数，可以用埃拉托斯特尼筛法计算：把所有μ值初始化为1。接下来，对于筛出的每个质数p，令μ(p)=-1，并扫描p的倍数x=2p,3p,…(n/p)·p，检查x能否被p^2整除。若能，则令μ(x)=0，否则令μ(x)=-μ(x)。</li>
<li>莫比乌斯反演：若g(x)=∑f(d),其中x|d，则f(x)=∑μ(d/x)*g(d)，其中x|d<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) miu[i]=<span class="number">1</span>,v[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">    miu[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)&#123;</span><br><span class="line">        v[j]=i;</span><br><span class="line">        <span class="keyword">if</span>((j/i)%i==<span class="number">0</span>) miu[j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> miu[j]*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="概率与数学期望"><a href="#概率与数学期望" class="headerlink" title="概率与数学期望"></a>概率与数学期望</h1><blockquote>
<ul>
<li>性质：数学期望是线性函数，满足<code>E(aX+bY)=a*E(X)+b*E(Y)</code>。此性质非常重要，是我们能都对数学期望进行递推求解的基本依据。如：掷一个骰子的期望E(x)=(1+2+3+4+5+6)/6=3.5。掷两个骰子的点数可以表示为随机变量2X，于是E(2x)=2E(x)=7;</li>
</ul>
</blockquote>
<h1 id="0-1分数规划"><a href="#0-1分数规划" class="headerlink" title="0/1分数规划"></a>0/1分数规划</h1><blockquote>
<ul>
<li>给定整数a1~an和b1~bn，求一组解xi(1 &lt;= i &lt;= n),使∑ai·xi/∑bi·xi最大化。即个特定n对整数ai,bi，从中选出若干对，使选出的数对的a之和与b之和商最大。</li>
</ul>
<ul>
<li>实数域二分答案（商）。check方式：<ul>
<li>对于当前答案ans，如果存在一组解，使得∑ai·xi/∑bi·xi&gt;=ans，即∑(ai-ans·bi)·xi&gt;=0，则有比ans更大的答案满足条件，令l=mid，否则令r=mid。</li>
<li>因为每一组的ai-ans·bi可直接算出来，所以我们只需要将所有的正值加起来就可以取得最大值，若最大值满足上述条件，则存在更优解。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="博弈论与SG函数"><a href="#博弈论与SG函数" class="headerlink" title="博弈论与SG函数"></a>博弈论与SG函数</h1><blockquote>
<ul>
<li>NIM博弈：给定n堆物品，第i堆中有Ai个物品，两名玩家轮流行动，每次从某一堆中取走若干个物品，可以全拿，但是不能不拿。拿走最后一件物品者获胜，两人取最优策略，问能否先手必胜。<ul>
<li>先手必胜，当且仅当A1 xor A2 xor A3… xor An 不为0。</li>
<li>证明：如果A1 xor A2 xor…xor An=x!=0，设x的二进制位表示下最高位的1在第k位，那么至少存在一堆石子Ai，它的第k位是1。显然Ai xor x &lt; Ai,从Ai中拿走一部分石子，使得Ai=Ai xor x，就得到了一个各堆石子数异或和为0的局面。对于任意一个石子数异或和为0的局面，无论怎么拿，异或和都不等于0，即必败。</li>
</ul>
</li>
<li>公平组合游戏ICG：若一个游戏满足一下条件则称其为公平组合游戏。NIM博弈属于公平组合游戏。<ul>
<li>由两名玩家交替行动</li>
<li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关</li>
<li>不能行动的玩家判负</li>
</ul>
</li>
<li>有向图游戏：给定一个有向无环图，图中有唯一起点，在起点上放一枚棋子。两名玩家交替地把这枚棋子沿着有向边进行移动，每次可以移动一步，无法移动者负。任何一个公平组合游戏都可以转化为有向图游戏。具体方法：把每个局面看成图中的一个节点，并且每个局面沿着合法行动能到达的下一个局面连有向边。</li>
<li>Mex运算：设S表示一个非负整数集合。定义mex(S)为求出<strong>不属于集合S的最小非负整数</strong>的运算。</li>
<li>SG函数：在有向图游戏中，对于每个节点x，设从x出发共k条有向边，分别到达节点y1,y2,y3…yk，定义SG(x)为x的后继节点y1,y2…yk的SG函数值构成的集合再执行mex运算的结果，即：<code>SG(x)=mex({SG(y1),SG(y2)...SG(yk)})</code>。整个有向图G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G)=SG(s)。</li>
</ul>
<ul>
<li><p>有向图游戏的和：设G1,G2…Gm是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1,G2,G3…Gn的和。有向图游戏的和的SG函数值等于它包含的各个字游戏SG函数值得异或和，即：<code>SG(G)=SG(G1) xor SG(G2)...xor SG(Gm)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSG</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sg,<span class="number">0</span>,<span class="keyword">sizeof</span>(sg));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//当前堆中有i个石头</span></span><br><span class="line">        <span class="built_in">memset</span>(Hash,<span class="number">0</span>,<span class="keyword">sizeof</span>(Hash));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;f[j]&lt;=i;j++)</span><br><span class="line">            Hash[sg[i-f[j]]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(Hash[t]) t++;</span><br><span class="line">        sg[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/221/" target="_blank" rel="noopener">例题：剪纸游戏</a></p>
</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>进阶训练</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶训练-搜索</title>
    <url>/%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0-%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>树与图的遍历，DFS，剪枝，迭代加深，BFS，双端队列BFS，优先队列BFS，A<em>，K短路，IDA</em><br><a id="more"></a></p>
<h1 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h1><blockquote>
<ul>
<li>DFS序：每个节点x的编号在序列中恰好出现两次。设这两次出现的位置为L[x]和R[x]，那么闭区间[L[x],R[x]]就以x为根的子树的DFS序。</li>
<li>树的重心，树的深度，图的连通块划分</li>
<li>拓扑排序：拓扑排序可以判定有向图是否存在环。如果结果序列长度小于图中点的数量，则说明某些节点未遍历，进而说明有环。</li>
</ul>
</blockquote>
<h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><blockquote>
<ul>
<li>优化搜索顺序。在一些搜索问题中，搜索树的各个层次、各个分支建的顺序不是固定的，不同的搜索顺序会产生不同的搜索树状态，其规模大小也相差甚远。如：<a href="https://www.acwing.com/problem/content/167/" target="_blank" rel="noopener">小猫爬山</a>时按照重量递减的顺序进行搜索，<a href="https://www.acwing.com/problem/content/168/" target="_blank" rel="noopener">数独</a>问题中优先搜索“能填的合法数字”最少的位置。</li>
<li>排除等效冗余。当我们能判定从搜索树的当前节点上沿着几天不同分支可达的子树是等效的，那么只需要对其中一条分支执行搜索。</li>
<li>可行性剪枝。有的分支永远无法到达边界，立即执行回溯。</li>
<li>最优性剪枝。在最优化搜索问题中，如果当前的代价已经超过了当前搜到的最优解，那么就不用继续往下搜索了，执行回溯。</li>
<li>记忆化。可以记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。</li>
</ul>
</blockquote>
<h1 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h1><blockquote>
<ul>
<li>DFS每次选定一个分支，不断深入，直到递归边界才回溯。当一颗搜索树的分支数目非常多，并且答案再某个较浅的节点上，如果在一开始就选错了分支，就很有可能在不包含答案的深子树上浪费很多时间。</li>
<li>我们可以从小到大限制搜索的深度，如果在当前深度限制下搜不到答案就把深度增加，重新进行一次搜索。虽然在深度限制为d时，会重复搜索第1~d-1层节点，但是当搜索树节点分支数目较多是，随着层数的增加，每层节点数就会呈指数级增长，这些重复搜索与深层子树的规模相比就不值一提了。</li>
<li>当<strong>搜索树随着层次的深入增长很快，并且我们能够确保答案再一个较浅层次的节点时</strong>，就可以采用迭代加深的方法来解决问题。甚至有的题目描述包含“如果10步内搜不到就算无解”的字样。</li>
<li>除了迭代加深外，<strong>双向搜索</strong>也可以避免在深层子树上浪费时间。有的题目不但有“初态”，还有明确的“终态”，并且从两个状态开始搜索产生的搜索树都能覆盖整个状态空间。这种情况下就可以双向搜索——从初态和终态出发各搜索一半，产生两个深度减半的搜索树，在中间交会、组合成最终的答案。</li>
</ul>
</blockquote>
<h1 id="BFS-每一步扩展花费代价为1"><a href="#BFS-每一步扩展花费代价为1" class="headerlink" title="BFS(每一步扩展花费代价为1)"></a>BFS(每一步扩展花费代价为1)</h1><blockquote>
<ul>
<li>BFS逐层遍历搜索树，所有状态按照入队的先后顺序具有<strong>层次单调性</strong>。如果每一次扩展花费代价为1，那么当一个状态第一次被访问时，就得到了从起始状态到该状态的最小步数。</li>
<li>值得一提的是，BFS队列中的元素关于层次满足<strong>两段性</strong>和<strong>单调性</strong>，两段性就是在任意时刻，队列中至多有两个层次的节点；在访问完所有的i层节点后才会访问第i+1层节点。</li>
</ul>
</blockquote>
<h1 id="双端队列BFS（每一步扩展花费代价只有0和1两种情况）"><a href="#双端队列BFS（每一步扩展花费代价只有0和1两种情况）" class="headerlink" title="双端队列BFS（每一步扩展花费代价只有0和1两种情况）"></a>双端队列BFS（每一步扩展花费代价只有0和1两种情况）</h1><blockquote>
<ul>
<li>如果每一步扩展花费代价要么是0，要么是1，我们就可以用双端队列在手动控制BFS的两段性和单调性。每个节点虽然可能被更新（入队）多次，但是它第一次被扩展出来时，就能得到对应的最优解，之后再被取出可直接忽略。</li>
</ul>
</blockquote>
<h1 id="优先队列BFS（每一步扩展都有各自不同的代价）"><a href="#优先队列BFS（每一步扩展都有各自不同的代价）" class="headerlink" title="优先队列BFS（每一步扩展都有各自不同的代价）"></a>优先队列BFS（每一步扩展都有各自不同的代价）</h1><blockquote>
<ul>
<li>法1：仍然使用一般的队列，这时我们不能保证每个状态第一次入队就能得到最小代价，所有只能允许一个状态被多次更新、多次进出队列，不断搜索，直到队列为空，最后记录数组中保存了最小代价。复杂度一般会达到O(n^2)，如最短路的SPFA算法。</li>
<li>法2：改用优先队列进行BFS。每次从队列中取出当前代价最小的状态进行扩展（该状态一定是最优的，因为其他状态的代价都不小于它，所以之后就不可能再更新它了）。虽然这样每个状态也会被多次更新、多次进入队列，一个状态也可能以不同的代价在队列中同时出现，但是每个状态第一次出队就是最优解，后面再出队就可以直接忽略。所以每个状态只扩展一次，时间复杂度为O(nlgn)，如对优化的Dijkstra。</li>
<li>优先队列BFS的缺点就是不跑有<strong>负边</strong>的图。因为每次找出代价最小的状态时，因为负边的存在，不能保证此时它就是最优解，这时就只能用一般的队列搜索完整个解空间了。</li>
</ul>
</blockquote>
<h1 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h1><blockquote>
<ul>
<li>同之前的双向DFS，从初态和终态同时扩展，最小交会代价和就是答案。</li>
</ul>
</blockquote>
<h1 id="A-估价函数-优先队列-BFS"><a href="#A-估价函数-优先队列-BFS" class="headerlink" title="A*(估价函数+优先队列+BFS)"></a>A*(估价函数+优先队列+BFS)</h1><blockquote>
<ul>
<li>在优先队列BFS中，我们不断从堆中取出“当前最小代价”的状态进行扩展，如果<strong>给出一个目标状态</strong> ，要求从初态到目标状态的最小代价，上述“优先策略”明显不完整。一个状态的当前代价最小，但在未来搜索中，可能当前状态到目标状态代价很大。</li>
<li>我们设计一个“估价函数”，以任意状态为输入，计算出从该状态到目标状态所需要的估计值。在搜索中，仍然维护一个堆，每次从堆中取出“当前代价+未来估价”最小的状态进行扩展。</li>
<li>设估价值为f(x)，当前状态到目标状态的实际值为g(x)，必须保证f(x) &lt;= g(x)。具体证明P124。</li>
</ul>
</blockquote>
<h1 id="K短路"><a href="#K短路" class="headerlink" title="K短路"></a>K短路</h1><blockquote>
<ul>
<li>使用优先队列bfs时，第一次取出x点的状态就是从起点到x点的最优解，即最短路，同理，在第k次取出x时就是x的第k优解，即k短路。</li>
<li>上诉方法虽然可行，但是最坏情况下时间复杂度为<code>O(K*(N+N)*log(N+M))</code>，使用A*提高搜索效率。</li>
<li>在第K短路中从x到T的估计距离f(x)应该不大于第K短路中x到T的实际距离g(x)，所以把估价函数f(x)定义为x到t的最短路。</li>
<li>步骤：<ul>
<li>dijkstra预处理出各个节点到t的最短路长度f(x)。</li>
<li>bfs时优先队列维护二元组(x,dist+f(x))，dist表示从s到x当前走过第距离，起初对重只有(s,0+f(s)).</li>
<li>取出dist+f(x)最小的x，向外扩展。如果节点y被取出的次数未达到k，就直接把新的二元组(y,dist+w(x,y)+f(y))放入优先队列。</li>
<li>重复2~3步，直到终点取出k次，返回答案。</li>
</ul>
</li>
<li>使用A*前后虽然时间复杂度上限相同，但是由于估价函数的作用，图中很多节点访问次数远小于K。</li>
</ul>
</blockquote>
<h1 id="IDA-（迭代深搜-估价函数）"><a href="#IDA-（迭代深搜-估价函数）" class="headerlink" title="IDA*（迭代深搜+估价函数）"></a>IDA*（迭代深搜+估价函数）</h1><blockquote>
<ul>
<li>若当前深度+未来估计步数&gt;深度限制，立即返回。</li>
<li>同样需要遵守f(x) &lt;= g(x)的准则。</li>
<li>只要f(x)够优秀，这个算法贼快。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>进阶训练</category>
      </categories>
      <tags>
        <tag>进阶训练</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶训练-基本数据结构</title>
    <url>/%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>单调栈，单调队列，双端队列，邻接表，Hash，字符串，trie<br><a id="more"></a></p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a><strong>单调栈</strong></h1><ul>
<li>借助单调性处理问题的思想在于<strong>及时排除不可能的选项，保证策略集合的高度有效性和秩序性</strong>，从而为我们做出的决策提供更多的条件和可能方法。<a href="https://www.acwing.com/problem/content/133/" target="_blank" rel="noopener">例题：直方图的最大矩形面积</a></li>
</ul>
</blockquote>
<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a><strong>单调队列</strong></h1><blockquote>
<ul>
<li>同单调栈一样，也是<strong>在决策集合中及时排除一定不是最优解的选择</strong>，是优化动态规划的一个重要手段。<a href="https://www.acwing.com/problem/content/137/" target="_blank" rel="noopener">例题：最大子序列和</a></li>
</ul>
</blockquote>
<h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line">front/back------队头/队尾元素，O(<span class="number">1</span>)</span><br><span class="line">push_back(x)----从队尾入队，O(<span class="number">1</span>)</span><br><span class="line">push_front(x)---从队头入队，O(<span class="number">1</span>)</span><br><span class="line">pop_front()-----从队头出队，O(<span class="number">1</span>)</span><br><span class="line">pop_back()------从队尾出队，O(<span class="number">1</span>)</span><br><span class="line">clear()---------清空队列，O(n)</span><br></pre></td></tr></table></figure>
<h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><blockquote>
<ul>
<li>这里的邻接表实现类似于链式前向星<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head[N],Next[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=Hash(i);</span><br><span class="line">    <span class="keyword">if</span>(head[num]==<span class="number">0</span>) &#123;</span><br><span class="line">        head[num]=i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=head[num];j;j=Next[j])&#123;</span><br><span class="line">        <span class="keyword">if</span>(check(i,j)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Next[j]==<span class="number">0</span>) &#123;</span><br><span class="line">            Next[j]=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><strong>Hash</strong></h1><blockquote>
<ul>
<li>Hash表：以哈希值为索引的邻接表</li>
</ul>
<ul>
<li>字符串Hash：<ul>
<li>用一个固定值P，把字符串看作P进制数，并分配一个大于0的数值，代表每种字符。取一固定值M，求出该P进制数对M的余数，作为该字符的哈希值。</li>
<li>一般来说，取P=131或P=13331,此时Hash值冲突概率极低，令M=2e64，即直接用unsigned long long存储这个哈希值，在计算时不需要处理算术溢出问题，溢出相当于对M取模。这样可以避免抵消的mod运算。</li>
<li>如果我们已知字符串S的Hash值为H(S)，那么在S后添加一个字符c构成的新字符串S+c的Hash值就是H(S+c)=(H(S)*P+value[c]) mod M。其中乘P相当于P进制下的左移运算。</li>
<li>如果已知S的Hash值为H(S)，S+T的Hash值是H(S+T)，那么字符串T的Hash值H(T)=(H(S+T)-H(S)*P^length(T)) mod M。相当于通过P进制下在S后补0的方式，把S左移到与S+T左端对其，然后二者相减就得到了H(T)</li>
<li><a href="https://www.acwing.com/problem/content/140/" target="_blank" rel="noopener">例题：兔子与兔子</a></li>
</ul>
</li>
<li>二维矩阵哈希：<ul>
<li><a href="https://www.acwing.com/problem/content/158/" target="_blank" rel="noopener">例题：矩阵</a></li>
<li>求出整个矩阵中所有axb大小的矩阵的哈希值，然后O（1）询问</li>
<li>先对每一行单独求出前缀字符串哈希值.</li>
<li>假如num为当前(j-1)b的矩阵的哈希值，那么在这个矩阵里面再加入第j行后的矩阵的哈希值为<code>num=num*q^b+hash[j](l~r)</code>;</li>
<li>如果加入这一行后矩阵高度大于了a，就需要使其变为减掉当前第一行后的哈希值，<code>num-=hash[f[j-a]](l~r)*q[a*b]</code>,即减去将当前第一行的哈希值左移a*b位.</li>
<li>unordered_set（哈希set）可在平均O(1)的时间下完成查询。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(d) scanf(<span class="meta-string">"%d"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLL(d) scanf(<span class="meta-string">"%lld"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(d) printf(<span class="meta-string">"%d\n"</span>,d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL(d) printf(<span class="meta-string">"%lld\n"</span>,d)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">131</span>;</span><br><span class="line">ull f[N][N],q[N*N+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(ull h[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*q[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,a,b;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,N*N) q[i]=q[i<span class="number">-1</span>]*p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;m,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">        rep(j,<span class="number">1</span>,n) f[i][j]=f[i][j<span class="number">-1</span>]*p+s[j]-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;ull&gt; S;</span><br><span class="line">    rep(i,b,n)&#123;</span><br><span class="line">        ull num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=i-b+<span class="number">1</span>,r=i;</span><br><span class="line">        rep(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            num=num*q[b]+get(f[j],l,r);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;a) num-=get(f[j-a],l,r)*q[a*b];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=a) S.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;S(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        ull num=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,a)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">            rep(j,<span class="number">1</span>,b) num=num*p+s[j]-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S.count(num)) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote>
<ul>
<li>KMP：next[i]=max{j},j &lt; i且A[i-j+1~i]=A[1~j]。特别的，没有这样的j存在时，next[i]=0;</li>
</ul>
<ul>
<li>循环节/循环元<ul>
<li>根据定义，S[i-next[i]+1~i]与S[1~next[i]]是相同的，并且不存在更大的next值满足这个条件。通过这一点我们可以得知，i-next[i]为前i个字符的循环节，当i%(i-next[i])==0时，它就是一个完美匹配的循环节，即循环元。如：abcab—abc是整个字符串的循环节，ababab—ab是整个字符串的循环元。</li>
<li>进一步的，如果i-next[next[i]]能整除i，那么S[1~next[next[i]]]就是S[1~i]的次小循环元，依次类推，我们可以找到S[1~i]所有可能的循环元。</li>
</ul>
</li>
<li>最小表示法：一个字符串S[1~n]，如果不断把最后一个字符放到开头，最终会得到n个字符串，称这n个字符串循环同构，其中字典序最小的一个，称为字符串S的最小表示法。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[n+<span class="number">1</span>]=s[i];</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>,k;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=n &amp;&amp; j&lt;=n)&#123;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n&amp;&amp;s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="keyword">if</span>(k==n)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[i+k]&gt;s[j+k])&#123;</span><br><span class="line">        i=i+k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==j) j++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        j=j+k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==j) j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=min(i,j);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N至少为 字符种类数*字符串长度</span></span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">27</span>],ed[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str),p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ch=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[p][ch]==<span class="number">0</span>) trie[p][ch]=++tot;</span><br><span class="line">        p=trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str),p=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        p=trie[p][str[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        ans+=ed[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>例题：<a href="https://www.acwing.com/problem/content/144/" target="_blank" rel="noopener">前缀统计</a>,<a href="https://www.acwing.com/problem/content/145/" target="_blank" rel="noopener">最大异或对</a>,<a href="https://www.acwing.com/problem/content/146/" target="_blank" rel="noopener">最大异或值路径</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>进阶训练</category>
      </categories>
      <tags>
        <tag>进阶训练</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶训练-基本算法</title>
    <url>/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>位运算，递推与递归，前缀和与差分，二分，排序，倍增，贪心<br><a id="more"></a></p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul>
<li>快速幂，快速乘（1e18），状态压缩，成对变换，lowbit。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速乘</span></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) a=(ans+a)%p;</span><br><span class="line">        a=a*<span class="number">2</span>%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="递推与递归"><a href="#递推与递归" class="headerlink" title="递推与递归"></a>递推与递归</h2><blockquote>
<ul>
<li>递推：以已知的“问题边界”为起点向“原问题”正向推导</li>
<li>递归：以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”的路线，再通过路线反向回溯</li>
</ul>
</blockquote>
<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><blockquote>
<ul>
<li>前缀和：s[i]=∑(a[1]~a[i])</li>
<li>差分：b[i]=a[i]-a[i-1]。前缀和与差分为互逆运算，b的前缀和序列就是a，可将原序列上的区间操作转化为差分序列上的单点操作。</li>
</ul>
</blockquote>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><blockquote>
<ul>
<li><p>整数域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实数域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l+<span class="number">1e-5</span>&lt;r)&#123;</span><br><span class="line">    <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当精度不容易确定或表示时，可采用固定循环次数的方法，这种方法得到的精度通常更高</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>三分：有一类函数被称为单峰函数，它们拥有<strong>唯一的极大值点</strong>，在极大值左侧严格单点上升，右侧严格单调下降；或者唯一的极小值点，左侧严格单调下降，右侧严格单调上升。可用三分法求极值。<ul>
<li>在函数域[l,r]上任取两点lmid和rmid</li>
<li>若f(lmid) &lt; f(rmid)，则lmid与rmid要么同时处于极大值左侧，要么两侧，无论如何，极大值一定在lmid右侧，令l=lmid</li>
<li>同理，若f(lmid)&gt;f(rmid)，令r=mid。<br>如果函数不严格单调，即在韩式中存在一段值相等的部分，就无法判断定义域的左右边界如何缩小，三分法不再适用。</li>
</ul>
</li>
</ul>
<ul>
<li>二分答案：在答案与原问题具有单调性时，对答案进行二分，然后每次进行check()。</li>
</ul>
</blockquote>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<ul>
<li>离散化：sort+unique，将数值较大但分散的数映射为有限集合以便于统计。</li>
<li>中位数：我们要在一个一维序列上找一个点，使得其他点到它的距离之和最小时，中位数即为答案。证明：把序列排序，选择第x个点，则x左侧有P个点，右侧有Q个点。若P &lt; Q,则每把x向右移动一个单位距离，距离之和就会变小Q-p；同理，若P &gt; Q，则没把x向左移动会使距离和变小，当P=Q时为最优解。即：∑|s[i]-s[k]|,找到一个s[k]使式子最小，这个s[k]就是s的中位数。</li>
<li>第k大数：给定区间，求第k大。排序至少O(nlgn)。利用快排的思想，在每次选取基准值后，统计出大于基准值的数量cnt，如果k&lt;=cnt，则去左边找，否则在右边找第k-cnt大，时间复杂度为O(n)</li>
<li>逆序对：利用归并排序进行求解。区间[l,r]中，mid=(l+r)/2，i从l到mid,j从mid+1到r，当a[i]&gt;a[j]的时候，a[i~mid]一定都大于a[j]，因为单独看左右区间是已经排好序的，sum+=mid-i+1即可。</li>
</ul>
</blockquote>
<h2 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h2><blockquote>
<ul>
<li>当通常的线性递推无法满足时间和空间复杂度的要求时，就可以通过成倍增长的方式，只递推状态空间在2的整数次幂上的值作为代表。当需要其他位置上的值时，我们可以通过“任意整数可以表示为若干个2的次幂项的和”这一性质，使用之前求出的代表值拼成想要的值。这个算法要求我们<strong>递推的问题的状态空间关于2的次幂具有可划分性</strong>。<ul>
<li>试想这样一个问题：给出长为N的数列，每次给出一个T，求最大的整数k使得∑(a[1]~a[k])&lt;=T.</li>
<li>常规做法两种，第一种是直接O(n)扫过去，显然效率很慢；第二种是O(n)预处理出前缀和，然后二分k，每次询问O(lgn)。第二种在平均情况下表现很好，但是假如每次给的T都很小，那么k一定也很小，那么此时二分可能还不如直接扫过去来的快。</li>
<li>我们可以设计这样一种倍增算法：<ul>
<li>令p=1,k=0,sum=0,预处理处前缀和S；</li>
<li>比较A数组中k之后p个数的和与T的关系。如果sum+S[k+p]-S[k]&lt;=T,则令sum+=S[k+p]-S[k]，k+=p,p*=2，即加上这p个数的和，然后把跨度增长一倍。如果sum+S[k+p]-S[k]&gt;T，则令p/=2.</li>
<li>重复上诉步骤，知道p的值为0，此时k就是答案</li>
</ul>
</li>
</ul>
</li>
<li>ST算法：利用倍增求RMQ问题以及树上倍增求LCA。</li>
</ul>
</blockquote>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><blockquote>
<ul>
<li>贪心法要求问题的<strong>整体最优性可以有局部最优性推导出</strong>，且需要证明，常见的证明方法有：<ul>
<li>微扰（邻项交换）：证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果变差。经常用于以排序为贪心策略的证明。<a href="https://www.acwing.com/problem/content/116/" target="_blank" rel="noopener">例题：国王游戏</a></li>
<li>范围缩放：证明任何<strong>对局部最优策略作用范围的扩展</strong>都<strong>不会</strong>造成整体结果变差。<br><a href="https://www.acwing.com/problem/content/114/" target="_blank" rel="noopener">例题：雷达设备</a></li>
<li>决策包容性：证明在任意局面下，作出局部最优决策以后，在问题状态空间中的可达集合包含了作出其他决策后的可达集合。换言之，这个局部最优策略提供的可能性包含其他所有策略提供的可能。</li>
<li>反证法。</li>
<li>数学归纳法。</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>进阶训练</category>
      </categories>
      <tags>
        <tag>进阶训练</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu P2617——树状数组套主席树</title>
    <url>/luogu-P2617%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%A5%97%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<h1 id="传送门luogu-P2617"><a href="#传送门luogu-P2617" class="headerlink" title="传送门luogu P2617"></a>传送门<a href="https://www.luogu.org/problem/P2617" target="_blank" rel="noopener">luogu P2617</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改变后的a继续回答上面的问题。你需要编一个这样的程序，从输入文件中读入序列a，然后读入一系列的指令，包括询问指令和修改指令。<br>对于每一个询问指令，你必须输出正确的回答。</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行有两个正整数n(1≤n≤100000)，m(1≤m≤100000)。分别表示序列的长度和指令的个数。<br>第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。接下来的m行描述每条指令，每行的格式是下面两种格式中的一种。 Q i j k 或者 C i t<br>Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。<br>C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5 3<br>3 2 1 4 7<br>Q 1 4 3<br>C 2 6<br>Q 2 5 3</li>
</ul>
</blockquote>
<ul>
<li>Output<br>3<br>6</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>带修改的区间第k大，本蒟蒻不会，先放个板子吧…</li>
<li><a href="https://blog.csdn.net/g21wcr/article/details/86652152" target="_blank" rel="noopener">%%%%%%</a></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> lc,rc,siz;&#125;T[maxn*<span class="number">600</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qury</span>&#123;</span><span class="keyword">int</span> a,b,c;&#125;q[maxn];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,ansx,ansy,tot,len;</span><br><span class="line"><span class="keyword">int</span> root[maxn*<span class="number">600</span>],a[maxn],b[maxn&lt;&lt;<span class="number">1</span>],qx[maxn],qy[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	T[root=++tot]=T[pre],T[root].siz+=num;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(val&lt;=mid) update(T[root].lc,T[pre].lc,l,mid,val,num);</span><br><span class="line">	<span class="keyword">else</span>		 update(T[root].rc,T[pre].rc,mid+<span class="number">1</span>,r,val,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val=lower_bound(b+<span class="number">1</span>,b+len+<span class="number">1</span>,a[pos])-b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;=n;i+=lowbit(i))</span><br><span class="line">		update(root[i],root[i],<span class="number">1</span>,len,val,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> sum=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansx;++i) sum-=T[T[qx[i]].lc].siz;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansy;++i) sum+=T[T[qy[i]].lc].siz;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=sum)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansx;++i) qx[i]=T[qx[i]].lc;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansy;++i) qy[i]=T[qy[i]].lc;</span><br><span class="line">		<span class="keyword">return</span> query(l,mid,k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansx;++i) qx[i]=T[qx[i]].rc;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansy;++i) qy[i]=T[qy[i]].rc;</span><br><span class="line">		<span class="keyword">return</span> query(mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">disc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sort(b+<span class="number">1</span>,b+len+<span class="number">1</span>);</span><br><span class="line">	len=unique(b+<span class="number">1</span>,b+len+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=read(),m=read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=b[++len]=read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		 <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">	   	 q[i].a=read(),q[i].b=read();</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>) q[i].c=read();</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>) q[i].c=<span class="number">0</span>,b[++len]=q[i].b;</span><br><span class="line">	&#125;disc();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) add(i,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i].c)&#123;</span><br><span class="line">			ansx=<span class="number">0</span>,ansy=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=q[i].b;j;j-=lowbit(j))   qy[++ansy]=root[j];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=q[i].a<span class="number">-1</span>;j;j-=lowbit(j)) qx[++ansx]=root[j];</span><br><span class="line">			print(b[query(<span class="number">1</span>,len,q[i].c)]),<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			add(q[i].a,<span class="number">-1</span>),a[q[i].a]=q[i].b;</span><br><span class="line">			add(q[i].a,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>Keen On Everything But Triangle——主席树</title>
    <url>/Keen-On-Everything-But-Triangle%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<h1 id="传送门HDU6601"><a href="#传送门HDU6601" class="headerlink" title="传送门HDU6601"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6601" target="_blank" rel="noopener">HDU6601</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>N sticks are arranged in a row, and their lengths are a1,a2,…,aN.<br>There are Q querys. For i-th of them, you can only use sticks between li-th to ri-th. Please output the maximum circumference of all the triangles that you can make with these sticks, or print −1 denoting no triangles you can make.</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are multiple test cases.<br>Each case starts with a line containing two positive integers N,Q(N,Q≤105).<br>The second line contains N integers, the i-th integer ai(1≤ai≤109) of them showing the length of the i-th stick.<br>Then follow Q lines. i-th of them contains two integers li,ri(1≤li≤ri≤N), meaning that you can only use sticks between li-th to ri-th.<br>It is guaranteed that the sum of Ns and the sum of Qs in all test cases are both no larger than 4×105.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, output Q lines, each containing an integer denoting the maximum circumference.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5 3<br>2 5 6 5 2<br>1 3<br>2 4<br>2 5</li>
</ul>
</blockquote>
<ul>
<li>Output<br>13<br>16<br>16</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给长度为n的数组，m组询问，每次询问给出一个区间，用区间中的三个数组成三角形，求最大周长。</li>
<li>在每个区间中，从第1,2,3大开始组合，当无法组成三角形时，放弃第1条边找第2,3,4大的边，直到能组成三角形。</li>
<li>证明：若第1,2,3大的三边a,b,c无法组成三角形，说明b+c&lt;=a，那么后面任意两个数的和都不会大于a，所以只能放弃a。根据斐波那契数列和1e9的数据，在一个区间中，就算一直找不到符合条件的三条边，我们要寻找的次数不会超过50次。</li>
<li>主席树找区间第k大。<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(d) scanf(<span class="meta-string">"%d"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLL(d) scanf(<span class="meta-string">"%lld"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(d) printf(<span class="meta-string">"%d\n"</span>,d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL(d) printf(<span class="meta-string">"%lld\n"</span>,d)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> L[N*<span class="number">20</span>],R[N*<span class="number">20</span>],num[N*<span class="number">20</span>],root[N];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        L[now]=build(l,mid);</span><br><span class="line">        R[now]=build(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=++tot;</span><br><span class="line">    L[now]=L[pre],R[now]=R[pre],num[now]=num[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) L[now]=update(L[pre],l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> R[now]=update(R[pre],mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> x=num[L[v]]-num[L[u]];</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=k) <span class="keyword">return</span> query(L[u],L[v],l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(R[u],R[v],mid+<span class="number">1</span>,r,k-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x+y&lt;=z||x+z&lt;=y||y+z&lt;=x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=r-l+<span class="number">1</span>;ll e[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=len;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">2</span>) e[i]=b[query(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,m,k--)];</span><br><span class="line">    <span class="keyword">while</span>(len-k&lt;<span class="number">50</span> &amp;&amp; k&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check(e[<span class="number">0</span>],e[<span class="number">1</span>],e[<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]+e[<span class="number">1</span>]+e[<span class="number">2</span>];</span><br><span class="line">        e[<span class="number">0</span>]=e[<span class="number">1</span>];</span><br><span class="line">        e[<span class="number">1</span>]=e[<span class="number">2</span>];</span><br><span class="line">        e[<span class="number">2</span>]=b[query(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,m,k--)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q,tem;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q))&#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            SLL(a[i]);</span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">        m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">        root[<span class="number">0</span>]=build(<span class="number">1</span>,m);</span><br><span class="line">        rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            tem=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,a[i])-b;</span><br><span class="line">            root[i]=update(root[i<span class="number">-1</span>],<span class="number">1</span>,m,tem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            S(l),S(r);</span><br><span class="line">            PLL(solve(l,r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>Kth number———主席树模板</title>
    <url>/Kth-number%E2%80%94%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="传送门HDU2665"><a href="#传送门HDU2665" class="headerlink" title="传送门HDU2665"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2665" target="_blank" rel="noopener">HDU2665</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Give you a sequence and ask you the kth big number of a inteval.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line is the number of the test cases.<br>For each test case, the first line contain two integer n and m (n, m &lt;= 100000), indicates the number of integers in the sequence and the number of the quaere.<br>The second line contains n integers, describe the sequence.<br>Each of following m lines contains three integers s, t, k.<br>[s, t] indicates the interval and k indicates the kth big number in interval [s, t]</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, output m lines. Each line contains the kth big number.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1<br>10 1<br>1 4 2 3 5 6 7 8 9 0<br>1 3 2 </li>
</ul>
</blockquote>
<ul>
<li>Output<br>2</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：n个数q次询问，每次给一个区间[l,r]和一个数k，求区间中第k大的数。（其实是第k小来着，不知道是出题人的锅还是阅读理解有问题…）</li>
<li>权值线段树：<strong>节点num[i]</strong>维护i出现次数的线段树，主席树就是可持续化权值线段树，用于求区间第k小的数。</li>
<li>在建树时，每插入一个数就新建一颗线段树，用i时刻表示a[i]插入线段树的时刻，节点维护数组中每个元素在每个时刻出现的次数，用root[i]则表示i时刻所建的线段树的顶点。通过线段树的性质不难发现，插入一个数时只会经过log(n)个点，我们只需要新建这log(n)个点即可，其他的可以直接使用上时刻状态的节点。</li>
<li>要查询区间a[2]~a[5]时，我们首先把第1颗树和第5颗树拿出来，把树种对应位置的节点相减，就可以得到a[2]~a[5]内节点所包含范围内的数的个数（前缀和思想）。如两个代表区间[1,4]的节点相减等于2，就说明在a[2]~a[5]内有2个数在1到4之间。</li>
<li>对于一个区间[l,r]，我们每次算出在[l,mid]范围内的数x，如果x&gt;=k，说明第k大的数在左边，如果x &lt; k，说明第k大在右边，就在右边找第k-x大的数（因为左边已经有x个数了）</li>
<li>为了节省空间，将数组元素离散化，每次插入这个数在数组排序并去重后的位次。</li>
<li>若排序去重后数组长度为m的话，那么线段树的空间需要mlg(m)，每次查询的时间复杂度为lg(m)，建树的时间复杂度为nlg(m);</li>
<li><a href="https://blog.csdn.net/bestFy/article/details/78650360" target="_blank" rel="noopener">很好的一篇博客</a></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(d) scanf(<span class="meta-string">"%d"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLL(d) scanf(<span class="meta-string">"%lld"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(d) printf(<span class="meta-string">"%d\n"</span>,d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL(d) printf(<span class="meta-string">"%lld\n"</span>,d)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],L[N*<span class="number">20</span>],R[N*<span class="number">20</span>],num[N*<span class="number">20</span>],root[N];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        L[now]=build(l,mid);</span><br><span class="line">        R[now]=build(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=++tot;</span><br><span class="line">    L[now]=L[pre],R[now]=R[pre],num[now]=num[pre]+<span class="number">1</span>;<span class="comment">//先将左右节点都连在上一棵树上</span></span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//新建左节点或新建右节点</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) L[now]=update(L[pre],l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> R[now]=update(R[pre],mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//左边数的个数x&gt;=k，说明第k位在左边，否则在右边找第k-x位</span></span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> x=num[L[v]]-num[L[u]];</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=k) <span class="keyword">return</span> query(L[u],L[v],l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(R[u],R[v],mid+<span class="number">1</span>,r,k-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ca;S(ca);</span><br><span class="line">    <span class="keyword">int</span> n,q,s,t,k,tem;</span><br><span class="line">    <span class="keyword">while</span>(ca--)&#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        S(n),S(q);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            S(a[i]);</span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">int</span> m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;<span class="comment">//去重</span></span><br><span class="line">        root[<span class="number">0</span>]=build(<span class="number">1</span>,m);<span class="comment">//建空树</span></span><br><span class="line">        rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            tem=lower_bound(b+<span class="number">1</span>,b+m+<span class="number">1</span>,a[i])-b;</span><br><span class="line">            root[i]=update(root[i<span class="number">-1</span>],<span class="number">1</span>,m,tem);</span><br><span class="line">            <span class="comment">//离散化，用位次表示数字并插入主席树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            S(s),S(t),S(k);</span><br><span class="line">            tem=query(root[s<span class="number">-1</span>],root[t],<span class="number">1</span>,m,k);</span><br><span class="line">            P(b[tem]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>Picture(扫描线周长并)</title>
    <url>/Picture-%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%91%A8%E9%95%BF%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="传送门-HDU1828"><a href="#传送门-HDU1828" class="headerlink" title="传送门 HDU1828"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1828" target="_blank" rel="noopener">HDU1828</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>A number of rectangular posters, photographs and other pictures of the same shape are pasted on a wall. Their sides are all vertical or horizontal. Each rectangle can be partially or totally covered by the others. The length of the boundary of the union of all rectangles is called the perimeter.<br>Write a program to calculate the perimeter. An example with 7 rectangles is shown in Figure 1.<br>The corresponding boundary is the whole set of line segments drawn in Figure 2.<br>The vertices of all rectangles have integer coordinates.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>Your program is to read from standard input. The first line contains the number of rectangles pasted on the wall. In each of the subsequent lines, one can find the integer coordinates of the lower left vertex and the upper right vertex of each rectangle. The values of those coordinates are given as ordered pairs consisting of an x-coordinate followed by a y-coordinate.<br>0 &lt;= number of rectangles &lt; 5000<br>All coordinates are in the range [-10000,10000] and any existing rectangle has a positive area.<br>Please process to the end of file.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Your program is to write to standard output. The output must contain a single line with a non-negative integer which corresponds to the perimeter for the input rectangles.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>7<br>-15 0 5 10<br>-5 8 20 25<br>15 -4 24 14<br>0 -6 16 4<br>2 15 10 22<br>30 10 36 20<br>34 0 40 16</li>
</ul>
</blockquote>
<ul>
<li>Output<br>Case 1: 2500<br>Case 2: 16</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson d&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson d&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SL</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,y,flag;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> SL&amp; a)&#123;<span class="keyword">return</span> y&lt;a.y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> len[maxn],cnt[maxn],fl[maxn],fr[maxn],num[maxn];</span><br><span class="line"><span class="comment">//len横线长度,cnt标记,fl区间左端点是否有竖线，fr区间右端点是否有竖线，num区间竖线对数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;SL&gt; sl;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sl.clear();dx.clear();</span><br><span class="line">    INIT(len,<span class="number">0</span>);INIT(cnt,<span class="number">0</span>);</span><br><span class="line">    INIT(fl,<span class="number">0</span>);INIT(fr,<span class="number">0</span>);</span><br><span class="line">    INIT(num,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[d])&#123;</span><br><span class="line">        len[d]=dx[r+<span class="number">1</span>]-dx[l];</span><br><span class="line">        num[d]=<span class="number">1</span>;</span><br><span class="line">        fl[d]=fr[d]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) len[d]=fl[d]=fr[d]=num[d]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        len[d]=len[d&lt;&lt;<span class="number">1</span>]+len[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        fl[d]=fl[d&lt;&lt;<span class="number">1</span>];</span><br><span class="line">        fr[d]=fr[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        num[d]=num[d&lt;&lt;<span class="number">1</span>]+num[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]-(fr[d&lt;&lt;<span class="number">1</span>]&amp;fl[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//当左区间右线和右区间左线重合时-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) cnt[d]+=val;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid) update(lson,ql,qr,val);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;qr) update(rson,ql,qr,val);</span><br><span class="line">    &#125;</span><br><span class="line">    push_up(d,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            sl.PB((SL)&#123;x1,x2,y1,<span class="number">1</span>&#125;);</span><br><span class="line">            sl.PB((SL)&#123;x1,x2,y2,<span class="number">-1</span>&#125;);</span><br><span class="line">            dx.PB(x1);dx.PB(x2);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(sl.begin(),sl.end());</span><br><span class="line">        sort(dx.begin(),dx.end());</span><br><span class="line">        dx.erase(unique(dx.begin(),dx.end()),dx.end());</span><br><span class="line">        LL ans=<span class="number">0</span>;<span class="keyword">int</span> tem=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sl.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ql=lower_bound(dx.begin(),dx.end(),sl[i].l)-dx.begin();</span><br><span class="line">            <span class="keyword">int</span> qr=lower_bound(dx.begin(),dx.end(),sl[i].r)-dx.begin()<span class="number">-1</span>;</span><br><span class="line">            update(<span class="number">1</span>,<span class="number">0</span>,dx.size()<span class="number">-1</span>,ql,qr,sl[i].flag);</span><br><span class="line">            ans+=<span class="built_in">abs</span>(len[<span class="number">1</span>]-tem);</span><br><span class="line">            tem=len[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; sl.size()<span class="number">-1</span>) ans+=num[<span class="number">1</span>]*<span class="number">2</span>*(sl[i+<span class="number">1</span>].y-sl[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Farming(扫描线体积并)</title>
    <url>/Farming-%E6%89%AB%E6%8F%8F%E7%BA%BF%E4%BD%93%E7%A7%AF%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="传送门-HDU3255"><a href="#传送门-HDU3255" class="headerlink" title="传送门 HDU3255"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3255" target="_blank" rel="noopener">HDU3255</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>You have a big farm, and you want to grow vegetables in it. You’re too lazy to seed the seeds yourself, so you’ve hired n people to do the job for you.<br>Each person works in a rectangular piece of land, seeding one seed in one unit square. The working areas of different people may overlap, so one unit square can be seeded several times. However, due to limited space, different seeds in one square fight each other — finally, the most powerful seed wins. If there are several “most powerful” seeds, one of them win (it does not matter which one wins).<br>There are m kinds of seeds. Different seeds grow up into different vegetables and sells for different prices.<br>As a rule, more powerful seeds always grow up into more expensive vegetables.<br>Your task is to calculate how much money will you get, by selling all the vegetables in the whole farm.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line contains a single integer T (T &lt;= 10), the number of test cases.<br>Each case begins with two integers n, m (1 &lt;= n &lt;= 30000, 1 &lt;= m &lt;= 3).<br>The next line contains m distinct positive integers pi (1 &lt;= pi &lt;= 100), the prices of each kind of vegetable.<br>The vegetables (and their corresponding seeds) are numbered 1 to m in the order they appear in the input.<br>Each of the following n lines contains five integers x1, y1, x2, y2, s, indicating a working seeded a rectangular area with lower-left corner (x1,y1), upper-right corner (x2,y2), with the s-th kind of seed.<br>All of x1, y1, x2, y2 will be no larger than 106 in their absolute values.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, print the case number and your final income.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2<br>1 1<br>25<br>0 0 10 10 1<br>2 2<br>5 2<br>0 0 2 1 1<br>1 0 3 2 2</li>
<li>Output<br>Case 1: 2500<br>Case 2: 16</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>枚举高度算面积并求和</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson d&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson d&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,y;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Seg&amp; a)&#123;<span class="keyword">return</span> y&lt;a.y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Seg&gt; seg;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx;</span><br><span class="line"><span class="keyword">int</span> len[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">5</span>],ph[maxn];</span><br><span class="line"><span class="keyword">int</span> px1[maxn],py1[maxn],px2[maxn],py2[maxn],n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[d]) len[d]=dx[r+<span class="number">1</span>]-dx[l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) len[d]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> len[d]=len[d&lt;&lt;<span class="number">1</span>]+len[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">        cnt[d]+=val;</span><br><span class="line">        push_up(d,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid) update(lson,ql,qr,val);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;qr) update(rson,ql,qr,val);</span><br><span class="line">        push_up(d,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        seg.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ph[j]&gt;h[i<span class="number">-1</span>])&#123;</span><br><span class="line">                seg.PB((Seg)&#123;px1[j],px2[j],py1[j],<span class="number">1</span>&#125;);</span><br><span class="line">                seg.PB((Seg)&#123;px1[j],px2[j],py2[j],<span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(seg.begin(),seg.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;seg.size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ql=lower_bound(dx.begin(),dx.end(),seg[j].l)-dx.begin();</span><br><span class="line">            <span class="keyword">int</span> qr=lower_bound(dx.begin(),dx.end(),seg[j].r)-dx.begin()<span class="number">-1</span>;</span><br><span class="line">            update(<span class="number">1</span>,<span class="number">0</span>,dx.size()<span class="number">-1</span>,ql,qr,seg[j].flag);</span><br><span class="line">            <span class="keyword">if</span>(j&lt;seg.size()<span class="number">-1</span>) ans+=<span class="number">1l</span>l*len[<span class="number">1</span>]*(seg[j+<span class="number">1</span>].y-seg[j].y)*(h[i]-h[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _=<span class="number">1</span>;_&lt;=t;_++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        seg.clear();dx.clear();</span><br><span class="line">        INIT(cnt,<span class="number">0</span>);INIT(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;px1[i],&amp;py1[i],&amp;px2[i],&amp;py2[i],&amp;ph[i]);</span><br><span class="line">            ph[i]=h[ph[i]];</span><br><span class="line">            dx.PB(px1[i]);</span><br><span class="line">            dx.PB(px2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(dx.begin(),dx.end());</span><br><span class="line">        sort(h+<span class="number">1</span>,h+m+<span class="number">1</span>);</span><br><span class="line">        dx.erase(unique(dx.begin(),dx.end()),dx.end());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,_,solve());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Atlantis(扫描线面积并)</title>
    <url>/Atlantis-%E6%89%AB%E6%8F%8F%E7%BA%BF%E9%9D%A2%E7%A7%AF%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="传送门-HDU1542"><a href="#传送门-HDU1542" class="headerlink" title="传送门 HDU1542"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1542" target="_blank" rel="noopener">HDU1542</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>There are several ancient Greek texts that contain descriptions of the fabled island Atlantis. Some of these texts even include maps of parts of the island. But unfortunately, these maps describe different regions of Atlantis. Your friend Bill has to know the total area for which maps exist. You (unwisely) volunteered to write a program that calculates this quantity.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input file consists of several test cases. Each test case starts with a line containing a single integer n (1&lt;=n&lt;=100) of available maps. The n following lines describe one map each. Each of these lines contains four numbers <code>x1;y1;x2;y2 (0&lt;=x1&lt;x2&lt;=100000;0&lt;=y1&lt;y2&lt;=100000)</code>, not necessarily integers. The values (x1; y1) and (x2;y2) are the coordinates of the top-left resp. bottom-right corner of the mapped area.<br>The input file is terminated by a line containing a single 0. Don’t process it.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, your program should output one section. The first line of each section must be “Test case #k”, where k is the number of the test case (starting with 1). The second one must be “Total explored area: a”, where a is the total explored area (i.e. the area of the union of all rectangles in this test case), printed exact to two digits to the right of the decimal point.<br>Output a blank line after each test case.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>输入<br>2<br>10 10 20 20<br>15 15 25 25.5<br>0</li>
<li>输出<br>Test case #1<br>Total explored area: 180.00 </li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson d&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson d&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x1,x2,y;</span><br><span class="line">    <span class="keyword">int</span> flag;  <span class="comment">//1下边，-1上边</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Seg&amp; a)&#123;<span class="keyword">return</span> y&lt;a.y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> len[maxn&lt;&lt;<span class="number">3</span>];               <span class="comment">//长度</span></span><br><span class="line"><span class="keyword">int</span> cnt[maxn&lt;&lt;<span class="number">3</span>];                  <span class="comment">//标记，大于0时可取</span></span><br><span class="line">V&lt;Seg&gt; seg;                        <span class="comment">//边表</span></span><br><span class="line">V&lt;<span class="keyword">double</span>&gt; dx;                      <span class="comment">//x离散化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[d]) len[d]=dx[r+<span class="number">1</span>]-dx[l]; <span class="comment">//不为0就说明整段可取</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) len[d]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> len[d]=len[d&lt;&lt;<span class="number">1</span>]+len[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) cnt[d]+=val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid) update(lson,ql,qr,val);</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid) update(rson,ql,qr,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(d,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        t++;</span><br><span class="line">        seg.clear();dx.clear();</span><br><span class="line">        INIT(len,<span class="number">0</span>);INIT(cnt,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">double</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            seg.PB((Seg)&#123;x1,x2,y1,<span class="number">1</span>&#125;);</span><br><span class="line">            seg.PB((Seg)&#123;x1,x2,y2,<span class="number">-1</span>&#125;);</span><br><span class="line">            dx.PB(x1);</span><br><span class="line">            dx.PB(x2);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(seg.begin(),seg.end());</span><br><span class="line">        sort(dx.begin(),dx.end());</span><br><span class="line">        dx.erase(unique(dx.begin(),dx.end()),dx.end());<span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;seg.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ql=lower_bound(dx.begin(),dx.end(),seg[i].x1)-dx.begin();</span><br><span class="line">            <span class="keyword">int</span> qr=lower_bound(dx.begin(),dx.end(),seg[i].x2)-dx.begin()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//左闭右开</span></span><br><span class="line">            update(<span class="number">1</span>,<span class="number">0</span>,dx.size()<span class="number">-1</span>,ql,qr,seg[i].flag);</span><br><span class="line">            ans+=len[<span class="number">1</span>]*(seg[i+<span class="number">1</span>].y-seg[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2lf\n\n"</span>,t,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Nightmare2</title>
    <url>/Nightmare2/</url>
    <content><![CDATA[<h1 id="传送门HDU3085"><a href="#传送门HDU3085" class="headerlink" title="传送门HDU3085"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3085" target="_blank" rel="noopener">HDU3085</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.<br>You may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.<br>Note: the new ghosts also can devide as the original ghost.<br>For example, given “ACGT”,”ATGC”,”CGTT” and “CAGT”, you can make a sequence in the following way. It is the shortest but may be not the only one.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input starts with an integer T, means the number of test cases.<br>Each test case starts with a line contains two integers n and m, means the size of the maze. (1&lt;n, m&lt;800)<br>The next n lines describe the maze. Each line contains m characters. The characters may be:<br>‘.’ denotes an empty place, all can walk on.<br>‘X’ denotes a wall, only people can’t walk on.<br>‘M’ denotes little erriyue<br>‘G’ denotes the girl friend.<br>‘Z’ denotes the ghosts.<br>It is guaranteed that will contain exactly one letter M, one letter G and two letters Z. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>3<br>5 6<br>XXXXXX<br>XZ..ZX<br>XXXXXX<br>M.G…<br>……<br>5 6<br>XXXXXX<br>XZZ..X<br>XXXXXX<br>M…..<br>..G…<br>10 10<br>……….<br>..X…….<br>..M.X…X.<br>X………<br>.X..X.X.X.<br>………X<br>..XX….X.<br>X….G…X<br>…ZX.X…<br>…Z..X..X</p>
</li>
<li><p>Output<br>1<br>1<br>-1</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：G和M在迷宫里寻找对方，M每秒可以走3步，G每次走一步，且只能上下左右走。迷宫里有鬼，鬼每次分裂到上下左右两格位置，直到占满所有格子，鬼可以穿墙，求G和M在不遇到鬼的情况下的最短相遇时间。</li>
<li>双向bfs，由于M每次走3步，所以M每次要处理3次。</li>
<li>由于鬼可以穿墙，所以判断人和鬼是否相遇时根据曼哈顿距离来算就行。当时间time*2&lt;曼哈顿距离时会和鬼相遇。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;M,G,Z[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> tab,node a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(ans*<span class="number">2</span> &gt;= <span class="built_in">abs</span>(Z[i].x-a.x)+<span class="built_in">abs</span>(Z[i].y-a.y) )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&lt;<span class="number">0</span>||a.x&gt;=n||a.y&lt;<span class="number">0</span>||a.y&gt;=m)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[a.x][a.y]==<span class="string">'X'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> tab,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    node tem,q;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; qt;</span><br><span class="line">    qt=que[tab];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;step;i++)&#123;</span><br><span class="line">         <span class="keyword">while</span>(!qt.empty())&#123;</span><br><span class="line">            q=qt.front();qt.pop();que[tab].pop();</span><br><span class="line">            <span class="keyword">if</span>(!judge(tab,q))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                tem.x=q.x+dir[i][<span class="number">0</span>],tem.y=q.y+dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(!judge(tab,tem)||vis[tab][tem.x][tem.y])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(vis[tab^<span class="number">1</span>][tem.x][tem.y]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                vis[tab][tem.x][tem.y]=<span class="number">1</span>;</span><br><span class="line">                que[tab].push(tem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qt=que[tab];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    INIT(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!que[<span class="number">0</span>].empty())que[<span class="number">0</span>].pop();</span><br><span class="line">    <span class="keyword">while</span>(!que[<span class="number">1</span>].empty())que[<span class="number">1</span>].pop();</span><br><span class="line">    que[<span class="number">0</span>].push(M);que[<span class="number">1</span>].push(G);</span><br><span class="line">    vis[<span class="number">0</span>][M.x][M.y]=vis[<span class="number">1</span>][G.x][G.y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que[<span class="number">0</span>].empty()||!que[<span class="number">1</span>].empty())&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>(solve(<span class="number">0</span>,<span class="number">3</span>)||solve(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> z=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//scanf("%s",mp[i]);</span></span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                mp[i][j]=getchar();</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'M'</span>) M=(node)&#123;i,j&#125;;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'G'</span>) G=(node)&#123;i,j&#125;;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'Z'</span>) Z[z++]=(node)&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bfs());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Travelling(三进制状压dp)</title>
    <url>/Travelling/</url>
    <content><![CDATA[<h1 id="传送门HDU3001"><a href="#传送门HDU3001" class="headerlink" title="传送门HDU3001"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3001" target="_blank" rel="noopener">HDU3001</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>After coding so many days,Mr Acmer wants to have a good rest.So travelling is the best choice!He has decided to visit n cities(he insists on seeing all the cities!And he does not mind which city being his start station because superman can bring him to any city at first but only once.), and of course there are m roads here,following a fee as usual.But Mr Acmer gets bored so easily that he doesn’t want to visit a city more than twice!And he is so mean that he wants to minimize the total fee!He is lazy you see.So he turns to you for help.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are several test cases,the first line is two intergers n(1&lt;=n&lt;=10) and m,which means he needs to visit n cities and there are m roads he can choose,then m lines follow,each line will include three intergers a,b and c(1&lt;=a,b&lt;=n),means there is a road between a and b and the cost is of course c.Input to the End Of File.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Output the minimum fee that he should pay,or -1 if he can’t find such a route.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>2 1<br>1 2 100<br>3 2<br>1 2 40<br>2 3 50<br>3 3<br>1 2 3<br>1 3 4<br>2 3 10</p>
</li>
<li><p>Output<br>100<br>90<br>7 </p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：从任意起点开始走完所有的点，每个点最多走两次，求最短路径</li>
<li>与经典TSP问题不同的是，这里每个点可以走两次，所以采用三进制状压，012分别表示没走过，走过一次，走过两次。</li>
<li>与二进制状压不同的是，我们不能通过位运算很方便地知道每一位的数值或者状态转移，所以我们要预处理出来每种状态的三进制下每一位的数值。</li>
<li>dp[i][j]表示用状态i下以j为最后一个到达的点的最短距离，<code>dp[sta+three[j]][j]=min(dp[sta+three[j]][j],dp[sta][i]+mp[i][j])</code>;</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,vis[N];</span><br><span class="line"><span class="keyword">int</span> three[<span class="number">11</span>],dig[<span class="number">60000</span>][<span class="number">20</span>];<span class="comment">//三进制数，每一个数的每一位（0,1,2）</span></span><br><span class="line"><span class="keyword">int</span> mp[N][N],ans,dp[<span class="number">60000</span>][<span class="number">20</span>];<span class="comment">//dp[i][j]第i种状态以j为结尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    three[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        three[i]=three[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> tem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;three[<span class="number">10</span>];i++)&#123;</span><br><span class="line">        tem=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            dig[i][j]=tem%<span class="number">3</span>;</span><br><span class="line">            tem/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    init();</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        INIT(mp,inf);INIT(dp,inf);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            mp[a<span class="number">-1</span>][b<span class="number">-1</span>]=mp[b<span class="number">-1</span>][a<span class="number">-1</span>]=min(mp[a<span class="number">-1</span>][b<span class="number">-1</span>],c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一个走的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            dp[three[i]][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=inf,flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta=<span class="number">0</span>;sta&lt;three[n];sta++)&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dig[sta][i]==<span class="number">0</span>)flag=<span class="number">0</span>;<span class="comment">//如果有0说明还有点没走过</span></span><br><span class="line">                <span class="keyword">if</span>(dp[sta][i]==inf)<span class="keyword">continue</span>;<span class="comment">//如果当前状态i点没走过，则不可用</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp[i][j]==inf||dig[sta][j]==<span class="number">2</span>)<span class="keyword">continue</span>;<span class="comment">//通过当前状态推导下一个状态，如果当前状态下j已经走过两次了，那么下一个状态必然不能再到j</span></span><br><span class="line">                    dp[sta+three[j]][j]=min(dp[sta+three[j]][j],dp[sta][i]+mp[i][j]);<span class="comment">//sta+three[j]相当于第j位+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//当存在所有点都走过的状态时就更新答案</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                ans=min(ans,dp[sta][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==inf) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Gap</title>
    <url>/Gap/</url>
    <content><![CDATA[<h1 id="传送门HDU1067"><a href="#传送门HDU1067" class="headerlink" title="传送门HDU1067"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1067" target="_blank" rel="noopener">HDU1067</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Let’s play a card game called Gap.<br>You have 28 cards labeled with two-digit numbers. The first digit (from 1 to 4) represents the suit of the card, and the second digit (from 1 to 7) represents the value of the card.<br>First, you shu2e the cards and lay them face up on the table in four rows of seven cards, leaving a space of one card at the extreme left of each row. The following shows an example of initial layout.<br>Next, you remove all cards of value 1, and put them in the open space at the left end of the rows: “11” to the top row, “21” to the next, and so on.<br>Now you have 28 cards and four spaces, called gaps, in four rows and eight columns. You start moving cards from this layout.<br>At each move, you choose one of the four gaps and fill it with the successor of the left neighbor of the gap. The successor of a card is the next card in the same suit, when it exists. For instance the successor of “42” is “43”, and “27” has no successor.<br>In the above layout, you can move “43” to the gap at the right of “42”, or “36” to the gap at the right of “35”. If you move “43”, a new gap is generated to the right of “16”. You cannot move any card to the right of a card of value 7, nor to the right of a gap.<br>The goal of the game is, by choosing clever moves, to make four ascending sequences of the same suit, as follows.<br>Your task is to find the minimum number of moves to reach the goal layout.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input starts with a line containing the number of initial layouts that follow.<br>Each layout consists of five lines - a blank line and four lines which represent initial layouts of four rows. Each row has seven two-digit numbers which correspond to the cards.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each initial layout, produce a line with the minimum number of moves to reach the goal layout. Note that this number should not include the initial four moves of the cards of value 1. If there is no move sequence from the initial layout to the goal layout, produce “-1”. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>4</li>
</ul>
<p>12 13 14 15 16 17 21<br>22 23 24 25 26 27 31<br>32 33 34 35 36 37 41<br>42 43 44 45 46 47 11</p>
<p>26 31 13 44 21 24 42<br>17 45 23 25 41 36 11<br>46 34 14 12 37 32 47<br>16 43 27 35 22 33 15</p>
<p>17 12 16 13 15 14 11<br>27 22 26 23 25 24 21<br>37 32 36 33 35 34 31<br>47 42 46 43 45 44 41</p>
<p>27 14 22 35 32 46 33<br>13 17 36 24 44 21 15<br>43 16 45 47 23 11 26<br>25 37 41 34 42 12 31</p>
<ul>
<li>Output<br>0<br>33<br>60<br>-1</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给出表如第一个图，给出每个数，共有28个数，首先要将11,21,31,41放到前面去如第二个图，然后每次可以挑选一个空位把某个数放在此位置，但是<br>要保证此数恰好是空位左边的数的后一个数，比如空位左边的数是42，则只能把43移到空位去。如果是47的话是没有后一个数的。</li>
<li>map保存状态bfs</li>
<li>利用Ascall码将2位数字变成一位字符，这样就可以将整个表的状态放在string里面了<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="built_in">string</span> aim=<span class="string">""</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">        mp[i][<span class="number">1</span>]=i*<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">8</span>) c=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> c=i*<span class="number">10</span>+j;</span><br><span class="line">                aim+=c;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vis.clear();</span><br><span class="line">    node tem;</span><br><span class="line">    <span class="built_in">string</span> be;<span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)</span><br><span class="line">            be+=mp[i][j];</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;be,<span class="number">0</span>&#125;);</span><br><span class="line">    vis[be]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node now=que.front();que.pop();</span><br><span class="line">        <span class="keyword">if</span>(now.str==aim) <span class="keyword">return</span> now.step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now.str[i]==<span class="number">1</span>&amp;&amp;now.str[i<span class="number">-1</span>]!=<span class="number">1</span>&amp;&amp;now.str[i<span class="number">-1</span>]%<span class="number">10</span>!=<span class="number">7</span>)&#123;</span><br><span class="line">                tem=now;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">                    <span class="keyword">if</span>(tem.str[j]==tem.str[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">                        tem.str[j]=<span class="number">1</span>;</span><br><span class="line">                        tem.str[i]=tem.str[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                        tem.step++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(vis.count(tem.str))<span class="keyword">continue</span>;</span><br><span class="line">                vis[tem.str]=<span class="number">1</span>;</span><br><span class="line">                que.push(tem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mp[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">                    mp[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bfs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Magic Cube</title>
    <url>/Magic%20Cube/</url>
    <content><![CDATA[<h1 id="传送门ZOJ2477"><a href="#传送门ZOJ2477" class="headerlink" title="传送门ZOJ2477"></a>传送门<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2477" target="_blank" rel="noopener">ZOJ2477</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>This is a very popular game for children. In this game, there’s a cube, which consists of 3 <em> 3 </em> 3 small cubes. We can unwrap the cube, it will become like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      w w w</span><br><span class="line">      w w w</span><br><span class="line">      w w w</span><br><span class="line">r r r g g g b b b o o o</span><br><span class="line">r r r g g g b b b o o o</span><br><span class="line">r r r g g g b b b o o o</span><br><span class="line">      y y y</span><br><span class="line">      y y y</span><br><span class="line">      y y y</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>The letters means the color on the small cubes. For example, ‘r’ means red, ‘g’ means green, ‘y’ means yellow….The goal for this game is to rotate the faces of the cube to make each of the faces contains only one color. Note there’re exact 6 kind of colors on the cube and there’re exact 9 small rectangles totally in any time in the game.<br>Do you know how to rotate the faces? I think most of you have known it. But I would like to show it again. When a face is rotated, the configuration of colors in all the adjacent faces changes. For the cube above, after we rotate the green face clock-wise, the last line of ‘w’ face will become the left column of ‘b’ face, the left column of ‘b’ face will become the top line of ‘y’ face, etc. As you may know, reaching the final position from a scrambled configuration can be quite challenging.<br>In this problem, you are given a configuration of the cube, and asked to give a way to reach the final position. To reduce the difficulty, the steps required will never be greater than 5.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input contains an integer in the first line, which indicates the number of the test cases. In each test case, there’re exact 10 lines. The first line is an empty line. The next 9 lines contain a configuration. The format can be seen in the sample input. For simplicity, we give an index to each face as follows:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    /---\</span><br><span class="line">    |   |</span><br><span class="line">    | 4 |</span><br><span class="line">    |   |</span><br><span class="line">/---+---+---+---\</span><br><span class="line">|   |   |   |   |</span><br><span class="line">| 0 | 1 | 2 | 3 |</span><br><span class="line">|   |   |   |   |</span><br><span class="line">\---+---+---+---/</span><br><span class="line">    |   |</span><br><span class="line">    | 5 |</span><br><span class="line">    |   |</span><br><span class="line">    \---/</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Note that there’s a space between two adjacent letters.</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, the first line of the output is the smallest count N of the steps to reach the winning position. If the winning position can’t be reached in 5 steps, print -1 in this line. Otherwise print each step in one line in the following N lines. A step contains two integers, the first one means the face index, and the second one means the direction. 1 means clock-wise and -1 means counter clock-wise. If the given position is the winning position, print 0 for such test case simply. If there’re multiple solutions, any one is acceptable.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">      w w w</span><br><span class="line">      w w w</span><br><span class="line">      w w w</span><br><span class="line">r r r g g g b b b o o o</span><br><span class="line">r r r g g g b b b o o o</span><br><span class="line">r r r g g g b b b o o o</span><br><span class="line">      y y y</span><br><span class="line">      y y y</span><br><span class="line">      y y y</span><br><span class="line"></span><br><span class="line">      w w w</span><br><span class="line">      w w w</span><br><span class="line">      b b b</span><br><span class="line">r r w g g g y b b o o o</span><br><span class="line">r r w g g g y b b o o o</span><br><span class="line">r r w g g g y b b o o o</span><br><span class="line">      r r r</span><br><span class="line">      y y y</span><br><span class="line">      y y y</span><br></pre></td></tr></table></figure>
</li>
<li><p>Output<br>0<br>1<br>1 1</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给出魔方六面，每一面标号如上，给出一种排列，你需要把它复原，求最少步数和步骤，不能超过5步。1表示顺时针，-1表示逆时针。</li>
<li>迭代深搜，deep从1到5。贼恶心一题，详细步骤看代码<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> cube[<span class="number">6</span>][<span class="number">9</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">22</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>&#125;,&#123;<span class="number">25</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">24</span>,<span class="number">26</span>,<span class="number">36</span>,<span class="number">37</span>,<span class="number">38</span>&#125;,</span><br><span class="line">    &#123;<span class="number">28</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">29</span>,<span class="number">39</span>,<span class="number">40</span>,<span class="number">41</span>&#125;,&#123;<span class="number">31</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>&#125;,&#123;<span class="number">49</span>,<span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>,<span class="number">53</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//只有20个需要改变，每个中心无需改变，转动时从i行变成i^1行</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rot[<span class="number">12</span>][<span class="number">20</span>]=&#123;</span><br><span class="line">         &#123;<span class="number">11</span>,<span class="number">23</span>,<span class="number">35</span>,<span class="number">34</span>,<span class="number">33</span>,<span class="number">21</span>, <span class="number">9</span>,<span class="number">10</span>,<span class="number">51</span>,<span class="number">48</span>,<span class="number">45</span>,<span class="number">36</span>,<span class="number">24</span>,<span class="number">12</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>,<span class="number">20</span>,<span class="number">32</span>,<span class="number">44</span>&#125;, </span><br><span class="line">         &#123; <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">35</span>,<span class="number">34</span>,<span class="number">33</span>,<span class="number">21</span>,<span class="number">36</span>,<span class="number">24</span>,<span class="number">12</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>,<span class="number">20</span>,<span class="number">32</span>,<span class="number">44</span>,<span class="number">51</span>,<span class="number">48</span>,<span class="number">45</span>&#125;,</span><br><span class="line">         &#123;<span class="number">14</span>,<span class="number">13</span>,<span class="number">26</span>,<span class="number">38</span>,<span class="number">37</span>,<span class="number">36</span>,<span class="number">24</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">27</span>,<span class="number">15</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">35</span>&#125;,</span><br><span class="line">         &#123;<span class="number">12</span>,<span class="number">24</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">38</span>,<span class="number">37</span>,<span class="number">36</span>,<span class="number">39</span>,<span class="number">27</span>,<span class="number">15</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">35</span>,<span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>&#125;,</span><br><span class="line">         &#123;<span class="number">17</span>,<span class="number">29</span>,<span class="number">41</span>,<span class="number">40</span>,<span class="number">39</span>,<span class="number">27</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">47</span>,<span class="number">50</span>,<span class="number">53</span>,<span class="number">42</span>,<span class="number">30</span>,<span class="number">18</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">38</span>&#125;,</span><br><span class="line">         &#123;<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">29</span>,<span class="number">41</span>,<span class="number">40</span>,<span class="number">39</span>,<span class="number">27</span>,<span class="number">42</span>,<span class="number">30</span>,<span class="number">18</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">38</span>,<span class="number">47</span>,<span class="number">50</span>,<span class="number">53</span>&#125;,</span><br><span class="line">         &#123;<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">32</span>,<span class="number">44</span>,<span class="number">43</span>,<span class="number">42</span>,<span class="number">30</span>,<span class="number">53</span>,<span class="number">52</span>,<span class="number">51</span>,<span class="number">33</span>,<span class="number">21</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,<span class="number">17</span>,<span class="number">29</span>,<span class="number">41</span>&#125;,</span><br><span class="line">         &#123;<span class="number">42</span>,<span class="number">30</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">32</span>,<span class="number">44</span>,<span class="number">43</span>,<span class="number">33</span>,<span class="number">21</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,<span class="number">17</span>,<span class="number">29</span>,<span class="number">41</span>,<span class="number">53</span>,<span class="number">52</span>,<span class="number">51</span>&#125;,</span><br><span class="line">         &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>, <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;,</span><br><span class="line">         &#123; <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>, <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;,</span><br><span class="line">         &#123;<span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">50</span>,<span class="number">53</span>,<span class="number">52</span>,<span class="number">51</span>,<span class="number">48</span>,<span class="number">44</span>,<span class="number">43</span>,<span class="number">42</span>,<span class="number">41</span>,<span class="number">40</span>,<span class="number">39</span>,<span class="number">38</span>,<span class="number">37</span>,<span class="number">36</span>,<span class="number">35</span>,<span class="number">34</span>,<span class="number">33</span>&#125;,</span><br><span class="line">         &#123;<span class="number">51</span>,<span class="number">48</span>,<span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">50</span>,<span class="number">53</span>,<span class="number">52</span>,<span class="number">41</span>,<span class="number">40</span>,<span class="number">39</span>,<span class="number">38</span>,<span class="number">37</span>,<span class="number">36</span>,<span class="number">35</span>,<span class="number">34</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">43</span>,<span class="number">42</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> deep=<span class="number">0</span>,ans[<span class="number">10</span>][<span class="number">2</span>];<span class="comment">//ans[i][0]表示深度为i时转动的面，ans[i][1]表示转动方向</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[cube[i][j]]!=a[cube[i][j+<span class="number">1</span>]])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=k^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> tem[<span class="number">60</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(tem,a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        a[rot[k][i]]=tem[rot[t][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;deep) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(judge()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> tem[<span class="number">60</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(tem,a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        change(i);</span><br><span class="line">        ans[t][<span class="number">0</span>]=i/<span class="number">2</span>;</span><br><span class="line">        ans[t][<span class="number">1</span>]=i&amp;<span class="number">1</span> ? <span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(t+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(a,tem,<span class="keyword">sizeof</span>(tem));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">0</span>;cas&lt;t;cas++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cas) getchar();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">54</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                a[i]=getchar();</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;=<span class="string">'a'</span>&amp;&amp;a[i]&lt;=<span class="string">'z'</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(deep=<span class="number">0</span>;deep&lt;=<span class="number">6</span>;deep++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deep==<span class="number">6</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dfs(<span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,deep);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deep;i++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans[i][<span class="number">0</span>],ans[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>DNA Sequence(IDA*,迭代深搜)</title>
    <url>/DNA%20Sequence/</url>
    <content><![CDATA[<h1 id="传送门HDU1560"><a href="#传送门HDU1560" class="headerlink" title="传送门HDU1560"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1560" target="_blank" rel="noopener">HDU1560</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>The twenty-first century is a biology-technology developing century. We know that a gene is made of DNA. The nucleotide bases from which DNA is built are A(adenine), C(cytosine), G(guanine), and T(thymine). Finding the longest common subsequence between DNA/Protein sequences is one of the basic problems in modern computational molecular biology. But this problem is a little different. Given several DNA sequences, you are asked to make a shortest sequence from them so that each of the given sequence is the subsequence of it. </p>
</blockquote>
<p>For example, given “ACGT”,”ATGC”,”CGTT” and “CAGT”, you can make a sequence in the following way. It is the shortest but may be not the only one.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line is the test case number t. Then t test cases follow. In each case, the first line is an integer n ( 1&lt;=n&lt;=8 ) represents number of the DNA sequences. The following k lines contain the k sequences, one per line. Assuming that the length of any sequence is between 1 and 5.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, print a line containing the length of the shortest sequence that can be made from these sequences.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>1<br>4<br>ACGT<br>ATGC<br>CGTT<br>CAGT</p>
</li>
<li><p>Output<br>8</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给出几个DNA序列，求一个最短的字符串，使得这些DNA序列都是它的子序列</li>
<li>此题用裸dfs的话不知道结束条件容易超时，用裸bfs很容易超内存，所以我们采用迭代深搜的方法。所谓迭代深搜就是限制dfs的深度，逐渐将深度加深，起到模拟bfs的作用，又不需要bfs那么多内存，但是肯定是比bfs耗时要长</li>
<li>在迭代深搜时，用deep表示限制深度，用tot表示当前串长度，用pos[i]表示i串目前已被匹配的字符个数，如果(tot+(len[i]-pos[i])&gt;deep)的话，说明当前限制下的深度肯定不够，这样起到剪枝的效果，也就成了所谓的IDA*搜索</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">string</span> dna[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> len[<span class="number">10</span>],pos[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"ACGT"</span>;</span><br><span class="line"><span class="keyword">int</span> n,deep;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ans=max(ans,len[i]-pos[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tot+fut()&gt;deep) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!fut()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tem[<span class="number">10</span>],flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;i++)</span><br><span class="line">            tem[i]=pos[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==dna[j][pos[j]])&#123;</span><br><span class="line">                pos[j]++;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(tot+<span class="number">1</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                pos[i]=tem[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        deep=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;dna[i];</span><br><span class="line">            len[i]=dna[i].size();</span><br><span class="line">            pos[i]=<span class="number">0</span>;</span><br><span class="line">            deep=max(deep,len[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!dfs(<span class="number">0</span>))</span><br><span class="line">			deep++;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;deep&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Escape</title>
    <url>/Escape/</url>
    <content><![CDATA[<h1 id="传送门HDU3533"><a href="#传送门HDU3533" class="headerlink" title="传送门HDU3533"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3533" target="_blank" rel="noopener">HDU3533</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>The students of the HEU are maneuvering for their military training.<br>The red army and the blue army are at war today. The blue army finds that Little A is the spy of the red army, so Little A has to escape from the headquarters of the blue army to that of the red army. The battle field is a rectangle of size m*n, and the headquarters of the blue army and the red army are placed at (0, 0) and (m, n), respectively, which means that Little A will go from (0, 0) to (m, n). The picture below denotes the shape of the battle field and the notation of directions that we will use later.<br>The blue army is eager to revenge, so it tries its best to kill Little A during his escape. The blue army places many castles, which will shoot to a fixed direction periodically. It costs Little A one unit of energy per second, whether he moves or not. If he uses up all his energy or gets shot at sometime, then he fails. Little A can move north, south, east or west, one unit per second. Note he may stay at times in order not to be shot.<br>To simplify the problem, let’s assume that Little A cannot stop in the middle of a second. He will neither get shot nor block the bullet during his move, which means that a bullet can only kill Little A at positions with integer coordinates. Consider the example below. The bullet moves from (0, 3) to (0, 0) at the speed of 3 units per second, and Little A moves from (0, 0) to (0, 1) at the speed of 1 unit per second. Then Little A is not killed. But if the bullet moves 2 units per second in the above example, Little A will be killed at (0, 1).<br>Now, please tell Little A whether he can escape.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>For every test case, the first line has four integers, m, n, k and d (2&lt;=m, n&lt;=100, 0&lt;=k&lt;=100, m+ n&lt;=d&lt;=1000). m and n are the size of the battle ground, k is the number of castles and d is the units of energy Little A initially has. The next k lines describe the castles each. Each line contains a character c and four integers, t, v, x and y. Here c is ‘N’, ‘S’, ‘E’ or ‘W’ giving the direction to which the castle shoots, t is the period, v is the velocity of the bullets shot (i.e. units passed per second), and (x, y) is the location of the castle. Here we suppose that if a castle is shot by other castles, it will block others’ shots but will NOT be destroyed. And two bullets will pass each other without affecting their directions and velocities.<br>All castles begin to shoot when Little A starts to escape.<br>Proceed to the end of file. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>If Little A can escape, print the minimum time required in seconds on a single line. Otherwise print “Bad luck!” without quotes.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>4 4 3 10<br>N 1 1 1 1<br>W 1 1 3 2<br>W 2 1 2 4<br>4 4 3 10<br>N 1 1 1 1<br>W 1 1 3 2<br>W 1 1 2 4</p>
</li>
<li><p>Output<br>9<br>Bad luck!</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：人要在规定时间内从(0,0)走到(m,n)，每次可以上下左右四个方向走，地方有炮台进行攻击，炮台每t秒攻击一次，每次攻击每秒弹v格，只能打到弹到的格子，如果弹射过程中遇到其他炮台则会被挡住（在空中也会被挡住），人在移动时不能被炮弹打到，也不能走到炮台的位置，但是可以站在原地等炮弹过去，求人到达目的地的最短时间，超出规定时间或被炮台击中输出Bad luck!<br>输入m n k d(m*n的格子，k个炮台，规定时间d),接下来k行输入炮台的射击方向，射击周期，移动速度v，炮台位置</li>
<li>判断人在time1时刻是否会被炮台打到时需要考虑炮台的射击方向、炮弹是否会被挡住，如果人站在炮台射击方向上并且炮弹不会被其他炮弹挡住的话，判断人与炮弹之间的距离是否是v的倍数，不是则不会被击中，如果是，则计算炮弹到达人位置的时间time2,如果(time1-time2)%t!=0,则不会被击中</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,k,d;</span><br><span class="line"><span class="keyword">int</span> vis[N][N][N];</span><br><span class="line"><span class="keyword">int</span> rec[<span class="number">5</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> fx,fy;<span class="comment">//最远可达</span></span><br><span class="line">    <span class="keyword">int</span> t,v,x,y;</span><br><span class="line">&#125;pao[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">man</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(p==q)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>((pao[p].c==<span class="string">'N'</span>||pao[p].c==<span class="string">'S'</span>) &amp;&amp; j!=pao[p].y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>((pao[p].c==<span class="string">'W'</span>||pao[p].c==<span class="string">'E'</span>) &amp;&amp; i!=pao[p].x) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//在射击路线上即挡住</span></span><br><span class="line">        <span class="keyword">if</span>((pao[p].x-i)*(i-pao[p].fx)&gt;=<span class="number">0</span>&amp;&amp;(pao[p].y-j)*(j-pao[p].fy)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            pao[p].fx=i,pao[p].fy=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(time&gt;d) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;m||j&lt;<span class="number">0</span>||j&gt;n)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==pao[p].x &amp;&amp; j==pao[p].y)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((pao[p].c==<span class="string">'N'</span>||pao[p].c==<span class="string">'S'</span>) &amp;&amp; j!=pao[p].y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>((pao[p].c==<span class="string">'W'</span>||pao[p].c==<span class="string">'E'</span>) &amp;&amp; i!=pao[p].x) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>((pao[p].x-i)*(i-pao[p].fx)&lt;<span class="number">0</span>||(pao[p].y-j)*(j-pao[p].fy)&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> dis=<span class="built_in">abs</span>(i-pao[p].x)+<span class="built_in">abs</span>(j-pao[p].y);</span><br><span class="line">        <span class="keyword">if</span>(dis % pao[p].v!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(time&lt;dis/pao[p].v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>((time-dis/pao[p].v)%pao[p].t==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;man&gt; que;</span><br><span class="line">    que.push((man)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        man q=que.front();que.pop();</span><br><span class="line">        <span class="keyword">if</span>(q.x==m &amp;&amp; q.y==n) <span class="keyword">return</span> q.time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx=q.x+rec[i][<span class="number">0</span>],ty=q.y+rec[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!vis[tx][ty][q.time+<span class="number">1</span>]&amp;&amp;judge(tx,ty,q.time+<span class="number">1</span>))&#123;</span><br><span class="line">                que.push((man)&#123;tx,ty,q.time+<span class="number">1</span>&#125;);</span><br><span class="line">                vis[tx][ty][q.time+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;m,&amp;n,&amp;k,&amp;d))&#123;</span><br><span class="line">        INIT(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c%d%d%d%d"</span>,&amp;pao[i].c,&amp;pao[i].t,&amp;pao[i].v,&amp;pao[i].x,&amp;pao[i].y);</span><br><span class="line">            <span class="keyword">if</span>(pao[i].c==<span class="string">'N'</span>)pao[i].fx=<span class="number">0</span>,pao[i].fy=pao[i].y;</span><br><span class="line">            <span class="keyword">if</span>(pao[i].c==<span class="string">'S'</span>)pao[i].fx=m,pao[i].fy=pao[i].y;</span><br><span class="line">            <span class="keyword">if</span>(pao[i].c==<span class="string">'E'</span>)pao[i].fx=pao[i].x,pao[i].fy=n;</span><br><span class="line">            <span class="keyword">if</span>(pao[i].c==<span class="string">'W'</span>)pao[i].fx=pao[i].x,pao[i].fy=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            init(pao[i].x,pao[i].y,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=bfs();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">"Bad luck!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Eight2</title>
    <url>/Eight2/</url>
    <content><![CDATA[<h1 id="传送门HDU3567"><a href="#传送门HDU3567" class="headerlink" title="传送门HDU3567"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3567" target="_blank" rel="noopener">HDU3567</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Eight-puzzle, which is also called “Nine grids”, comes from an old game.<br>In this game, you are given a 3 by 3 board and 8 tiles. The tiles are numbered from 1 to 8 and each covers a grid. As you see, there is a blank grid which can be represented as an ‘X’. Tiles in grids having a common edge with the blank grid can be moved into that blank grid. This operation leads to an exchange of ‘X’ with one tile.<br>We use the symbol ‘r’ to represent exchanging ‘X’ with the tile on its right side, and ‘l’ for the left side, ‘u’ for the one above it, ‘d’ for the one below it.<br>A state of the board can be represented by a string S using the rule showed below.<br>The problem is to operate an operation list of ‘r’, ‘u’, ‘l’, ‘d’ to turn the state of the board from state A to state B. You are required to find the result which meets the following constrains: </p>
<ol>
<li>It is of minimum length among all possible solutions. </li>
<li>It is the lexicographically smallest one of all solutions of minimum length. <a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1>The first line is T (T &lt;= 200), which means the number of test cases of this problem.<br>The input of each test case consists of two lines with state A occupying the first line and state B on the second line.<br>It is guaranteed that there is an available solution from state A to B. </li>
</ol>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case two lines are expected.<br>The first line is in the format of “Case x: d”, in which x is the case number counted from one, d is the minimum length of operation list you need to turn A to B.<br>S is the operation list meeting the constraints and it should be showed on the second line. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>2<br>12X453786<br>12345678X<br>564178X23<br>7568X4123</p>
</li>
<li><p>Output<br>Case 1: 2<br>dd<br>Case 2: 8<br>urrulldr</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：与上一题不一样的是，此题要求从给定输入串处理到给定输出串</li>
<li>将字符串采用映射的方式进行预处理，然后O(t)查询，t为答案长度。</li>
<li>将输入串的X置0，其他的数从1到8一次排列形成映射，则初始状态就只有10种，预处理这10中状态能到达的状态。</li>
<li>对于样例中的564178X23,我们将其映射为123456078，则7568X4123就相应得被映射为512603478。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">362885</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">string</span> ori[<span class="number">10</span>]=&#123;<span class="string">"012345678"</span>,<span class="string">"102345678"</span>,<span class="string">"120345678"</span>,<span class="string">"123045678"</span>,<span class="string">"123405678"</span>,</span><br><span class="line"><span class="string">"123450678"</span>,<span class="string">"123456078"</span>,<span class="string">"123456708"</span>,<span class="string">"123456780"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rec[<span class="number">4</span>]=&#123;<span class="number">3</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-3</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> ops=<span class="string">"dlru"</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10</span>][N];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">10</span>][N];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10</span>][N],fac[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> sta;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cantor</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i]) c++;</span><br><span class="line">        ans+=c*fac[<span class="number">9</span>-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(to&lt;<span class="number">0</span>||to&gt;=<span class="number">9</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">2</span>&amp;&amp;to==<span class="number">3</span>)||(x==<span class="number">3</span>&amp;&amp;to==<span class="number">2</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">5</span>&amp;&amp;to==<span class="number">6</span>)||(x==<span class="number">6</span>&amp;&amp;to==<span class="number">5</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    <span class="keyword">int</span> c=cantor(ori[t]);</span><br><span class="line">    vis[t][c]=<span class="number">0</span>;</span><br><span class="line">    que.push((node)&#123;ori[t],t&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node q=que.front();que.pop();</span><br><span class="line">        c=cantor(q.sta);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=q.x+rec[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(q.x,to))&#123;</span><br><span class="line">                swap(q.sta[q.x],q.sta[to]);</span><br><span class="line">                <span class="keyword">int</span> c1=cantor(q.sta);</span><br><span class="line">                <span class="keyword">if</span>(vis[t][c1]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    vis[t][c1]=vis[t][c]+<span class="number">1</span>;</span><br><span class="line">                    que.push((node)&#123;q.sta,to&#125;);</span><br><span class="line">                    ans[t][c1]=i;</span><br><span class="line">                    pre[t][c1]=c;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(q.sta[q.x],q.sta[to]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[n][c]==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    print(n,pre[n][c]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,ops[ans[n][c]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ios::sync_with_stdio(false);//不要关闭流同步，会wa</span></span><br><span class="line">	<span class="comment">//cin.tie(0);</span></span><br><span class="line">	INIT(vis,<span class="number">-1</span>);INIT(pre,<span class="number">-1</span>);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++) bfs(i);</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="built_in">string</span> s1,s2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _=<span class="number">1</span>;_&lt;=t;_++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;_&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==<span class="string">'X'</span>)&#123;</span><br><span class="line">                n=i;</span><br><span class="line">                h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> h[s1[i]-<span class="string">'0'</span>]=m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ss=<span class="string">"123456789"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s2[i]==<span class="string">'X'</span>) s2[i]=<span class="string">'0'</span>;</span><br><span class="line">            ss[i]=h[s2[i]-<span class="string">'0'</span>]+<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c=cantor(ss);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;vis[n][c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        print(n,c);</span><br><span class="line">        <span class="keyword">if</span>(vis[n][c]!=<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Eight</title>
    <url>/Eight/</url>
    <content><![CDATA[<h1 id="传送门HDU1043"><a href="#传送门HDU1043" class="headerlink" title="传送门HDU1043"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1043" target="_blank" rel="noopener">HDU1043</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: </p>
<p>1  2  3  4<br> 5  6  7  8<br> 9 10 11 12<br>13 14 15  x</p>
<p>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1  2  3  4     1  2  3  4     1  2  3  4     1  2  3  4</span><br><span class="line"> 5  6  7  8     5  6  7  8     5  6  7  8     5  6  7  8</span><br><span class="line"> 9  x 10 12     9 10  x 12     9 10 11 12     9 10 11 12</span><br><span class="line">13 14 11 15    13 14 11 15    13 14  x 15    13 14 15  x</span><br><span class="line">            r-&gt;            d-&gt;            r-&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively. </p>
<p>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course). </p>
<p>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle<br>1 2 3<br>x 4 6<br>7 5 8<br>is described by this list:<br>1 2 3 x 4 6 7 5 8 </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>You will print to standard output either the word ``unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>2  3  4  1  5  x  7  6  8</p>
</li>
<li><p>Output<br>ullddrurdllurdruldr</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：3*3的表格，x可以和上下左右交换，最后通过移动x使整个表格有序且x在最后一格。求移动方案，输出路径，没有则输出-1</li>
<li>法一：从输入字符串和目标串开始进行双向bfs（3000+ms）</li>
<li>法二：bfs预处理出目标串到其他可达串的路径，然后O(t)查询，t为答案长度(300+ms)</li>
<li>因为内存有限，把x视为9，用康托展开存储答案。</li>
</ul>
</blockquote>
<h1 id="Code（法一）"><a href="#Code（法一）" class="headerlink" title="Code（法一）"></a>Code（法一）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双向bfs+康托</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">362885</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">string</span> title=<span class="string">"12345678x"</span>;</span><br><span class="line"><span class="built_in">string</span> mp=<span class="string">"111111111"</span>;</span><br><span class="line"><span class="built_in">string</span> ops[<span class="number">2</span>]=&#123;<span class="string">"udlr"</span>,<span class="string">"durl"</span>&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> rec[<span class="number">4</span>]=&#123;<span class="number">-3</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> sta;</span><br><span class="line">    <span class="keyword">int</span> xsit;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(to&lt;<span class="number">0</span>||to&gt;=<span class="number">9</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">2</span>&amp;&amp;to==<span class="number">3</span>)||(x==<span class="number">3</span>&amp;&amp;to==<span class="number">2</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">5</span>&amp;&amp;to==<span class="number">6</span>)||(x==<span class="number">6</span>&amp;&amp;to==<span class="number">5</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cantor</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])c++;</span><br><span class="line">        ans+=c*fac[<span class="number">9</span>-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=que[t].size();</span><br><span class="line">    node q;</span><br><span class="line">    <span class="keyword">while</span>(sum--)&#123;</span><br><span class="line">        q=que[t].front();que[t].pop();</span><br><span class="line">        <span class="keyword">int</span> can=cantor(q.sta);</span><br><span class="line">        <span class="keyword">if</span>(vis[t^<span class="number">1</span>][can]) <span class="keyword">return</span> can;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=q.xsit+rec[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(q.xsit,to))&#123;</span><br><span class="line">                swap(q.sta[q.xsit],q.sta[to]);</span><br><span class="line">                <span class="keyword">int</span> _can=cantor(q.sta);</span><br><span class="line">                <span class="keyword">if</span>(!vis[t][_can])&#123;</span><br><span class="line">                    vis[t][_can]=<span class="number">1</span>;</span><br><span class="line">                    que[t].push((node)&#123;q.sta,to&#125;);</span><br><span class="line">                    op[t][_can]=op[t][can]+ops[t][i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(q.sta[q.xsit],q.sta[to]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    INIT(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!que[<span class="number">0</span>].empty())que[<span class="number">0</span>].pop();</span><br><span class="line">    <span class="keyword">while</span>(!que[<span class="number">1</span>].empty())que[<span class="number">1</span>].pop();</span><br><span class="line">    que[<span class="number">0</span>].push((node)&#123;mp,t&#125;);</span><br><span class="line">    que[<span class="number">1</span>].push((node)&#123;title,<span class="number">8</span>&#125;);</span><br><span class="line">    op[<span class="number">0</span>].clear(),op[<span class="number">1</span>].clear();</span><br><span class="line">    op[<span class="number">0</span>][cantor(mp)]=<span class="string">""</span>;</span><br><span class="line">    op[<span class="number">1</span>][<span class="number">0</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(que[<span class="number">0</span>].size()||que[<span class="number">1</span>].size())&#123;</span><br><span class="line">        <span class="keyword">int</span> ans1=solve(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans2=solve(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans1!=<span class="number">-1</span>||ans2!=<span class="number">-1</span>)&#123;</span><br><span class="line">            ans=(ans1==<span class="number">-1</span>)?ans2:ans1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(op[<span class="number">1</span>][ans].begin(),op[<span class="number">1</span>][ans].end());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;op[<span class="number">0</span>][ans]&lt;&lt;op[<span class="number">1</span>][ans]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        fac[i]=i*fac[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;mp[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;mp[i];</span><br><span class="line">            <span class="keyword">if</span>(mp[i]==<span class="string">'x'</span>) t=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i]==<span class="string">'x'</span>) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[j]==<span class="string">'x'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(mp[j]&gt;mp[i]) sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &amp; <span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsolvable"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//逆序数为奇数则无解</span></span><br><span class="line">        <span class="keyword">else</span> bfs(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Code-法二"><a href="#Code-法二" class="headerlink" title="Code(法二)"></a>Code(法二)</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预处理答案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">string</span> title=<span class="string">"12345678x"</span>;</span><br><span class="line"><span class="built_in">string</span> mp=<span class="string">"111111111"</span>;</span><br><span class="line"><span class="built_in">string</span> ops=<span class="string">"durl"</span>;</span><br><span class="line"><span class="keyword">int</span> rec[<span class="number">4</span>]=&#123;<span class="number">-3</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pre[N],ans[N],vis[N],fac[<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> sta;</span><br><span class="line">    <span class="keyword">int</span> xsit;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(to&lt;<span class="number">0</span>||to&gt;=<span class="number">9</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">2</span>&amp;&amp;to==<span class="number">3</span>)||(x==<span class="number">3</span>&amp;&amp;to==<span class="number">2</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">5</span>&amp;&amp;to==<span class="number">6</span>)||(x==<span class="number">6</span>&amp;&amp;to==<span class="number">5</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cantor</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])c++;</span><br><span class="line">        ans+=c*fac[<span class="number">9</span>-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    INIT(vis,<span class="number">0</span>);</span><br><span class="line">    INIT(pre,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;que;</span><br><span class="line">    que.push((node)&#123;title,<span class="number">8</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> can=cantor(title);</span><br><span class="line">    vis[can]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node q=que.front();que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=q.xsit+rec[i];</span><br><span class="line">            can=cantor(q.sta);</span><br><span class="line">            <span class="keyword">if</span>(judge(q.xsit,to))&#123;</span><br><span class="line">                swap(q.sta[q.xsit],q.sta[to]);</span><br><span class="line">                <span class="keyword">int</span> _can=cantor(q.sta);</span><br><span class="line">                <span class="keyword">if</span>(!vis[_can])&#123;</span><br><span class="line">                    vis[_can]=<span class="number">1</span>;</span><br><span class="line">                    que.push((node)&#123;q.sta,to&#125;);</span><br><span class="line">                    ans[_can]=i;</span><br><span class="line">                    pre[_can]=can;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(q.sta[q.xsit],q.sta[to]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[c]==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ops[ans[c]];</span><br><span class="line">    print(pre[c]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        fac[i]=i*fac[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;mp[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;mp[i];</span><br><span class="line">            <span class="keyword">if</span>(mp[i]==<span class="string">'x'</span>) t=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> can=cantor(mp);</span><br><span class="line">        <span class="keyword">if</span>(!vis[can]) <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsolvable"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> print(can);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Find a way</title>
    <url>/Find-a-way/</url>
    <content><![CDATA[<h1 id="传送门HDU2612"><a href="#传送门HDU2612" class="headerlink" title="传送门HDU2612"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2612" target="_blank" rel="noopener">HDU2612</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.<br>Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.<br>Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The input contains multiple test cases.<br>Each test case include, first two integers n, m. (2&lt;=n,m&lt;=200).<br>Next n lines, each line included m character.<br>‘Y’ express yifenfei initial position.<br>‘M’    express Merceki initial position.<br>‘#’ forbid road;<br>‘.’ Road.<br>‘@’ KCF</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">Y.#@</span><br><span class="line">....</span><br><span class="line">.#..</span><br><span class="line">@..M</span><br><span class="line">4 4</span><br><span class="line">Y.#@</span><br><span class="line">....</span><br><span class="line">.#..</span><br><span class="line">@#.M</span><br><span class="line">5 5</span><br><span class="line">Y..@.</span><br><span class="line">.#...</span><br><span class="line">.#...</span><br><span class="line">@..M.</span><br><span class="line">#...#</span><br></pre></td></tr></table></figure>
</li>
<li><p>Output<br>66<br>88<br>66</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：地图上有多个KFC，小Y和小M一起从家出发前往一家KFC碰面，每单位可以往上下左右走，求在哪个KFC碰面所需时间最短，输出最短时间       </li>
<li>分别以小Y和小M为起点跑两次BFS，预处理处理他们到所有KFC所需时间，然后遍历找最小和即可。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> ans[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,sx,sy,ex,ey;</span><br><span class="line"><span class="keyword">int</span> rec[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>, <span class="number">-1</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">1</span>, <span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i,j,time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=m||vis[x][y]||mp[x][y]==<span class="string">'#'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    INIT(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;x,y,<span class="number">0</span>&#125;);</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node q=que.front();que.pop();</span><br><span class="line">        <span class="keyword">if</span>(mp[q.i][q.j]==<span class="string">'@'</span>) ans[q.i][q.j][t]=q.time * <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx=q.i+rec[k][<span class="number">0</span>],ty=q.j+rec[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(judge(tx,ty))&#123;</span><br><span class="line">                vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">                que.push((node)&#123;tx,ty,q.time+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        INIT(ans,inf);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'Y'</span>) sx=i,sy=j;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'M'</span>) ex=i,ey=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(sx,sy,<span class="number">0</span>);</span><br><span class="line">        bfs(ex,ey,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                res=min(ans[i][j][<span class="number">0</span>]+ans[i][j][<span class="number">1</span>],res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>非常可乐</title>
    <url>/%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90/</url>
    <content><![CDATA[<h1 id="传送门HDU1495"><a href="#传送门HDU1495" class="headerlink" title="传送门HDU1495"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1495" target="_blank" rel="noopener">HDU1495</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>如果能平分的话请输出最少要倒的次数，否则输出”NO”。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>7 4 3<br>4 1 3<br>0 0 0</p>
</li>
<li><p>Output<br>NO<br>3</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>bfs</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N][N][N];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sta</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> h[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Sta&gt; que;</span><br><span class="line">    que.push((Sta)&#123;&#123;s[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>&#125;,<span class="number">0</span>&#125;);</span><br><span class="line">    vis[s[<span class="number">0</span>]][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> can,tem[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        Sta q=que.front();que.pop();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;q.h[0]&lt;&lt;" "&lt;&lt;q.h[1]&lt;&lt;" "&lt;&lt;q.h[2]&lt;&lt;" "&lt;&lt;q.time&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>((q.h[<span class="number">0</span>]==q.h[<span class="number">1</span>]&amp;&amp;q.h[<span class="number">0</span>]*<span class="number">2</span>==s[<span class="number">0</span>])||(q.h[<span class="number">1</span>]==q.h[<span class="number">2</span>]&amp;&amp;q.h[<span class="number">1</span>]*<span class="number">2</span>==s[<span class="number">0</span>])||(q.h[<span class="number">0</span>]==q.h[<span class="number">2</span>]&amp;&amp;q.h[<span class="number">0</span>]*<span class="number">2</span>==s[<span class="number">0</span>])) <span class="keyword">return</span> q.time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">                can=min(q.h[i],s[j]-q.h[j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">                    tem[k]=q.h[k];</span><br><span class="line">                <span class="keyword">if</span>(can)&#123;</span><br><span class="line">                    tem[i]-=can,tem[j]+=can;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[tem[<span class="number">0</span>]][tem[<span class="number">1</span>]][tem[<span class="number">2</span>]])&#123;</span><br><span class="line">                        que.push((Sta)&#123;&#123;tem[<span class="number">0</span>],tem[<span class="number">1</span>],tem[<span class="number">2</span>]&#125;,q.time+<span class="number">1</span>&#125;);</span><br><span class="line">                        vis[tem[<span class="number">0</span>]][tem[<span class="number">1</span>]][tem[<span class="number">2</span>]]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s[<span class="number">0</span>]&gt;&gt;s[<span class="number">1</span>]&gt;&gt;s[<span class="number">2</span>]&amp;&amp;(s[<span class="number">0</span>]||s[<span class="number">1</span>]||s[<span class="number">2</span>]))&#123;</span><br><span class="line">        INIT(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=bfs();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Fire</title>
    <url>/Fire/</url>
    <content><![CDATA[<h1 id="传送门UVA11624"><a href="#传送门UVA11624" class="headerlink" title="传送门UVA11624"></a>传送门<a href="https://cn.vjudge.net/problem/UVA-11624" target="_blank" rel="noopener">UVA11624</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Joe works in a maze. Unfortunately, portions of the maze have<br>caught on fire, and the owner of the maze neglected to create a fire<br>escape plan. Help Joe escape the maze.<br>Given Joe’s location in the maze and which squares of the maze<br>are on fire, you must determine whether Joe can exit the maze before<br>the fire reaches him, and how fast he can do it.<br>Joe and the fire each move one square per minute, vertically or<br>horizontally (not diagonally). The fire spreads all four directions<br>from each square that is on fire. Joe may exit the maze from any<br>square that borders the edge of the maze. Neither Joe nor the fire<br>may enter a square that is occupied by a wall.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The first line of input contains a single integer, the number of test<br>cases to follow. The first line of each test case contains the two<br>integers R and C, separated by spaces, with 1 ≤ R, C ≤ 1000. The<br>following R lines of the test case each contain one row of the maze. Each of these lines contains exactly<br>C characters, and each of these characters is one of:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. #, a wall</span><br><span class="line">2. ., a passable square</span><br><span class="line">3. J, Joe’s initial position in the maze, which is a passable square</span><br><span class="line">4. F, a square that is on fire</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>There will be exactly one J in each test case.</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, output a single line containing ‘IMPOSSIBLE’ if Joe cannot exit the maze before the<br>fire reaches him, or an integer giving the earliest time Joe can safely exit the maze, in minutes.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 4</span><br><span class="line">####</span><br><span class="line">#JF#</span><br><span class="line">#..#</span><br><span class="line">#..#</span><br><span class="line">3 3</span><br><span class="line">###</span><br><span class="line">#J.</span><br><span class="line">#.F</span><br></pre></td></tr></table></figure>
</li>
<li><p>Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">IMPOSSIBLE</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：迷宫逃脱，一开始有多个火焰源，火焰每单位时间向四周蔓延一格，人每单位可以向四周移动一格，人可以从任意边界逃脱，但是不能碰到火焰，求最短逃脱时间。</li>
<li>先多起点bfs预处理出每一个格子的火焰到达时间，然后对人进行bfs即可。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,jx,jy;</span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> fi[N][N],vis[N][N];</span><br><span class="line"><span class="keyword">int</span> rec[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">away</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>||i==n<span class="number">-1</span>||j==<span class="number">0</span>||j==m<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=n||j&lt;<span class="number">0</span>||j&gt;=m||vis[i][j]||mp[i][j]==<span class="string">'#'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; fque;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!fque.empty())&#123;</span><br><span class="line">        node q=fque.front();fque.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx=q.x+rec[i][<span class="number">0</span>],ny=q.y+rec[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(judge(nx,ny))&#123;</span><br><span class="line">                fque.push((node)&#123;nx,ny,q.time+<span class="number">1</span>&#125;);</span><br><span class="line">                fi[nx][ny]=q.time+<span class="number">1</span>;</span><br><span class="line">                vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    INIT(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;jx,jy,<span class="number">1</span>&#125;);</span><br><span class="line">    vis[jx][jy]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node q=que.front();que.pop();</span><br><span class="line">        <span class="keyword">if</span>(away(q.x,q.y)) <span class="keyword">return</span> q.time;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx=q.x+rec[i][<span class="number">0</span>],ny=q.y+rec[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(judge(nx,ny)&amp;&amp;q.time+<span class="number">1</span>&lt;fi[nx][ny])&#123;</span><br><span class="line">                que.push((node)&#123;nx,ny,q.time+<span class="number">1</span>&#125;);</span><br><span class="line">                vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        INIT(fi,inf),INIT(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;mp[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'J'</span>) jx=i,jy=j;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'F'</span>) &#123;</span><br><span class="line">                    fque.push((node)&#123;i,j,<span class="number">1</span>&#125;);</span><br><span class="line">                    vis[i][j]=<span class="number">1</span>;</span><br><span class="line">                    fi[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fire();</span><br><span class="line">        <span class="keyword">int</span> ans=bfs();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Fire Game(双起点BFS)</title>
    <url>/Fire-Game-%E5%8F%8C%E8%B5%B7%E7%82%B9BFS/</url>
    <content><![CDATA[<h1 id="传送门FZU2150"><a href="#传送门FZU2150" class="headerlink" title="传送门FZU2150"></a>传送门<a href="http://acm.fzu.edu.cn/problem.php?pid=2150" target="_blank" rel="noopener">FZU2150</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Fat brother and Maze are playing a kind of special (hentai) game on an N*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire. As we all know, the fire can spread among the grass. If the grid (x, y) is firing at time t, the grid which is adjacent to this grid will fire at time t+1 which refers to the grid (x+1, y), (x-1, y), (x, y+1), (x, y-1). This process ends when no new grid get fire. If then all the grid which are consisting of grass is get fired, Fat brother and Maze will stand in the middle of the grid and playing a MORE special (hentai) game. (Maybe it’s the OOXX game which decrypted in the last problem, who knows.)<br>You can assume that the grass in the board would never burn out and the empty grid would never get fire.<br>Note that the two grids they choose can be the same.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The first line of the date is an integer T, which is the number of the text cases.<br>Then T cases follow, each case contains two integers N and M indicate the size of the board. Then goes N line, each line with M character shows the board. “#” Indicates the grass. You can assume that there is at least one grid which is consisting of grass in the board.<br>1 &lt;= T &lt;=100, 1 &lt;= n &lt;=10, 1 &lt;= m &lt;=10</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each case, output the case number first, if they can play the MORE special (hentai) game (fire all the grass), output the minimal time they need to wait after they set fire, otherwise just output -1. See the sample input and output for more details.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 3</span><br><span class="line">.#.</span><br><span class="line">###</span><br><span class="line">.#.</span><br><span class="line">3 3</span><br><span class="line">.#.</span><br><span class="line">#.#</span><br><span class="line">.#.</span><br><span class="line">3 3</span><br><span class="line">...</span><br><span class="line">#.#</span><br><span class="line">...</span><br><span class="line">3 3</span><br><span class="line">###</span><br><span class="line">..#</span><br><span class="line">#.#</span><br></pre></td></tr></table></figure>
</li>
<li><p>Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">Case 1: 1</span><br><span class="line">Case 2: -1</span><br><span class="line">Case 3: 0</span><br><span class="line">Case 4: 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：为了将草丛变成空地，现在需要找两个点放火，火会向上下左右蔓延，空地不会被点燃，每向四周蔓延一格需要1单位的时间，求最少需要多久可以将所有草烧完，无法烧完则输出-1</li>
<li>双起点bfs，n方枚举两个起点放入队列，然后bfs即可<br>记录路径<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> gra[N*N][<span class="number">2</span>],tot=<span class="number">0</span>,vis[N][N];</span><br><span class="line"><span class="keyword">int</span> rec[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=n||j&lt;<span class="number">0</span>||j&gt;=m||mp[i][j]==<span class="string">'.'</span>||vis[i][j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[gra[i][<span class="number">0</span>]][gra[i][<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node q=que.front();que.pop();</span><br><span class="line">        res=max(res,q.time);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx=q.x+rec[i][<span class="number">0</span>],ny=q.y+rec[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(judge(nx,ny))&#123;</span><br><span class="line">                que.push((node)&#123;nx,ny,q.time+<span class="number">1</span>&#125;);</span><br><span class="line">                vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(can()) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=t;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;k&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'#'</span>)&#123;</span><br><span class="line">                    gra[tot][<span class="number">0</span>]=i;</span><br><span class="line">                    gra[tot++][<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=inf,tem;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++)&#123;</span><br><span class="line">                INIT(vis,<span class="number">0</span>);</span><br><span class="line">                vis[gra[i][<span class="number">0</span>]][gra[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">                vis[gra[j][<span class="number">0</span>]][gra[j][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">                que.push((node)&#123;gra[i][<span class="number">0</span>],gra[i][<span class="number">1</span>],<span class="number">0</span>&#125;);</span><br><span class="line">                que.push((node)&#123;gra[j][<span class="number">0</span>],gra[j][<span class="number">1</span>],<span class="number">0</span>&#125;);</span><br><span class="line">                tem=bfs();</span><br><span class="line">                <span class="keyword">if</span>(tem!=<span class="number">-1</span>) ans=min(tem,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==inf)<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Pots</title>
    <url>/Pots/</url>
    <content><![CDATA[<h1 id="传送门POJ3414"><a href="#传送门POJ3414" class="headerlink" title="传送门POJ3414"></a>传送门<a href="http://poj.org/problem?id=3414" target="_blank" rel="noopener">POJ3414</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>You are given two pots, having the volume of A and B liters respectively. The following operations can be performed:</p>
<ol>
<li>FILL(i)        fill the pot i (1 ≤ i ≤ 2) from the tap;</li>
<li>DROP(i)      empty the pot i to the drain;</li>
<li>POUR(i,j)    pour from pot i to pot j; after this operation either the &gt;pot j is full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j).<br>Write a program to find the shortest possible sequence of these operations that will yield exactly C liters of water in one of the pots.<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1>On the first and only line are the numbers A, B, and C. These are all integers in the range from 1 to 100 and C≤max(A,B).</li>
</ol>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>The first line of the output must contain the length of the sequence of operations K. The following K lines must each describe one operation. If there are several sequences of minimal length, output any one of them. If the desired result can’t be achieved, the first and only line of the file must contain the word ‘impossible’.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>3 5 4</p>
</li>
<li><p>Output<br>6<br>FILL(2)<br>POUR(2,1)<br>DROP(1)<br>POUR(2,1)<br>FILL(2)<br>POUR(2,1)</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：有两个杯子，每次可以对他们进行3种操作:<br>FILL(i):装满i;<br>DROP(i):倒掉i中的水;<br>POUR(i,j):从i往j倒水;<br>要使得某个杯子中有c升水，求最少操作次数以及对应步骤，输出任意路径</li>
<li>bfs，字符串映射<br>记录路径<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,time;</span><br><span class="line">    <span class="built_in">string</span> op;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> ops[<span class="number">7</span>]=&#123;<span class="string">""</span>,<span class="string">"FILL(1)"</span>,<span class="string">"FILL(2)"</span>,<span class="string">"POUR(1,2)"</span>,<span class="string">"POUR(2,1)"</span>,<span class="string">"DROP(1)"</span>,<span class="string">"DROP(2)"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a,b,c,vis[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">"0"</span>&#125;);</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node q=que.front();que.pop();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;q.x&lt;&lt;" "&lt;&lt;q.y&lt;&lt;" "&lt;&lt;q.op&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(q.x==c||q.y==c)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;q.time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q.op.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.op[i]!=<span class="string">'0'</span>)</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;ops[q.op[i]-<span class="string">'0'</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.x!=a &amp;&amp; !vis[a][q.y]) &#123;</span><br><span class="line">            vis[a][q.y]=<span class="number">1</span>;</span><br><span class="line">            que.push((node)&#123;a,q.y,q.time+<span class="number">1</span>,q.op+<span class="string">"1"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.y!=b &amp;&amp; !vis[q.x][b]) &#123;</span><br><span class="line">            vis[q.x][b]=<span class="number">1</span>;</span><br><span class="line">            que.push((node)&#123;q.x,b,q.time+<span class="number">1</span>,q.op+<span class="string">"2"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.x&gt;<span class="number">0</span> &amp;&amp; !vis[<span class="number">0</span>][q.y])&#123;</span><br><span class="line">            vis[<span class="number">0</span>][q.y]=<span class="number">1</span>;</span><br><span class="line">            que.push((node)&#123;<span class="number">0</span>,q.y,q.time+<span class="number">1</span>,q.op+<span class="string">"5"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.y&gt;<span class="number">0</span> &amp;&amp; !vis[q.x][<span class="number">0</span>])&#123;</span><br><span class="line">            vis[q.x][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            que.push((node)&#123;q.x,<span class="number">0</span>,q.time+<span class="number">1</span>,q.op+<span class="string">"6"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> can=min(q.x,b-q.y);</span><br><span class="line">        <span class="keyword">if</span>(can &amp;&amp; !vis[q.x-can][q.y+can])&#123;</span><br><span class="line">            vis[q.x-can][q.y+can]=<span class="number">1</span>;</span><br><span class="line">            que.push((node)&#123;q.x-can,q.y+can,q.time+<span class="number">1</span>,q.op+<span class="string">"3"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        can=min(q.y,a-q.x);</span><br><span class="line">        <span class="keyword">if</span>(can &amp;&amp; !vis[q.x+can][q.y-can])&#123;</span><br><span class="line">            vis[q.x+can][q.y-can]=<span class="number">1</span>;</span><br><span class="line">            que.push((node)&#123;q.x+can,q.y-can,q.time+<span class="number">1</span>,q.op+<span class="string">"4"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Fliptile</title>
    <url>/Fliptile/</url>
    <content><![CDATA[<h1 id="传送门POJ3279"><a href="#传送门POJ3279" class="headerlink" title="传送门POJ3279"></a>传送门<a href="http://poj.org/problem?id=3279" target="_blank" rel="noopener">POJ3279</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M × N grid (1 ≤ M ≤ 15; 1 ≤ N ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.</p>
</blockquote>
<p>As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.</p>
<p>Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>Line 1: Two space-separated integers: M and N<br>Lines 2..M+1: Line i+1 describes the colors (left to right) of row i of the grid with N space-separated integers which are 1 for black and 0 for white</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Lines 1..M: Each line contains N space-separated integers, each specifying how many times to flip that particular location.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>4 4<br>1 0 0 1<br>0 1 1 0<br>0 1 1 0<br>1 0 0 1</p>
</li>
<li><p>Output<br>0 0 0 0<br>1 0 0 1<br>1 0 0 1<br>0 0 0 0</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：翻牌子，每翻一次可以将选中的牌子自身以及上下左右取反，求最少多少次可以翻成全0.</li>
<li>对于第i行，我们可以找到i-1行中为1的位置[i-1][j]，然后通过翻[i][j]将其变为0，这样可以保证除了最后一行，前面全是0，最后只需要看最后一行是否为全0就可以判断是否可行。</li>
<li>枚举第一行，共2^N种，通过这些初始状态去处理后面的格子，如果可行，更新答案。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,mp[N][N],tem[N][N],ans[N][N],res[N][N],flag=<span class="number">0</span>,time,mintime=inf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            tem[i][j]=mp[i][j];</span><br><span class="line">    INIT(ans,<span class="number">0</span>);</span><br><span class="line">    time=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fan</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    tem[i][j]^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>) tem[i<span class="number">-1</span>][j]^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m) tem[i+<span class="number">1</span>][j]^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>) tem[i][j<span class="number">-1</span>]^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n) tem[i][j+<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ac</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(tem[m<span class="number">-1</span>][i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;mp[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sta=<span class="number">0</span>;sta&lt;(<span class="number">1</span>&lt;&lt;n);sta++)&#123;   <span class="comment">//状态</span></span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;          <span class="comment">//处理第一行</span></span><br><span class="line">            <span class="keyword">if</span>(sta &amp; (<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                ans[<span class="number">0</span>][n-j<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">                fan(<span class="number">0</span>,n-j<span class="number">-1</span>);</span><br><span class="line">                time++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tem[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                    ans[i][j]=<span class="number">1</span>;</span><br><span class="line">                    fan(i,j);</span><br><span class="line">                    time++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ac() &amp;&amp; time&lt;mintime)&#123;</span><br><span class="line">            mintime=time;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                    res[i][j]=ans[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mintime==inf) <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMPOSSIBLE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;res[i][j]&lt;&lt;<span class="string">" \n"</span>[j==n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Independent Task Scheduling</title>
    <url>/Independent-Task-Scheduling/</url>
    <content><![CDATA[<h1 id="传送门SwustOj698"><a href="#传送门SwustOj698" class="headerlink" title="传送门SwustOj698"></a>传送门<a href="http://acm.swust.edu.cn/#/problem/698/433" target="_blank" rel="noopener">SwustOj698</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>用2 台处理机A 和B 处理n 个作业。设第i 个作业交给机器A 处理时需要时间ai ，若由机器B 来处理，则需要时间bi 。由于各作业的特点和机器的性能关系，很可能对于某些i，有ai &gt;=bi，而对于某些j,j≠i，有aj &lt; bj 。既不能将一个作业分开由2 台机器处理，也没有一台机器能同时处理2 个作业。设计一个动态规划算法，使得这2 台机器处理完这n个作业的时间最短(从任何一台机器开工到最后一台机器停工的总时间)。<br>研究一个实例：<br>(a1,a2,a3,a4,a5,a6)＝(2,5,7,10,5,2)；<br>(b1,b2,b3,b4,b5,b6)＝(3,8,4,11,3,4)。<br>对于给定的2 台处理机A 和B处理n 个作业，找出一个最优调度方案，使2台机器处理完这n 个作业的时间最短。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>的第1行是1个正整数n&lt;=200, 表示要处理n个作业。 接下来的2行中，每行有n 个正整数，分别表示处理机A 和B 处理第i 个作业需要的处理时间。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>最短处理时间</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>6<br>2 5 7 10 5 2<br>3 8 4 11 3 4</li>
</ul>
</blockquote>
<ul>
<li>Output<br>15</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>dp[j]表示a的工作时长不超过j时b的最短工作时长</li>
<li>对于工作i<ul>
<li>a做时: dp[j]=dp[j-a[i]]</li>
<li>b做时：dp[j]=dp[j]+b[i]</li>
</ul>
</li>
<li>最后遍历一下找到最小的max(j,dp[j])</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//dp[i] a的工作时长不超过i时b的工作时长</span></span><br><span class="line">    <span class="keyword">int</span> a[maxn],b[maxn],dp[<span class="number">100007</span>];</span><br><span class="line">    <span class="keyword">int</span> n,suma=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        suma+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=suma;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=a[i])&#123;</span><br><span class="line">                dp[j]=min(dp[j]+b[i],dp[j-a[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j]+=b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf,tem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=suma;i++)&#123;</span><br><span class="line">        tem=max(i,dp[i]);</span><br><span class="line">        ans=min(ans,tem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Edit Distance</title>
    <url>/Edit-Distance/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>设A 和B 是2 个字符串。要用最少的字符操作将字符串A 转换为字符串B。这里所说的字符操作包括<br>(1)删除一个字符；<br>(2)插入一个字符；<br>(3)将一个字符改为另一个字符。<br>将字符串A变换为字符串B 所用的最少字符操作数称为字符串A到B 的编辑距离，记为d(A,B)。<br>试设计一个有效算法，对任给的2 个字符串A和B，计算出它们的编辑距离d(A,B)。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>第一行是字符串A，文件的第二行是字符串B。字符串长度不大于2000。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出距离d(A,B)</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>fxpimu<br>xwr</li>
</ul>
</blockquote>
<ul>
<li>Output<br>5</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>dp[i][j]表示a的前i个字符到b的前j个字符的最优编辑距离</li>
<li>从a到b<ul>
<li>删一个字符：dp[i][j]=dp[i-1][j]+1</li>
<li>插入一个： dp[i][j]=dp[i][j-1]+1</li>
<li>替换： dp[i][j]=dp[i-1][j-1]+1</li>
<li>a[i]==b[j]: dp[i][j]=dp[i-1][j-1]<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[maxn],b[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a,b);</span><br><span class="line">    <span class="keyword">int</span> lena=<span class="built_in">strlen</span>(a),lenb=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenb;j++) dp[<span class="number">0</span>][j]=j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=min(dp[i][j<span class="number">-1</span>],min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[lena][lenb]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Jack Straws —— 判断直线相交</title>
    <url>/Jack-Straws/</url>
    <content><![CDATA[<h1 id="传送门Poj1127"><a href="#传送门Poj1127" class="headerlink" title="传送门Poj1127"></a>传送门<a href="http://poj.org/problem?id=1127" target="_blank" rel="noopener">Poj1127</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>In the game of Jack Straws, a number of plastic or wooden “straws” are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>A problem consists of multiple lines of input. The first line will be an integer n (1 &lt; n &lt; 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers, x1 , y1 , x2 and y2 , giving the coordinates, (x1 ; y1 ); (x2 ; y2 ) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of input (except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the input is terminated. There will be no illegal input and there are no zero-length straws.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply “CONNECTED”, if straw a is connected to straw b, or “NOT CONNECTED”, if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>7<br>1 6 3 3<br>4 6 4 9<br>4 5 6 7<br>1 4 3 5<br>3 5 5 5<br>5 2 6 3<br>5 4 7 2<br>1 4<br>1 6<br>3 3<br>6 7<br>2 3<br>1 3<br>0 0<br>2<br>0 2 0 0<br>0 0 0 1<br>1 1<br>2 2<br>1 2<br>0 0</li>
</ul>
</blockquote>
<p>0</p>
<ul>
<li>Output<br>CONNECTED<br>NOT CONNECTED<br>CONNECTED<br>CONNECTED<br>NOT CONNECTED<br>CONNECTED<br>CONNECTED<br>CONNECTED<br>CONNECTED</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给出n条线段的起点和终点，线段相交具有传递性，询问某两条线间是否连通</li>
<li>快速排斥实验+跨立实验判定两线段相交，Floyd预处理联通性，O（1）查询</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(Edge l1, Edge l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//快速排斥实验</span></span><br><span class="line">    <span class="keyword">if</span> ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span><br><span class="line">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span><br><span class="line">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span><br><span class="line">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跨立实验</span></span><br><span class="line">    <span class="keyword">if</span> ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span><br><span class="line">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; <span class="number">0</span> ||</span><br><span class="line">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span><br><span class="line">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> con[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b,c,d;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        INIT(con,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">            edge[i]=(Edge)&#123;a,b,c,d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(judge(edge[i],edge[j]))</span><br><span class="line">                    con[i][j]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(con[i][k] &amp;&amp; con[k][j])</span><br><span class="line">                        con[i][j]=con[j][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)&amp;&amp;(a||b))&#123;</span><br><span class="line">            <span class="keyword">if</span>(con[a][b]||con[b][a]) <span class="built_in">printf</span>(<span class="string">"CONNECTED\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NOT CONNECTED\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>叉积</tag>
      </tags>
  </entry>
  <entry>
    <title>Roadblocks——次短路</title>
    <url>/Roadblocks%E2%80%94%E2%80%94%E6%AC%A1%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="传送门POJ3255"><a href="#传送门POJ3255" class="headerlink" title="传送门POJ3255"></a>传送门<a href="http://poj.org/problem?id=3255" target="_blank" rel="noopener">POJ3255</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Bessie has moved to a small farm and sometimes enjoys returning to visit one of her best friends. She does not want to get to her old home too quickly, because she likes the scenery along the way. She has decided to take the second-shortest rather than the shortest path. She knows there must be some second-shortest path.</p>
<p>The countryside consists of R (1 ≤ R ≤ 100,000) bidirectional roads, each linking two of the N (1 ≤ N ≤ 5000) intersections, conveniently numbered 1..N. Bessie starts at intersection 1, and her friend (the destination) is at intersection N.</p>
<p>The second-shortest path may share roads with any of the shortest paths, and it may backtrack i.e., use the same road or intersection more than once. The second-shortest path is the shortest path whose length is longer than the shortest path(s) (i.e., if two or more shortest paths exist, the second-shortest path is the one whose length is longer than those but no longer than any other path).<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>Line 1: Two space-separated integers: N and R<br>Lines 2..R+1: Each line contains three space-separated integers: A, B, and D that describe a road that connects intersections A and B and has length D (1 ≤ D ≤ 5000)</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Line 1: The length of the second shortest path between node 1 and node N</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>4 4<br>1 2 100<br>2 4 200<br>2 3 250<br>3 4 100</li>
</ul>
</blockquote>
<ul>
<li>Output<br>450</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：输入n,m;1—n的点，m条边，找出次短路</li>
<li>用dis[i][0]表示1到i的最短距离，dis[i][1]表示1到i的次短距离</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><blockquote>
<ul>
<li><p>Dijkstra:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> R=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,val,next;</span><br><span class="line">&#125;edge[R&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;e)<span class="keyword">const</span>&#123;<span class="keyword">return</span> w&gt;e.w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Begin[N],tot=<span class="number">0</span>,vis[N];LL dis[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[tot]=(Edge)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i][<span class="number">0</span>]=dis[i][<span class="number">1</span>]=inf;</span><br><span class="line">    dis[t][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    que.push((Node)&#123;t,dis[t][<span class="number">0</span>]&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        Node now=que.top();que.pop();</span><br><span class="line">        <span class="keyword">int</span> x=now.v;</span><br><span class="line">        <span class="keyword">if</span>(dis[x][<span class="number">1</span>]&lt;now.w)<span class="keyword">continue</span>;        <span class="comment">//之前被更新过，不是最新值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[x];~i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ne=edge[i].to; </span><br><span class="line">            <span class="keyword">int</span> d=now.w+edge[i].val;        <span class="comment">//now.w不一定是到i的最短路</span></span><br><span class="line">            <span class="keyword">if</span>(d&lt;dis[ne][<span class="number">0</span>])&#123;</span><br><span class="line">                dis[ne][<span class="number">1</span>]=dis[ne][<span class="number">0</span>];</span><br><span class="line">                dis[ne][<span class="number">0</span>]=d;</span><br><span class="line">                que.push((Node)&#123;ne,dis[ne][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;dis[ne][<span class="number">0</span>]&amp;&amp;d&lt;dis[ne][<span class="number">1</span>])&#123;</span><br><span class="line">                dis[ne][<span class="number">1</span>]=d;</span><br><span class="line">                que.push((Node)&#123;ne,dis[ne][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    INIT(Begin,<span class="number">-1</span>);INIT(vis,<span class="number">0</span>);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        add(x,y,w);</span><br><span class="line">        add(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[n][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SPFA:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> R=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,val,next;</span><br><span class="line">&#125;edge[R&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Begin[N],tot=<span class="number">0</span>;LL dis[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[tot]=(Edge)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i][<span class="number">0</span>]=dis[i][<span class="number">1</span>]=inf;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; road;</span><br><span class="line">    road.push((Node)&#123;t,<span class="number">0</span>&#125;);</span><br><span class="line">    dis[t][<span class="number">0</span>]=<span class="number">0</span>;;</span><br><span class="line">    <span class="keyword">while</span>(!road.empty())&#123;</span><br><span class="line">        Node top=road.front();road.pop();</span><br><span class="line">        <span class="keyword">int</span> now=top.v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];~i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ne=edge[i].to;</span><br><span class="line">            LL d=top.w+edge[i].val;</span><br><span class="line">            <span class="keyword">if</span>(dis[ne][<span class="number">0</span>]&gt;d)&#123;</span><br><span class="line">                dis[ne][<span class="number">1</span>]=dis[ne][<span class="number">0</span>];</span><br><span class="line">                dis[ne][<span class="number">0</span>]=d;</span><br><span class="line">                road.push((Node)&#123;ne,dis[ne][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dis[ne][<span class="number">0</span>]&lt;d &amp;&amp; d&lt;dis[ne][<span class="number">1</span>])&#123;</span><br><span class="line">                dis[ne][<span class="number">1</span>]=d;</span><br><span class="line">                road.push((Node)&#123;ne,dis[ne][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    INIT(Begin,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        add(x,y,w);</span><br><span class="line">        add(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[n][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>k短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Summer Holiday——Tarjan缩点</title>
    <url>/Summer-Holiday%E2%80%94%E2%80%94Tarjan%E7%BC%A9%E7%82%B9/</url>
    <content><![CDATA[<h1 id="传送门HDU1827"><a href="#传送门HDU1827" class="headerlink" title="传送门HDU1827"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1827" target="_blank" rel="noopener">HDU1827</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>To see a World in a Grain of Sand<br>And a Heaven in a Wild Flower,<br>Hold Infinity in the palm of your hand<br>And Eternity in an hour.<br>                  —— William Blake<br>听说lcy帮大家预定了新马泰7日游，Wiskey真是高兴的夜不能寐啊，他想着得快点把这消息告诉大家，虽然他手上有所有人的联系方式，但是一个一个联系过去实在太耗时间和电话费了。他知道其他人也有一些别人的联系方式，这样他可以通知其他人，再让其他人帮忙通知一下别人。你能帮Wiskey计算出至少要通知多少人，至少得花多少电话费就能让所有人都被通知到吗？</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>多组测试数组，以EOF结束。<br>第一行两个整数N和M（1&lt;=N&lt;=1000, 1&lt;=M&lt;=2000），表示人数和联系对数。<br>接下一行有N个整数，表示Wiskey联系第i个人的电话费用。<br>接着有M行，每行有两个整数X，Y，表示X能联系到Y，但是不表示Y也能联系X。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出最小联系人数和最小花费。<br>每个CASE输出答案一行。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>12 16<br>2 2 2 2 2 2 2 2 2 2 2 2<br>1 3<br>3 2<br>2 1<br>3 4<br>2 4<br>3 5<br>5 4<br>4 6<br>6 4<br>7 4<br>7 12<br>7 8<br>8 7<br>8 9<br>10 9<br>11 10</li>
</ul>
</blockquote>
<ul>
<li>Output<br>3 6</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>通过Tarjan缩点后找出每个点的入度，入度为0的点需要Wiskey通知</li>
<li>缩点的时候，强联通分量中的最小权值为此点的权值</li>
<li>在存图时同时保存当前边的起点和终点，以便寻找入度。</li>
<li>遍历所有的边，如果边i的起点和终点不属于同一强联通分量，则它们所属的两个强联通分量之间有一条边。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> from,to,next;&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],dfn[maxn],low[maxn],vis[maxn],sta[maxn],color[maxn];</span><br><span class="line"><span class="keyword">int</span> val[maxn],minV[maxn],inde[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,dfsNum,colNum,tot,top,ansV,ansN;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    INIT(Begin,<span class="number">-1</span>);INIT(dfn,<span class="number">0</span>);</span><br><span class="line">    INIT(low,<span class="number">0</span>);INIT(vis,<span class="number">0</span>);</span><br><span class="line">    INIT(color,<span class="number">0</span>);INIT(minV,inf);</span><br><span class="line">    INIT(inde,<span class="number">0</span>);</span><br><span class="line">    colNum=<span class="number">0</span>,dfsNum=<span class="number">0</span>,tot=<span class="number">0</span>,top=<span class="number">-1</span>,ansV=<span class="number">0</span>,ansN=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[tot]=(Edge)&#123;x,y,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfsNum;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[x];~i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> ne=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ne])&#123;</span><br><span class="line">            Tarjan(ne);</span><br><span class="line">            low[x]=min(low[x],low[ne]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[ne]) low[x]=min(low[x],dfn[ne]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        color[x]=++colNum;</span><br><span class="line">        minV[colNum]=min(minV[colNum],val[x]);</span><br><span class="line">        <span class="keyword">while</span>(sta[top]!=x)&#123;</span><br><span class="line">            vis[sta[top]]=<span class="number">0</span>;</span><br><span class="line">            minV[colNum]=min(minV[colNum],val[sta[top]]);<span class="comment">//找最小点权</span></span><br><span class="line">            color[sta[top--]]=colNum;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            add(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[edge[i].from]!=color[edge[i].to])&#123;</span><br><span class="line">                inde[color[edge[i].to]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=colNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inde[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                ansN++;</span><br><span class="line">                ansV+=minV[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ansN,ansV);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫城堡——Tarjan</title>
    <url>/%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1%E2%80%94%E2%80%94Tarjan/</url>
    <content><![CDATA[<h1 id="传送门HDU1269"><a href="#传送门HDU1269" class="headerlink" title="传送门HDU1269"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1269" target="_blank" rel="noopener">HDU1269</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3 3<br>1 2<br>2 3<br>3 1<br>3 3<br>1 2<br>2 3<br>3 2<br>0 0</li>
</ul>
</blockquote>
<ul>
<li>Output<br>Yes<br>No</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>判断所给有向图是否强联通</li>
<li>Tarjan可以找出所有强联通分量并进行分类。</li>
</ul>
<ul>
<li>此算法通过dfs实现：<ul>
<li>用dfn[i]来表示i节点第一次被搜索到的时间戳</li>
<li>用low[i]表示i点和i的子孙节点能追溯到的dfn的最小值</li>
<li>用栈sta来存放当前 <strong>可能</strong> 构成强联通分量的点</li>
<li>用vis[i]来记录点i当前是否在栈sta中</li>
</ul>
</li>
<li>通过链式前向星遍历节点<ul>
<li>初始化dfn[i]=low[i]=被dfs到的次序</li>
<li>将点i存入sta中，vis[i]=true<ul>
<li>如果i在sta中，且后面遍历到的某点j能够到达i的话，那么i~j属于同一个联通分量</li>
</ul>
</li>
<li>遍历i能到的每一个点j，如果dfn[j]=0，即未被访问过，则对j进行dfs，然后low[i]=min(low[i],low[j])</li>
<li>如果j能到达的下一个点i已经在sta中，则说明i~j属于同一个联通分量，那么low[j]=min(low[j],dfn[i]),在回溯的过程中，low[i~j]都会变成min(low[j])，这样就能找到强联通分量的根</li>
<li>如果dfn[i]==low[i]，则说明i和他的子孙节点可构成一个联通分量，其子孙节点存放于sta中，将这些节点弹出并进行染色标记</li>
</ul>
</li>
<li>最后，同一个染色标记的所有节点为同一个强联通分量，可将他们看作一个点，即缩点操作，这些强联通分量间构成一个有向无环图。</li>
<li>时间复杂度O(n+m)<br><img src="../image/tarjan.jpg" alt=""></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,next;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],dfn[maxn],low[maxn],vis[maxn],sta[maxn],color[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,top,dfsNum,colNum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    INIT(Begin,<span class="number">-1</span>);INIT(vis,<span class="number">0</span>);</span><br><span class="line">    INIT(low,<span class="number">0</span>);INIT(dfn,<span class="number">0</span>);</span><br><span class="line">    INIT(color,<span class="number">0</span>);</span><br><span class="line">    top=<span class="number">-1</span>,tot=<span class="number">0</span>,dfsNum=<span class="number">0</span>,colNum=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[tot]=(Edge)&#123;x,y,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfsNum; <span class="comment">//标记时间戳</span></span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    sta[++top]=x; <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[x];~i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> ne=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ne])&#123;</span><br><span class="line">            Tarjan(ne);</span><br><span class="line">            low[x]=min(low[x],low[ne]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[ne]) low[x]=min(low[x],dfn[ne]); <span class="comment">//找到环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        color[x]=++colNum;</span><br><span class="line">        <span class="comment">//出栈并染色</span></span><br><span class="line">        <span class="keyword">while</span>(sta[top]!=x)&#123;</span><br><span class="line">            vis[sta[top]]=<span class="number">0</span>;</span><br><span class="line">            color[sta[top--]]=colNum;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;<span class="comment">//弹出x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;(n||m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            add(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">        <span class="keyword">if</span>(colNum==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>归并求逆序数</title>
    <url>/%E5%BD%92%E5%B9%B6%E6%B1%82%E9%80%86%E5%BA%8F%E6%95%B0/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>在归并排序的同时求逆序数</li>
<li>区间[l,r]中，mid=(l+r)/2，i从l到mid,j从mid+1到r，当a[i]&gt;a[j]的时候，a[i~mid]一定都大于a[j]，因为单独看左右区间是已经排好序的，sum+=mid-i+1即可<a id="more"></a>
</li>
</ul>
</blockquote>
<p><img src="../image/merge.jpg" alt=""></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOCKS_PER_SEC ((clock_t)1000)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_CHAR=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>, a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    MergeSort(l,mid);</span><br><span class="line">    MergeSort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l; k&lt;=r; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;r || (i&lt;=mid &amp;&amp; a[i]&lt;=a[j])) b[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> b[k] = a[j++], ans += mid-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l; k&lt;=r; k++) a[k] = b[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    MergeSort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title>确定比赛名次——拓扑排序</title>
    <url>/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1%E2%80%94%E2%80%94%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="传送门HDU1285"><a href="#传送门HDU1285" class="headerlink" title="传送门HDU1285"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank" rel="noopener">HDU1285</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。<br>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>4 3<br>1 2<br>2 3<br>4 3</li>
<li>Output<br>1 2 4 3</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>在一个有向无环图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。</li>
<li>先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。</li>
<li>一直做改操作，直到所有的节点都被分离出来。</li>
<li>如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。</li>
<li>按字典序输出的时候用优先队列处理即可</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">priority_queue&lt; <span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt; <span class="keyword">int</span>&gt; &gt;cnt;</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],tot=<span class="number">0</span>,in[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[tot]=(Edge)&#123;y,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>)</span><br><span class="line">            cnt.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">    <span class="keyword">while</span>(!cnt.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=cnt.top();cnt.pop();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];~i;i=edge[i].next)&#123;</span><br><span class="line">            in[edge[i].to]--;</span><br><span class="line">            <span class="keyword">if</span>(in[edge[i].to]==<span class="number">0</span>)</span><br><span class="line">                cnt.push(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans[i],<span class="string">" \n"</span>[i==ans.size()<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x,y;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        INIT(Begin,<span class="number">-1</span>);</span><br><span class="line">        INIT(in,<span class="number">0</span>);</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            in[y]++;</span><br><span class="line">            add(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        topo(n);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最小圆覆盖</title>
    <url>/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h1 id="传送门HDU3007"><a href="#传送门HDU3007" class="headerlink" title="传送门HDU3007"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3007" target="_blank" rel="noopener">HDU3007</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Each person had do something foolish along with his or her growth.But,when he or she did this that time,they could not predict that this thing is a mistake and they will want this thing would rather not happened.<br>The world king Sconbin is not the exception.One day,Sconbin was sleeping,then swakened by one nightmare.It turned out that his love letters to Dufein were made public in his dream.These foolish letters might ruin his throne.Sconbin decided to destroy the letters by the military exercises’s opportunity.The missile is the best weapon.Considered the execution of the missile,Sconbin chose to use one missile with the minimum destruction.<br>Sconbin had writen N letters to Dufein, she buried these letters on different places.Sconbin got the places by difficult,he wants to know where is the best place launch the missile,and the smallest radius of the burst area. Let’s help Sconbin to get the award.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are many test cases.Each case consists of a positive integer N(N&lt;500,^V^,our great king might be a considerate lover) on a line followed by N lines giving the coordinates of N letters.Each coordinates have two numbers,x coordinate and y coordinate.N=0 is the end of the input file.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each case,there should be a single line in the output,containing three numbers,the first and second are x and y coordinates of the missile to launch,the third is the smallest radius the missile need to destroy all N letters.All output numbers are rounded to the second digit after the decimal point.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3<br>1.00 1.00<br>2.00 2.00<br>3.00 3.00<br>0</li>
<li>Output<br>2.00 2.00 1.41</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：狗血剧情懒得讲，裸最小覆盖圆；多组输入n，n=0停止，下面n行为每个点的坐标。</li>
<li>随机增量法是一个可以在 期望 O(n)时间内求出最小圆覆盖的算法，首先它的算法流程是这样的<ul>
<li>枚举第一个点 i，若不在目前圆内，设它为圆心</li>
<li>枚举第二个点 j，若不在当前圆内，设当前圆为以 i,j 为直径的圆</li>
<li>枚举第三个点 k，若不在当前圆内，设当前圆为 i,j,k 的外接圆</li>
</ul>
</li>
<li>正确性:显然最优解一定是两个点为直径的圆或者一个三角形的外接圆，否则肯定能缩的更小。那么这么枚举的正确性是比较显然的了。</li>
<li>时间复杂度:<br>这是一个重点，这么做看似是O(n^3) 的，不过对于随机顺序的点，是可以期望O(n) 的。下面考虑证明：<br>显然，最后一层循环枚举从 1~j，只要进入循环就一定要跑完，所以是O(j) 的<br>考虑倒数第二层循环，什么情况下会进入第三层循环呢？仅当 j 不在前 j-1 个点形成的圆中，考虑 j 个点形成的圆是由三个点确定的，那么第 j 个 (最后一个点) 若是三个点之一，则需要扩大圆，否则不需要进入第三层循环，这个概率是3/j 的，所以第二层的复杂度是O(i) 的同理，第一层的复杂度就是O(n)的了<br>当然，这是基于随机数据的期望复杂度，所以我们一般需要手动打乱排列</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125; p[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Point <span class="title">circumcenter</span><span class="params">(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b,<span class="keyword">const</span> Point &amp;c)</span> </span>&#123; <span class="comment">//返回三角形的外心</span></span><br><span class="line">    Point ret;</span><br><span class="line">    <span class="keyword">double</span> a1=b.x-a.x,b1=b.y-a.y,c1=(a1*a1+b1*b1)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> a2=c.x-a.x,b2=c.y-a.y,c2=(a2*a2+b2*b2)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d=a1*b2-a2*b1;</span><br><span class="line">    ret.x=a.x+(c1*b2-c2*b1)/d;</span><br><span class="line">    ret.y=a.y+(a1*c2-a2*c1)/d;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCC</span><span class="params">(Point *p,<span class="keyword">int</span> n,Point &amp;c,<span class="keyword">double</span> &amp;r)</span> </span>&#123; <span class="comment">//c为圆心，r为半径</span></span><br><span class="line">    random_shuffle(p,p+n);</span><br><span class="line">    c=p[<span class="number">0</span>];</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis(p[i],c)&gt;r+eps) &#123; <span class="comment">//第一个点</span></span><br><span class="line">            c=p[i];r=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">                <span class="keyword">if</span>(dis(p[j],c)&gt;r+eps) &#123; <span class="comment">//第二个点</span></span><br><span class="line">                    c.x=(p[i].x+p[j].x)/<span class="number">2</span>;</span><br><span class="line">                    c.y=(p[i].y+p[j].y)/<span class="number">2</span>;</span><br><span class="line">                    r=dis(p[j],c);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;j; k++)</span><br><span class="line">                        <span class="keyword">if</span>(dis(p[k],c)&gt;r+eps) &#123; <span class="comment">//第三个点</span></span><br><span class="line">                            <span class="comment">//求外接圆圆心，三点必不共线</span></span><br><span class="line">                            c=circumcenter(p[i],p[j],p[k]);</span><br><span class="line">                            r=dis(p[i],c);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Point c;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">        random_shuffle(p,p+n);</span><br><span class="line">        MCC(p,n,c,r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf %.2lf %.2lf\n"</span>,c.x,c.y,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>最小圆覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>最近点对</title>
    <url>/%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="传送门最近对问题"><a href="#传送门最近对问题" class="headerlink" title="传送门最近对问题"></a>传送门<a href="http://acm.swust.edu.cn/?dnrgdeihvxldxlwj#/problems/794/416?_k=12a4sg" target="_blank" rel="noopener">最近对问题</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>设p1=(x1, y1), p2=(x2, y2), …, pn=(xn, yn)是平面上n个点构成的集合S，设计算法找出集合S中距离最近的点对。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>多组测试数据，第一行为测试数据组数n（0&lt;n≤100），每组测试数据由两个部分构成，第一部分为一个点的个数m（0&lt;m≤1000），紧接着是m行，每行为一个点的坐标x和y，用空格隔开，（0&lt;x，y≤100000）</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>每组测试数据输出一行，为该组数据最近点的距离，保留4为小数。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2<br>2<br>0 0<br>0 1<br>3<br>0 0<br>1 1<br>1 0</li>
<li>Output<br>1.0000<br>1.0000</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>按x排序，二分区间，找到左右子区间的最小距离d=min(d1,d2)，再在中间[mid-d,mid+d]找是否有更小的<br><img src="../image/最近点对.jpg" alt=""></li>
<li>由鸽巢定理，对于[mid-d,mid]中的某点i，在[mid,mid+d]中最多找6个点就能确定结果</li>
<li>时间复杂度O(nlgnlgn)，中间区域按y排序O(nlgn)，这一步可以通过归并思想优化到n，总时间复杂度优化至O(nlgn)。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line">Node tem[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpX</span><span class="params">(Node a,Node b)</span></span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpY</span><span class="params">(Node a,Node b)</span></span>&#123;<span class="keyword">return</span> a.y&lt;b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dis</span><span class="params">(Node a,Node b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MinDis</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">2</span>) <span class="keyword">return</span> Dis(node[l],node[r]);</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">3</span>) <span class="keyword">return</span> min(Dis(node[l],node[l+<span class="number">1</span>]),Dis(node[l+<span class="number">1</span>],node[r]));</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> d=min(MinDis(l,mid),MinDis(mid+<span class="number">1</span>,r));</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(node[i].x-node[mid].x&lt;=d))</span><br><span class="line">            tem[tot++]=node[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tem,tem+tot,cmpY);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;i+<span class="number">6</span> &amp;&amp; j&lt;tot;j++)&#123;</span><br><span class="line">            d=min(d,Dis(tem[i],tem[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("0.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">            sort(node+<span class="number">1</span>,node+<span class="number">1</span>+n,cmpX);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,MinDis(<span class="number">1</span>,n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>最近点对</tag>
      </tags>
  </entry>
  <entry>
    <title>凸包</title>
    <url>/%E5%87%B8%E5%8C%85%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>取最左边的点x为第一个点，其他所有点根据与点x连线的斜率排序，然后依次扫过去。</li>
<li>如下图所示，线段ab相对于xa按逆时针旋转，所以a在当前确定的凸包集合中；</li>
<li>线段bc相对于ab按顺时针方向旋转，所以b不在当前确定的凸包集合中；</li>
<li>判断两<strong>向量</strong>的相对旋转方向可以用叉积来计算。<strong>a</strong> x <strong>b</strong> &gt; 0 时b相对a逆时针旋转， <strong>a</strong> x <strong>b</strong> &lt; 0 时b相对a顺时针旋转<br><img src="../image/凸包.jpg" alt=""></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>,pi=<span class="number">3.14159265</span>;</span><br><span class="line"><span class="comment">// 若 一点的坐标在前面两点的右边，则更新右端点</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  <span class="comment">// 三态函数 ，在下面用于是否在精度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x,y;</span><br><span class="line">	inline Point(double x=0,double y=0):x(x),y(y)&#123;&#125;</span><br><span class="line">&#125;p[N],ch[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.x!=B.x)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> A.y&lt;B.y;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> + (Point A,Point B)&#123;</span><br><span class="line">	<span class="keyword">return</span> Point(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> - (Point A,Point B)&#123;</span><br><span class="line">	<span class="keyword">return</span> Point(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; A,<span class="keyword">const</span> Point&amp; B)&#123;</span><br><span class="line">	<span class="keyword">return</span> dcmp(A.x-B.x)==<span class="number">0</span>&amp;&amp;dcmp(A.y-B.y)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Point A,Point B)</span>  <span class="comment">// 计算叉积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x * B.y - A.y * B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConvexHull</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sort(p,p+n,myCmp);</span><br><span class="line">	<span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="comment">// 求下曲包，当该点在前进方向的右边时（使用叉积判断），删除前进的右端点，</span></span><br><span class="line">	<span class="comment">// 循环，直到不在，并将该点加入，不在右边，则直接加入</span></span><br><span class="line">		<span class="keyword">while</span>(m&gt;<span class="number">1</span>&amp;&amp;dcmp(Cross(ch[m<span class="number">-1</span>]-ch[m<span class="number">-2</span>],p[i]-ch[m<span class="number">-2</span>]))&lt;=<span class="number">0</span>)m--;</span><br><span class="line">		ch[m++]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k=m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">// 因 pn-1 已经遍历过，故从n-2开始</span></span><br><span class="line">		<span class="comment">// 求上凸包，最终形成合围，为完整凸包</span></span><br><span class="line">		<span class="keyword">while</span>(m&gt;k&amp;&amp;dcmp(Cross(ch[m<span class="number">-1</span>]-ch[m<span class="number">-2</span>],p[i]-ch[m<span class="number">-2</span>]))&lt;=<span class="number">0</span>)m--;</span><br><span class="line">		ch[m++]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)m--;  <span class="comment">// 因要形成凸包，故起始点重复，减1</span></span><br><span class="line">	<span class="keyword">return</span> m;  <span class="comment">//返回顶点个数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dis</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		p[i]=Point(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	m=ConvexHull();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算凸包周长</span></span><br><span class="line"><span class="comment">/*	double ans=0.0;</span></span><br><span class="line"><span class="comment">	for(int i=0;i&lt;m-1;i++)</span></span><br><span class="line"><span class="comment">	  ans+=Dis(ch[i],ch[i+1]);</span></span><br><span class="line"><span class="comment">	ans+=Dis(ch[m-1],ch[0]);</span></span><br><span class="line"><span class="comment">	printf("%.1f\n",ans);*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算凸包面积</span></span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0.0</span>;</span><br><span class="line">	ch[m]=ch[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		ans+=(ch[i].x*ch[i+<span class="number">1</span>].y-ch[i+<span class="number">1</span>].x*ch[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	ans=ans/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.0f\n"</span>,<span class="built_in">floor</span>(ans/<span class="number">50</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">1 -1</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 -1</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 -2</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">5 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output 15.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列康托展开</title>
    <url>/%E5%85%A8%E6%8E%92%E5%88%97%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h1 id="传送门-排列的字典序问题"><a href="#传送门-排列的字典序问题" class="headerlink" title="传送门 排列的字典序问题"></a>传送门 <a href="http://acm.swust.edu.cn/#/problems/541/388?_k=g0tqt5" target="_blank" rel="noopener">排列的字典序问题</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>n个元素{1,2,…, n }有n!个不同的排列。将这n!个排列按字典序排列，并编号为0，1，…，n!-1。每个排列的编号为其字典序值。例如，当n=3时，6 个不同排列的字典序值如下：<br> 0    1   2   3   4   5<br>123  132 213 231 312 321<br>任务：给定n 以及n 个元素{1,2,…, n }的一个排列，计算出这个排列的字典序值，以及按字典序排列的下一个排列。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第1 行是元素个数n(n &lt; 15)。接下来的1 行是n个元素{1,2,…, n }的一个排列。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>第一行是字典序值，第2行是按字典序排列的下一个排列。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>8<br>2 6 4 5 8 1 7 3</li>
<li>output<br>8227<br>2 6 4 5 8 3 1 7</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>康托展开：设某个排列{x0,x1,x2…x(n-1)}的对应键值为k，则<code>k=a[0]*(n-1)!+a[1]*(n-2)!+...+a[n-1]*0!</code>,其中a[i]表示x[i]在i~n-1中的升序位置，同时也可以得知该排列在所有排列中是第k+1个。</li>
<li>康托逆展开：已知<strong>键值k</strong>求排列。通过上面的式子，我们令i从(n-1)到0，每次取<code>t=k/(i!)</code>，显然i后面所有式子加起来都没有i!大，故得到的t就表示这个位置应该填的数是在剩下还没有填的数的升序位置，然后用<code>k/=(i!)</code>去找下一位。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL jc[maxn];</span><br><span class="line"><span class="function">LL <span class="title">Cantor</span><span class="params">(LL *a,LL n)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])c++;</span><br><span class="line">        ans+=c*jc[n<span class="number">-1</span>-i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeCantor</span><span class="params">(LL num,LL n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt;cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cnt.push_back(i);</span><br><span class="line">    LL ans[maxn],tem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        tem=num/jc[i];</span><br><span class="line">        num%=jc[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>,cnt[tem]);</span><br><span class="line">        cnt.erase(cnt.begin()+tem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)jc[i]=jc[i<span class="number">-1</span>]*i;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        LL a[maxn];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        LL next=Cantor(a,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,next);</span><br><span class="line">        DeCantor((next+<span class="number">1</span>)%jc[n],n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图性质</title>
    <url>/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>最小点覆盖=最大匹配</li>
<li>最小边覆盖=v-最大匹配=最大独立集<a id="more"></a>
</li>
</ul>
</blockquote>
<h1 id="点覆盖、最小点覆盖"><a href="#点覆盖、最小点覆盖" class="headerlink" title="点覆盖、最小点覆盖"></a>点覆盖、最小点覆盖</h1><blockquote>
<ul>
<li>点覆盖集即一个点集，使得所有边至少有一个端点在集合里。或者说是“点” 覆盖了所有“边”。。极小点覆盖(minimal vertex covering)：本身为点覆盖，其真子集都不是。最小点覆盖(minimum vertex covering)：点最少的点覆盖。点覆盖数(vertex covering number)：最小点覆盖的点数。</li>
</ul>
</blockquote>
<h1 id="边覆盖、极小边覆盖"><a href="#边覆盖、极小边覆盖" class="headerlink" title="边覆盖、极小边覆盖"></a>边覆盖、极小边覆盖</h1><blockquote>
<ul>
<li>边覆盖集即一个边集，使得所有点都与集合里的边邻接。或者说是“边” 覆盖了所有“点”。极小边覆盖(minimal edge covering)：本身是边覆盖，其真子集都不是。最小边覆盖(minimum edge covering)：边最少的边覆盖。边覆盖数(edge covering number)：最小边覆盖的边数。</li>
</ul>
</blockquote>
<h1 id="独立集、极大独立集"><a href="#独立集、极大独立集" class="headerlink" title="独立集、极大独立集"></a>独立集、极大独立集</h1><blockquote>
<ul>
<li>独立集即一个点集，集合中任两个结点不相邻，则称V为独立集。或者说是导出的子图是零图（没有边）的点集。极大独立集(maximal independent set)：本身为独立集，再加入任何点都不是。最大独立集(maximum independent set)：点最多的独立集。独立数(independent number)：最大独立集的点。</li>
</ul>
</blockquote>
<h1 id="团"><a href="#团" class="headerlink" title="团"></a>团</h1><blockquote>
<ul>
<li>团即一个点集，集合中任两个结点相邻。或者说是导出的子图是完全图的点集。极大团(maximal clique)：本身为团，再加入任何点都不是。最大团(maximum clique)：点最多的团。团数(clique number)：最大团的点数。</li>
</ul>
</blockquote>
<h1 id="边独立集、极大边独立集"><a href="#边独立集、极大边独立集" class="headerlink" title="边独立集、极大边独立集"></a>边独立集、极大边独立集</h1><blockquote>
<ul>
<li>边独立集即一个边集，满足边集中的任两边不邻接。极大边独立集(maximal edge independent set)：本身为边独立集，再加入任何边都不是。最大边独立集(maximum edge independent set)：边最多的边独立集。边独立数(edge independent number)：最大边独立集的边数。<br>边独立集又称匹配(matching)，相应的有极大匹配(maximal matching)，最大匹配(maximum matching)，匹配数(matching number)。</li>
</ul>
</blockquote>
<h1 id="支配集、极小支配集"><a href="#支配集、极小支配集" class="headerlink" title="支配集、极小支配集"></a>支配集、极小支配集</h1><blockquote>
<ul>
<li>支配集即一个点集，使得所有其他点至少有一个相邻点在集合里。或者说是一部分的“点”支配了所有“点”。极小支配集(minimal dominating set)：本身为支配集，其真子集都不是。最小支配集(minimum dominating set)：点最少的支配集。支配数(dominating number)：最小支配集的点数。</li>
</ul>
</blockquote>
<h1 id="边支配集、极小边支配集"><a href="#边支配集、极小边支配集" class="headerlink" title="边支配集、极小边支配集"></a>边支配集、极小边支配集</h1><blockquote>
<ul>
<li>边支配集即一个边集，使得所有边至少有一条邻接边在集合里。或者说是一部分的“边”支配了所有“边”。极小边支配集(minimal edge dominating set)：本身是边支配集，其真子集都不是。最小边支配集(minimum edge dominating set)：边最少的边支配集。边支配数(edge dominating number)：最小边支配集的边数。</li>
</ul>
</blockquote>
<h1 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h1><blockquote>
<ul>
<li>最小路径覆盖(path covering)：是“路径” 覆盖“点”，即用尽量少的不相交简单路径覆盖有向无环图G的所有顶点，即每个顶点严格属于一条路径。路径的长度可能为0(单个点)。</li>
<li>最小路径覆盖数＝G的点数－最小路径覆盖中的边数。应该使得最小路径覆盖中的边数尽量多，但是又不能让两条边在同一个顶点相交。拆点：将每一个顶点i拆成两个顶点Xi和Yi。然后根据原图中边的信息，从X部往Y部引边。所有边的方向都是由X部到Y部。因此，所转化出的二分图的最大匹配数则是原图G中最小路径覆盖上的边数。因此由最小路径覆盖数＝原图G的顶点数－二分图的最大匹配数便可以得解。</li>
</ul>
</blockquote>
<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><blockquote>
<ul>
<li>匹配(matching)是一个边集，满足边集中的边两两不邻接。匹配又称边独立集(edge independent set)。</li>
<li>在匹配中的点称为匹配点(matched vertex)或饱和点；反之，称为未匹配点(unmatched vertex)或未饱和点。</li>
<li>交错轨(alternating path)是图的一条简单路径，满足任意相邻的两条边，一条在匹配内，一条不在匹配内。</li>
<li>增广轨(augmenting path)：是一个始点与终点都为未匹配点的交错轨。</li>
<li>最大匹配(maximum matching)是具有最多边的匹配。</li>
<li>匹配数(matching number)是最大匹配的大小。</li>
<li>完美匹配(perfect matching)是匹配了所有点的匹配。</li>
<li>完备匹配(complete matching)是匹配了二分图较小集合（二分图X，Y中小的那个）的所有点的匹配。</li>
<li>增广轨定理：一个匹配是最大匹配当且仅当没有增广轨。</li>
<li>所有匹配算法都是基于增广轨定理：一个匹配是最大匹配当且仅当没有增广轨。这个定理适用于任意图。</li>
</ul>
</blockquote>
<h1 id="二分图的性质"><a href="#二分图的性质" class="headerlink" title="二分图的性质"></a>二分图的性质</h1><blockquote>
<ul>
<li>二分图中，点覆盖数是匹配数。</li>
<li>二分图的最大匹配数等于最小覆盖数，即求最少的点使得每条边都至少和其中的一个点相关联，很显然直接取最大匹配的一段节点即可。</li>
<li>二分图的独立数等于顶点数减去最大匹配数，很显然的把最大匹配两端的点都从顶点集中去掉这个时候剩余的点是独立集，这是|V|-2*|M|，同时必然可以从每条匹配边的两端取一个点加入独立集并且保持其独立集性质。</li>
<li>DAG的最小路径覆盖，将每个点拆点后作最大匹配，结果为n-m，求具体路径的时候顺着匹配边走就可以，匹配边i→j’,j→k’,k→l’….构成一条有向路径。</li>
<li>最大匹配数=左边匹配点+右边未匹配点。因为在最大匹配集中的任意一条边，如果他的左边没标记，右边被标记了，那么我们就可找到一条新的增广路，所以每一条边都至少被一个点覆盖。</li>
<li>最小边覆盖=图中点的个数-最大匹配数=最大独立集。</li>
</ul>
</blockquote>
<h1 id="二分图的判定"><a href="#二分图的判定" class="headerlink" title="二分图的判定"></a>二分图的判定</h1><blockquote>
<ul>
<li>二分图是这样一个图： 有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！</li>
<li>无向图G为二分图的充分必要条件是，G至少有两个顶点,且其所有回路的长度均为偶数。</li>
<li>判断二分图的常见方法是染色法： 开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，bfs和dfs可以搞定！</li>
<li>易知：任何无回路的的图均是二分图。</li>
</ul>
</blockquote>
<h1 id="二分图的应用模型"><a href="#二分图的应用模型" class="headerlink" title="二分图的应用模型"></a>二分图的应用模型</h1><blockquote>
<ul>
<li>二分图的最大匹配：<ul>
<li><strong>0要素：左右每个集合中包含0条边</strong></li>
<li><strong>1要素：每个点只能被一个匹配覆盖</strong></li>
</ul>
</li>
<li>二分图的最小点覆盖：<ul>
<li>选出最少的点组成集合，使所有的边都至少有一个端点在集合中</li>
<li><strong>2要素：每条边有两个端点，至少选择一个端点</strong></li>
<li>最小点覆盖数等于最大匹配数</li>
</ul>
</li>
<li>二分图最大独立集：<ul>
<li>在任意两点之间都没有边相连的情况下选出最多的点</li>
<li>最大独立集=n-最大匹配</li>
</ul>
</li>
<li>二分图最大团：<ul>
<li>任意两点之间都有一条边相连的情况下选出最多的点</li>
<li><strong>二分图G的最大团等于其补图G’的最大独立集</strong>。</li>
<li>补图转化思想极为重要，在一些题中能称为解答的突破口</li>
</ul>
</li>
<li>DAG最小路径点覆盖：<ul>
<li>用最少的<strong>不相交</strong>的简单路径覆盖所有的点（即每个点只能被覆盖一次）</li>
<li>建一张新图，1~n节点作为二分图左部点，n+1~2n作为右部点，对原图每条边(x,y)，从x到y+n连一条边。</li>
<li>最小路径点覆盖=n-新图最大匹配数</li>
</ul>
</li>
<li>DAG最小路径可重复点覆盖：<ul>
<li>用最少的<strong>可相交</strong>的简单路径覆盖所有的点（即每个点可被覆盖多次）</li>
<li>也可用于解决：在DAG中，求出最多的点数，满足点之间两两不连通</li>
<li>先对DAG传递闭包，然后求最小路径点覆盖。</li>
</ul>
</li>
<li>二分图最大匹配的必经边和可行边：<ul>
<li>给二分图添加源点与左部所有节点相连，汇点与右部所有节点相连，每条无向边拆成两条有向边。</li>
<li>先用最大流找出任意一组最大匹配，此时：<ul>
<li><strong>必经边</strong>:(x,y)的流量为1，并且在残量网络上属于<strong>不同</strong>的强连通分量</li>
<li><strong>可行边</strong>：(x,y)的流量为1，或者在残量网络上属于<strong>不同</strong>的强连通分量<ul>
<li>dinic求最大流，tarjan求强连通分量，最后对边逐一进行判定，时间复杂度为O(E*sqrt(N+M))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>Ants(最小权值二分图匹配)</title>
    <url>/Ants-%E6%9C%80%E5%B0%8F%E6%9D%83%E5%80%BC%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="传送门poj3565"><a href="#传送门poj3565" class="headerlink" title="传送门poj3565"></a>传送门<a href="http://poj.org/problem?id=3565" target="_blank" rel="noopener">poj3565</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Young naturalist Bill studies ants in school. His ants feed on plant-louses that live on apple trees. Each ant colony needs its own apple tree to feed itself.<br>Bill has a map with coordinates of n ant colonies and n apple trees. He knows that ants travel from their colony to their feeding places and back using chemically tagged routes. The routes cannot intersect each other or ants will get confused and get to the wrong colony or tree, thus spurring a war between colonies.<br>Bill would like to connect each ant colony to a single apple tree so that all n routes are non-intersecting straight lines. In this problem such connection is always possible. Your task is to write a program that finds such connection.<br><img src="../image/ant.png" alt=""><br>On this picture ant colonies are denoted by empty circles and apple trees are denoted by filled circles. One possible connection is denoted by lines.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line of the input file contains a single integer number n (1 ≤ n ≤ 100) — the number of ant colonies and apple trees. It is followed by n lines describing n ant colonies, followed by n lines describing n apple trees. Each ant colony and apple tree is described by a pair of integer coordinates x and y (−10 000 ≤ x, y ≤ 10 000) on a Cartesian plane. All ant colonies and apple trees occupy distinct points on a plane. No three points are on the same line.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Write to the output file n lines with one integer number on each line. The number written on i-th line denotes the number (from 1 to n) of the apple tree that is connected to the i-th ant colony.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5<br>-42 58<br>44 86<br>7 28<br>99 34<br>-13 -59<br>-47 -44<br>86 74<br>68 -75<br>-68 60<br>99 -60</li>
</ul>
</blockquote>
<ul>
<li>Output<br>4<br>2<br>1<br>5<br>3</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：n个蚂蚁n颗树，一个蚂蚁连一个树，连线不能相交，求出每个蚂蚁所连的树</li>
<li><img src="../image/蚂蚁.jpg" alt=""><br>假设A、B为蚂蚁，C、D为苹果树。则存在两种匹配：第一种是AD、BC，第二种是AC、BD。<br>根据三角形不等式AD+BC &lt; AC+BD，最后得到很重要的一个性质——满足总路程之和最小<br>的方案一定不相交。现在来构建二分图，一边为蚂蚁，另一边为苹果树，以距离为边权值，题<br>目就变为了求带权二分图最小权和的最佳匹配。</li>
<li>这里要用数组优化</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组优化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">0xffffffffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">double</span> coor[maxn&lt;&lt;<span class="number">1</span>][<span class="number">2</span>],line[maxn][maxn];</span><br><span class="line"><span class="keyword">double</span> wx[maxn],wy[maxn],visx[maxn],visy[maxn];</span><br><span class="line"><span class="keyword">int</span> matchx[maxn],matchy[maxn];</span><br><span class="line"><span class="keyword">double</span> minsub,a,b,t;</span><br><span class="line"><span class="keyword">double</span> tem[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    visx[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visy[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">double</span> t=wx[x]+wy[i]-line[x][i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(t)&lt;=<span class="number">1e-6</span>)&#123;</span><br><span class="line">            visy[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!matchy[i]||Find(matchy[i]))&#123;</span><br><span class="line">                matchx[x]=i;</span><br><span class="line">                matchy[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> tem[i]=min(tem[i],t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Km</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            tem[j]=inf;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            minsub=inf;</span><br><span class="line">            INIT(visx,<span class="number">0</span>);INIT(visy,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(Find(i))<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(!visy[j]) minsub=min(tem[j],minsub);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visx[j]) wx[j]-=minsub;</span><br><span class="line">                <span class="keyword">if</span>(visy[j]) wy[j]+=minsub;</span><br><span class="line">                <span class="keyword">else</span> tem[j]-=minsub;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        INIT(line,<span class="number">0</span>);INIT(wy,<span class="number">0</span>);</span><br><span class="line">        INIT(matchx,<span class="number">0</span>);INIT(matchy,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;coor[i][<span class="number">0</span>],&amp;coor[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            wx[i]=-inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n+<span class="number">1</span>;j&lt;=<span class="number">2</span>*n;j++)&#123;</span><br><span class="line">                a=coor[j][<span class="number">0</span>]-coor[i][<span class="number">0</span>];</span><br><span class="line">                b=coor[j][<span class="number">1</span>]-coor[i][<span class="number">1</span>];</span><br><span class="line">                t=<span class="built_in">sqrt</span>(a*a+b*b);</span><br><span class="line">                line[i][j-n]=-t;</span><br><span class="line">                wx[i]=max(wx[i],-t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Km();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,matchx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title>Cyclic Tour(最小权值环)</title>
    <url>/Cyclic-Tour-%E6%9C%80%E5%B0%8F%E6%9D%83%E5%80%BC%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="传送门HDU1853"><a href="#传送门HDU1853" class="headerlink" title="传送门HDU1853"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1853" target="_blank" rel="noopener">HDU1853</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>There are N cities in our country, and M one-way roads connecting them. Now Little Tom wants to make several cyclic tours, which satisfy that, each cycle contain at least two cities, and each city belongs to one cycle exactly. Tom wants the total length of all the tours minimum, but he is too lazy to calculate. Can you help him?</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are several test cases in the input. You should process to the end of file (EOF).<br>The first line of each test case contains two integers N (N ≤ 100) and M, indicating the number of cities and the number of roads. The M lines followed, each of them contains three numbers A, B, and C, indicating that there is a road from city A to city B, whose length is C. (1 ≤ A,B ≤ N, A ≠ B, 1 ≤ C ≤ 1000).</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Output one number for each test case, indicating the minimum length of all the tours. If there are no such tours, output -1. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>6 9<br>1 2 5<br>2 3 5<br>3 1 10<br>3 4 12<br>4 1 8<br>4 6 11<br>5 4 7<br>5 6 9<br>6 5 4<br>6 5<br>1 2 1<br>2 3 1<br>3 4 1<br>4 5 1<br>5 6 1</li>
</ul>
</blockquote>
<ul>
<li>Output<br>42<br>-1</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给出n个点，m条边，两个点之间可能会有多条边，在图中找出几个环，每个点仅属于一个环，每个环至少两个点，求划分后这些环的最小权值和，如果有的点无法构成环，则输出-1。</li>
<li>对于一个环，每个点的出度和入度都是1，把每个点的出度和入度分开，构成二分图。如果某几个点构成完美匹配，则这几个点可构成一个环。这样问题就变成了找最小权值和的完美匹配，如果没有完美匹配，则输出-1。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn],wx[maxn],wy[maxn],visx[maxn],visy[maxn],match[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,minsub;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    visx[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visy[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t=wx[x]+wy[i]-line[x][i];</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            visy[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[i]||Find(match[i]))&#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> minsub=min(minsub,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Km</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            minsub=inf;</span><br><span class="line">            INIT(visx,<span class="number">0</span>);INIT(visy,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(Find(i)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visx[j]) wx[j]-=minsub;</span><br><span class="line">                <span class="keyword">if</span>(visy[j]) wy[j]+=minsub;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(line[match[i]][i]==-inf) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//两点间无边</span></span><br><span class="line">        ans+=line[match[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        INIT(match,<span class="number">0</span>);INIT(wy,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            wx[i]=-inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                line[i][j]=-inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            line[x][y]=max(line[x][y],-w);  </span><br><span class="line">            wx[x]=max(wx[x],-w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Km());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title>Going Home (最小权值完备匹配)</title>
    <url>/Going-Home-%E6%9C%80%E5%B0%8F%E6%9D%83%E5%80%BC%E5%AE%8C%E5%A4%87%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="传送门HDU1533"><a href="#传送门HDU1533" class="headerlink" title="传送门HDU1533"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1533" target="_blank" rel="noopener">HDU1533</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>On a grid map there are n little men and n houses. In each unit time, every little man can move one unit step, either horizontally, or vertically, to an adjacent point. For each little man, you need to pay a $1 travel fee for every step he moves, until he enters a house. The task is complicated with the restriction that each house can accommodate only one little man.<br>Your task is to compute the minimum amount of money you need to pay in order to send these n little men into those n different houses. The input is a map of the scenario, a ‘.’ means an empty space, an ‘H’ represents a house on that point, and am ‘m’ indicates there is a little man on that point.<br>You can think of each point on the grid map as a quite large square, so it can hold n little men at the same time; also, it is okay if a little man steps on a grid with a house without entering that house.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are one or more test cases in the input. Each case starts with a line giving two integers N and M, where N is the number of rows of the map, and M is the number of columns. The rest of the input will be N lines describing the map. You may assume both N and M are between 2 and 100, inclusive. There will be the same number of ‘H’s and ‘m’s on the map; and there will be at most 100 houses. Input will terminate with 0 0 for N and M. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, output one line with the single integer, which is the minimum amount, in dollars, you need to pay. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2 2<br>.m<br>H.<br>5 5<br>HH..m<br>…..<br>…..<br>…..<br>mm..H<br>7 8<br>…H….<br>…H….<br>…H….<br>mmmHmmmm<br>…H….<br>…H….<br>…H….<br>0 0</li>
</ul>
</blockquote>
<ul>
<li>Output<br>2<br>10<br>28</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给出n*m的地图，其中H表示房子，m表示人，每个房子只能装一个人，每个人都要走到一个房子里去，走进去需要消费相当于人与房子间的曼哈顿距离的代价，求最小代价和。</li>
<li>以人和房子为点，每个人与每个房子间的曼哈顿距离为边构成二分图。找出最小权值的完备匹配</li>
<li>最小权值的完备匹配，在最大权值匹配上，将边取负，其他变，得出答案后再取负的即可（负的最大即为正的最小）</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//边权改负  wx改负</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn],wx[maxn],wy[maxn],visx[maxn],visy[maxn],match[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> x,y;&#125;Node;</span><br><span class="line"><span class="keyword">int</span> sn,sm,n=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line">Node man[maxn];</span><br><span class="line">Node house[maxn];</span><br><span class="line"><span class="keyword">int</span> minsub=inf;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    visx[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visy[i]||line[x][i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t=wx[x]+wy[i]-line[x][i];</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            visy[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[i]||Find(match[i]))&#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> minsub=min(minsub,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Km</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            INIT(visx,<span class="number">0</span>);INIT(visy,<span class="number">0</span>);</span><br><span class="line">            minsub=inf;</span><br><span class="line">            <span class="keyword">if</span>(Find(i))<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(visx[j]) wx[j]-=minsub;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                <span class="keyword">if</span>(visy[j]) wy[j]+=minsub;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(match[i]) ans+=line[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> -ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;sn,&amp;sm)&amp;&amp;(sn&amp;&amp;sm))&#123;</span><br><span class="line">        INIT(line,<span class="number">0</span>);INIT(match,<span class="number">0</span>);</span><br><span class="line">        n=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sn;i++)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sm;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;s);</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="string">'H'</span>) house[++m]=(Node)&#123;i,j&#125;;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="string">'m'</span>) man[++n]=(Node)&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        INIT(wy,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            wx[i]=-inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> dis=<span class="built_in">abs</span>(man[i].x-house[j].x)+<span class="built_in">abs</span>(man[i].y-house[j].y);</span><br><span class="line">                line[i][j]=-dis;</span><br><span class="line">                wx[i]=max(wx[i],-dis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Km());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title>奔小康赚大钱（KM模板题）</title>
    <url>/%E5%A5%94%E5%B0%8F%E5%BA%B7%E8%B5%9A%E5%A4%A7%E9%92%B1%EF%BC%88KM%E6%A8%A1%E6%9D%BF%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="传送门HDU2255"><a href="#传送门HDU2255" class="headerlink" title="传送门HDU2255"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2255" target="_blank" rel="noopener">HDU2255</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>传说在遥远的地方有一个非常富裕的村落,有一天,村长决定进行制度改革：重新分配房子。<br>这可是一件大事,关系到人民的住房问题啊。村里共有n间房间,刚好有n家老百姓,考虑到每家都要有房住（如果有老百姓没房子住的话，容易引起不安定因素），每家必须分配到一间房子且只能得到一间房子。<br>另一方面,村长和另外的村领导希望得到最大的效益,这样村里的机构才会有钱.由于老百姓都比较富裕,他们都能对每一间房子在他们的经济范围内出一定的价格,比如有3间房子,一家老百姓可以对第一间出10万,对第2间出2万,对第3间出20万.(当然是在他们的经济范围内).现在这个问题就是村领导怎样分配房子才能使收入最大.(村民即使有钱购买一间房子但不一定能买到,要看村领导分配的).<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n&lt;=300)。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>请对每组数据输出最大的收入值，每组的输出占一行。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2<br>100 10<br>15 23</li>
</ul>
</blockquote>
<ul>
<li>Output<br>123</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>二分图最大权值和的完备匹配</li>
<li><a href="https://www.cnblogs.com/logosG/p/logos.html" target="_blank" rel="noopener">KM思路</a></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn],visx[maxn],visy[maxn],wx[maxn],wy[maxn],another[maxn];</span><br><span class="line"><span class="keyword">int</span> n,t,minsub;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    visx[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visy[i])<span class="keyword">continue</span>;</span><br><span class="line">        t=wx[x]+wy[i]-line[x][i];</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            visy[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!another[i]||Find(another[i]))&#123;</span><br><span class="line">                another[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">            minsub=min(minsub,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Km</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            INIT(visx,<span class="number">0</span>);INIT(visy,<span class="number">0</span>);</span><br><span class="line">            minsub=inf;</span><br><span class="line">            <span class="keyword">if</span>(Find(i))<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visx[j]) wx[j]-=minsub ;</span><br><span class="line">                <span class="keyword">if</span>(visy[j]) wy[j]+=minsub ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(another[i]) ans+=line[another[i]][i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))&#123;</span><br><span class="line">        INIT(wx,<span class="number">0</span>),INIT(wy,<span class="number">0</span>);</span><br><span class="line">        INIT(another,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;line[i][j]);</span><br><span class="line">                wx[i]=max(wx[i],line[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Km());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title>无题II(二分+匈牙利)</title>
    <url>/%E6%97%A0%E9%A2%98II-%E4%BA%8C%E5%88%86-%E5%8C%88%E7%89%99%E5%88%A9/</url>
    <content><![CDATA[<h1 id="传送门Poj1325"><a href="#传送门Poj1325" class="headerlink" title="传送门Poj1325"></a>传送门<a href="http://poj.org/problem?id=1325" target="_blank" rel="noopener">Poj1325</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>这是一个简单的游戏，在一个n*n的矩阵中，找n个数使得这n个数都在不同的行和列里并且要求这n个数中的最大值和最小值的差值最小。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>输入一个整数T表示T组数据。<br>对于每组数据第一行输入一个正整数n(1&lt;=n&lt;=100)表示矩阵的大小。<br>接着输入n行，每行n个数x(0&lt;=x&lt;=100)。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每组数据输出一个数表示最小差值。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1<br>4<br>1 1 1 1<br>2 2 2 2<br>3 3 3 3<br>4 4 4 4</li>
</ul>
</blockquote>
<ul>
<li>Output<br>3</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>找到最大差值maxsub，最小差值0，最大值maxnum，最小值minnum，二分差值找答案。</li>
<li>以行、列为顶点构建二分图，对于每个差值midsub=(maxsub+minsub)/2,令g从minsum遍历到g+midsub&lt;=maxnum,在每个区间[g,g+midsub]里面找二分图最大匹配，（<strong>匹配点权值均在区间内</strong>）；</li>
<li>如果在区间里能找到n个匹配，则说明最小差值&lt;=midsub，找差值左区间，同时保存这个差值；</li>
<li>否则说明最小差值&gt;=midsub，找差值右区间；</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn],vis[maxn],match[maxn];</span><br><span class="line"><span class="keyword">int</span> n,minnum,maxnum,minsub,maxsub,midsub,p;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]&amp;&amp;line[x][i]&gt;=p&amp;&amp;line[x][i]&lt;=p+midsub)&#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[i]||Find(match[i]))&#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Hungary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        INIT(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!Find(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        INIT(match,<span class="number">0</span>);</span><br><span class="line">        minnum=inf,maxnum=-inf;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;line[i][j]);</span><br><span class="line">                minnum=min(minnum,line[i][j]);</span><br><span class="line">                maxnum=max(maxnum,line[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minsub=<span class="number">0</span>,maxsub=maxnum-minnum;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(minsub&lt;=maxsub)&#123;</span><br><span class="line">            midsub=(minsub+maxsub)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(p=minnum;p+midsub&lt;=maxnum;p++)&#123;</span><br><span class="line">                INIT(match,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(Hungary()) &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)maxsub=midsub<span class="number">-1</span>,ans=midsub;</span><br><span class="line">            <span class="keyword">else</span> minsub=midsub+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Schedule</title>
    <url>/Machine-Schedule/</url>
    <content><![CDATA[<h1 id="传送门Poj1325"><a href="#传送门Poj1325" class="headerlink" title="传送门Poj1325"></a>传送门<a href="http://poj.org/problem?id=1325" target="_blank" rel="noopener">Poj1325</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>As we all know, machine scheduling is a very classical problem in computer science and has been studied for a very long history. Scheduling problems differ widely in the nature of the constraints that must be satisfied and the type of schedule desired. Here we consider a 2-machine scheduling problem.<br>There are two machines A and B. Machine A has n kinds of working modes, which is called mode_0, mode_1, …, mode_n-1, likewise machine B has m kinds of working modes, mode_0, mode_1, … , mode_m-1. At the beginning they are both work at mode_0.<br>For k jobs given, each of them can be processed in either one of the two machines in particular mode. For example, job 0 can either be processed in machine A at mode_3 or in machine B at mode_4, job 1 can either be processed in machine A at mode_2 or in machine B at mode_4, and so on. Thus, for job i, the constraint can be represent as a triple (i, x, y), which means it can be processed either in machine A at mode_x, or in machine B at mode_y.<br>Obviously, to accomplish all the jobs, we need to change the machine’s working mode from time to time, but unfortunately, the machine’s working mode can only be changed by restarting it manually. By changing the sequence of the jobs and assigning each job to a suitable machine, please write a program to minimize the times of restarting machines.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input file for this program consists of several configurations. The first line of one configuration contains three positive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). The following k lines give the constrains of the k jobs, each line is a triple: i, x, y. The input will be terminated by a line containing a single zero. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对输入的每组数据，按照如下格式输出：<br>The output should be one integer per line, which means the minimal times of restarting machine.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5 5 10<br>0 1 1<br>1 1 2<br>2 1 3<br>3 1 4<br>4 2 1<br>5 2 2<br>6 2 3<br>7 2 4<br>8 3 3<br>9 4 3<br>0</li>
<li>Output<br>3</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：现在机器A有n种状态（1~n)，机器B有m种状态(1~m)，k项工作。每项工作可以让机器A的状态x做，也可以让机器B的状态y做。每台机器某一时刻只能处于某一种状态，显然，要完成所有工作就需要不断改变两台机器的状态。两台机器的初始状态都是0，给出k项工作的x，y，k项工作完成顺序不限，求出想要完成所有工作，A、B两机器需要改变状态次数和最小是多少。</li>
<li>根据每项工作i，将xi、yi连接起来，构成二分图，这条连线就表示工作i。我们需要找到最少的点使得所有的边被覆盖，也就是最小点覆盖。最小点覆盖=二分图最大匹配。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> line[maxn][maxn],used[maxn],another[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i]&amp;&amp;line[x][i])&#123;</span><br><span class="line">            used[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!another[i]||Find(another[i]))&#123;</span><br><span class="line">                another[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        INIT(used,<span class="number">0</span>);</span><br><span class="line">        ans+=Find(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;t);</span><br><span class="line">        INIT(line,<span class="number">0</span>);INIT(another,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            line[b][c]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Count());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2017OpenGL的配置</title>
    <url>/VS2017OpenGL%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br><a id="more"></a></p>
<h1 id="下载OpenGL"><a href="#下载OpenGL" class="headerlink" title="下载OpenGL"></a>下载OpenGL</h1><ul>
<li>打开网址：<a href="https://www.opengl.org/resources/libraries/glut/glut_downloads.php" target="_blank" rel="noopener">https://www.opengl.org/resources/libraries/glut/glut_downloads.php</a></li>
<li>找到标题为 GLUT for Microsoft Windows 9X, ME, 2000, NT &amp; XP users，下面有：<br>If you want just the GLUT header file, the .LIB, and .DLL files all pre-compiled for Intel platforms, you can simply download the glutdlls37beta.zip file (149 kilobytes)。</li>
<li>点击 glutdlls37beta.zip 即可下载。</li>
</ul>
</blockquote>
<h1 id="配置OpenGL"><a href="#配置OpenGL" class="headerlink" title="配置OpenGL"></a>配置OpenGL</h1><blockquote>
<ul>
<li>将下载的 glutdlls37beta.zip 解压可发现里面包含 glut.dll glut32.dll glut.lib glut32.lib glut.h 5个文件。</li>
<li>然后找到vs2017安装的目录，路径为 （C:Program File(x86)）\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.11.25503\include ，创建一个名为gl的文件夹，并将解压到的glut.h文件复制其中。</li>
<li>再找到路径为 （C:Program File(x86)）\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.11.25503\lib\x86 ，将解压到的glut.lib，glut32.lib复制其中。</li>
<li>最后把解压到的glut.dll和glut32.dll复制到C:\Windows\System32文件夹内（32位系统）或C:\Windows\SysWOW64(64位系统）。<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1></li>
<li>打开vs2017，新建一个C++的Windows控制台应用程序的空项目，将如下代码粘贴：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glRectf(<span class="number">-0.1f</span>, <span class="number">-0.1f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);</span><br><span class="line">    glutInitWindowPosition(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    glutInitWindowSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    glutCreateWindow(<span class="string">"OpenGL-ONE"</span>);</span><br><span class="line">    glutDisplayFunc(Show);</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>如果你能成功运行如上代码，并且成功绘制了一个矩形，那么配置成功。</p>
]]></content>
  </entry>
  <entry>
    <title>系统重装后快速恢复hexo</title>
    <url>/%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E5%90%8E%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8Dhexo/</url>
    <content><![CDATA[<blockquote>
<p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br><a id="more"></a></p>
</blockquote>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><blockquote>
<p>Git和Node.js<br><img src="../image/recover/git.jpg" alt=""><br><img src="../image/recover/node.jpg" alt=""></p>
</blockquote>
<h1 id="配置git个人信息，生成新的ssh密匙"><a href="#配置git个人信息，生成新的ssh密匙" class="headerlink" title="配置git个人信息，生成新的ssh密匙"></a>配置git个人信息，生成新的ssh密匙</h1><blockquote>
<ul>
<li>git config —global user.name “xxxxxx”</li>
<li>git config —global user.email “xxxxxx”</li>
<li>ssh-keygen -t rsa -C “xxxxxxxx(邮箱)”<br>中间连按3个回车<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/Mr.Yang/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/Mr.Yang/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/Mr.Yang/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:zA6wNJrFB6NcqS6eBog/AHlzQuvFjYpG759Yhh1lWGI xxxxxx@xxxxx.xxx(上面自己的邮箱)</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|    +E .         |</span><br><span class="line">| ..+oo+          |</span><br><span class="line">| oo+*+.o         |</span><br><span class="line">|o.*===+o         |</span><br><span class="line">|==+*... S        |</span><br><span class="line">|B.+.o .o         |</span><br><span class="line">|++o. +  .        |</span><br><span class="line">| +o.+ .          |</span><br><span class="line">|.  o.o           |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="在GitHub上建一个新的ssh"><a href="#在GitHub上建一个新的ssh" class="headerlink" title="在GitHub上建一个新的ssh"></a>在GitHub上建一个新的ssh</h1><blockquote>
<ul>
<li>在用户-&gt;.ssh目录下已经得到了两个文件：id_rsa（私有秘钥）和id_rsa.pub（公有密钥）<br><img src="../image/recover/id_rsa.jpg" alt=""><br>用记事本打开</li>
<li>在GitHub右上角用户找到Settings<br><img src="../image/recover/3.jpg" alt=""></li>
<li>在左边找到SSH…<br><img src="../image/recover/4.jpg" alt=""></li>
<li>new一个ssh，把id_rsa.pub里面的东西全放进去，标题随便起。<br><img src="../image/recover/5.jpg" alt=""></li>
<li>在git bash 下输入命令检测是否成功<br><code>ssh -T git@github.com</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?  # 直接输入yes</span><br><span class="line">Hi cnfeat! You&apos;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><blockquote>
<ul>
<li>npm install hexo-cli -g</li>
<li>检测是否完成 <code>hexo server</code></li>
<li>部署<code>hexo g &amp;&amp; hexo d</code></li>
</ul>
</blockquote>
<h1 id="解决每次部署都要输入账户密码的问题"><a href="#解决每次部署都要输入账户密码的问题" class="headerlink" title="解决每次部署都要输入账户密码的问题"></a>解决每次部署都要输入账户密码的问题</h1><ul>
<li><code>git remote -v</code>查看远程连接方式</li>
<li><code>git remote rm origin</code>删除之前的连接方式</li>
<li>GitHub仓库复制SSH地址<br><img src="../image/recover/1.jpg" alt=""><br><img src="../image/recover/2.jpg" alt=""></li>
<li><code>git remote add origin SSH地址</code>，连接方式改为SSh</li>
<li><code>git remote -v</code> 查看发现已更改</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>仓鼠找sugar(倍增LCA)</title>
    <url>/%E4%BB%93%E9%BC%A0%E6%89%BEsugar-%E5%80%8D%E5%A2%9ELCA/</url>
    <content><![CDATA[<h1 id="传送门-洛谷P3398"><a href="#传送门-洛谷P3398" class="headerlink" title="传送门 洛谷P3398"></a>传送门 <a href="https://www.luogu.org/problemnew/show/P3398" target="_blank" rel="noopener">洛谷P3398</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为1~n。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（a）到餐厅（b），而他的基友同时要从他的卧室（c）到图书馆（d）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？<br>小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行两个正整数n和q，表示这棵树节点的个数和询问的个数。<br>接下来n-1行，每行两个正整数u和v，表示节点u到节点v之间有一条边。<br>接下来q行，每行四个正整数a、b、c和d，表示节点编号，也就是一次询问，其意义如上。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每个询问，如果有公共点，输出大写字母“Y”；否则输出“N”。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>Input<br>5 5<br>2 5<br>4 2<br>1 3<br>1 4<br>5 1 5 1<br>2 2 1 4<br>4 1 3 4<br>3 1 1 5<br>3 5 1 4</p>
</li>
<li><p>Output<br>Y<br>N<br>Y<br>Y<br>Y</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>如果两个仓鼠走的路有交集的话，那么其中一个的LCA一定在另一个路径上。</li>
<li>设a,b的LCA为x，c,d的LCA为y，如果<code>depth[x] &gt; depth[y]</code>，x必然在cy或者dy上，即x必然和c、d其中一个点有公共祖先，并且这个点的在x下面；<br>同理，如果<code>depth[x] &lt; depth[y]</code>，y必然和a、b其中一个有公共祖先，并且这个点在y下面。<br><img src="../image/lca.jpg" alt=""></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],fa[maxn][<span class="number">30</span>],lg[maxn],depth[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;ae[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,n,q;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	ae[tot]=(Edge)&#123;y,Begin[x]&#125;;</span><br><span class="line">	Begin[x]=tot++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	fa[now][<span class="number">0</span>]=f;</span><br><span class="line">	depth[now]=depth[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=depth[now];i++)</span><br><span class="line">		fa[now][i]=fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];~i;i=ae[i].next)</span><br><span class="line">		<span class="keyword">if</span>(ae[i].to!=f)Dfs(ae[i].to,now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">while</span>(depth[x]&gt;depth[y])</span><br><span class="line">		x=fa[x][lg[depth[x]-depth[y]]<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">			x=fa[x][i],y=fa[y][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(depth[x]&lt;depth[y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span>(depth[x]&gt;depth[y])</span><br><span class="line">		x=fa[x][lg[depth[x]-depth[y]]<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	INIT(Begin,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">		Add(a,b);Add(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		lg[i]=lg[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg[i<span class="number">-1</span>]==i);</span><br><span class="line">	Dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">		<span class="keyword">int</span> x=Lca(a,b),y=Lca(c,d);</span><br><span class="line">		<span class="keyword">if</span>(depth[x]&lt;depth[y])&#123;</span><br><span class="line">			<span class="keyword">if</span>(Judge(a,y)||Judge(b,y))<span class="built_in">printf</span>(<span class="string">"Y\n"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"N\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(Judge(c,x)||Judge(d,x))<span class="built_in">printf</span>(<span class="string">"Y\n"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"N\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>倍增LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>How far away(倍增LCA)</title>
    <url>/How-far-away-%E5%80%8D%E5%A2%9ELCA/</url>
    <content><![CDATA[<h1 id="传送门-HDU2586"><a href="#传送门-HDU2586" class="headerlink" title="传送门 HDU2586"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2586" target="_blank" rel="noopener">HDU2586</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>There are n houses in the village and some bidirectional roads connecting them. Every day peole always like to ask like this “How far is it if I want to go from house A to house B”? Usually it hard to answer. But luckily int this village the answer is always unique, since the roads are built in the way that there is a unique simple path(“simple” means you can’t visit a place twice) between every two houses. Yout task is to answer all these curious people.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>First line is a single integer T(T&lt;=10), indicating the number of test cases.<br>  For each test case,in the first line there are two numbers n(2&lt;=n&lt;=40000) and m (1&lt;=m&lt;=200),the number of houses and the number of queries. The following n-1 lines each consisting three numbers i,j,k, separated bu a single space, meaning that there is a road connecting house i and house j,with length k(0&lt;k&lt;=40000).The houses are labeled from 1 to n.<br>  Next m lines each has distinct integers i and j, you areato answer the distance between house i and house j.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case,output m lines. Each line represents the answer of the query. Output a bland line after each test case.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2<br>3 2<br>1 2 10<br>3 1 15<br>1 2<br>2 3</li>
</ul>
</blockquote>
<p>2 2<br>1 2 100<br>1 2<br>2 1</p>
<blockquote>
<ul>
<li>Output<br>10<br>25<br>100<br>100</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给一棵树，求两点的最短距离。</li>
<li>带权LCA。在原有的基础上用dis[i][j]表示节点i到<code>i+(2^j)</code>节点的距离，dis[i][0]就是i节点到父节点的距离，<code>dis[i][j]=dis[i][j-1]+dis[father[i][j-1]][j-1]</code></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">4e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1</span>&lt;&lt;<span class="number">32</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],fa[maxn][<span class="number">30</span>],dis[maxn][<span class="number">30</span>],lg[maxn],depth[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,val,next;</span><br><span class="line">&#125;ae[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	ae[tot]=(Edge)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">	Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	depth[now]=depth[f]+<span class="number">1</span>;</span><br><span class="line">	fa[now][<span class="number">0</span>]=f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=depth[now];i++)&#123;</span><br><span class="line">		fa[now][i]=fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		dis[now][i]=dis[now][i<span class="number">-1</span>]+dis[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];~i;i=ae[i].next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ae[i].to!=f)&#123;</span><br><span class="line">			dis[ae[i].to][<span class="number">0</span>]=ae[i].val;</span><br><span class="line">			Dfs(ae[i].to,now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">while</span>(depth[x]&gt;depth[y])&#123;</span><br><span class="line">		<span class="keyword">int</span> k=lg[depth[x]-depth[y]]<span class="number">-1</span>;</span><br><span class="line">		ans+=dis[x][k];</span><br><span class="line">		x=fa[x][k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==y)<span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">			ans+=dis[x][i];ans+=dis[y][i];</span><br><span class="line">			x=fa[x][i],y=fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> ans+dis[x][<span class="number">0</span>]+dis[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)</span><br><span class="line">		lg[i]=lg[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg[i<span class="number">-1</span>]==i);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">		INIT(Begin,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">int</span> x,y,z;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">			Add(x,y,z);Add(y,x,z);</span><br><span class="line">		&#125;</span><br><span class="line">		Dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Lca(x,y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">15 100</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">2 4 4</span></span><br><span class="line"><span class="comment">2 5 5</span></span><br><span class="line"><span class="comment">2 6 6</span></span><br><span class="line"><span class="comment">3 7 7</span></span><br><span class="line"><span class="comment">3 8 8</span></span><br><span class="line"><span class="comment">8 9 9</span></span><br><span class="line"><span class="comment">8 10 10</span></span><br><span class="line"><span class="comment">8 11 11</span></span><br><span class="line"><span class="comment">10 12 12</span></span><br><span class="line"><span class="comment">10 13 13</span></span><br><span class="line"><span class="comment">12 14 14</span></span><br><span class="line"><span class="comment">12 15 15</span></span><br><span class="line"><span class="comment">4 15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>倍增LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>P3379 【模板】最近公共祖先（LCA）</title>
    <url>/P3379-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89/</url>
    <content><![CDATA[<h1 id="传送门-洛谷P3379"><a href="#传送门-洛谷P3379" class="headerlink" title="传送门 洛谷P3379"></a>传送门 <a href="https://www.luogu.org/problemnew/show/P3379" target="_blank" rel="noopener">洛谷P3379</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行包含三个正整数N、M、S，分别表示树的结点个数、询问的个数和树根结点的序号。<br>接下来N-1行每行包含两个正整数x、y，表示x结点和y结点之间有一条直接连接的边（数据保证可以构成树）。<br>接下来M行每行包含两个正整数a、b，表示询问a结点和b结点的最近公共祖先。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出包含M行，每行包含一个正整数，依次为每一个询问的结果。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5 5 4<br>3 1<br>2 4<br>5 1<br>1 4<br>2 4<br>3 2<br>3 5<br>1 2<br>4 5</li>
<li>Output<br>4<br>4<br>1<br>4<br>4</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>用father[i][j]表示节点i向上走2^j的节点，father[i][0]自然就是i的父节点，<code>father[i][j]=father[father[i][j-1]][j-1]</code>。</li>
<li>当查询a和b的最近公共祖先时，最暴力的方法就是先把两个节点深度统一，然后一起往上一步一步走，到相同为止。用father数组处理后，每次就可以一段一段地往上面走。</li>
<li>假设a的深度比b大，先将a移动到和b深度相同的位置，每次向上走<code>2^(log(depth[x]-depth[y])/log(2.0))</code>个，直到a,b深度相同为止。</li>
<li>当两个深度相同后，从<code>i=log(depth[x])/log(2.0)</code>开始，只要father[x][i]和father[y][i]不同，就往上面跳，i递减，这样只要他们有公共祖先，就一定能跳到公共祖先的孩子位置。</li>
<li>用递推的方法求lg数组，lg[i]表示<code>log(i)/log(2)+1</code>.</li>
<li>链式向前星存图</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1</span>&lt;&lt;<span class="number">32</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],father[maxn][<span class="number">22</span>],depth[maxn],lg[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;ae[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	ae[tot]=(Edge)&#123;y,Begin[x]&#125;;</span><br><span class="line">	Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	depth[now]=depth[fa]+<span class="number">1</span>;</span><br><span class="line">	father[now][<span class="number">0</span>]=fa;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=depth[now];i++)</span><br><span class="line">		father[now][i]=father[father[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];~i;i=ae[i].next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ae[i].to!=fa)dfs(ae[i].to,now);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">while</span>(depth[x]&gt;depth[y])</span><br><span class="line">		x=father[x][lg[depth[x]-depth[y]]<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(father[x][i]!=father[y][i])</span><br><span class="line">			x=father[x][i],y=father[y][i];</span><br><span class="line">	<span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	INIT(Begin,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">		add(x,y);add(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		lg[i]=lg[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg[i<span class="number">-1</span>]==i);</span><br><span class="line">	dfs(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Lca(x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>倍增LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>Interviewe ——RMQ</title>
    <url>/Interviewe%20/</url>
    <content><![CDATA[<h1 id="传送门-HDU-3486"><a href="#传送门-HDU-3486" class="headerlink" title="传送门 HDU - 3486"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3486" target="_blank" rel="noopener">HDU - 3486</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>YaoYao has a company and he wants to employ m people recently. Since his company is so famous, there are n people coming for the interview. However, YaoYao is so busy that he has no time to interview them by himself. So he decides to select exact m interviewers for this task.<br>YaoYao decides to make the interview as follows. First he queues the interviewees according to their coming order. Then he cuts the queue into m segments. The length of each segment is n/m, which means he ignores the rest interviewees (poor guys because they comes late). Then, each segment is assigned to an interviewer and the interviewer chooses the best one from them as the employee.<br>YaoYao’s idea seems to be wonderful, but he meets another problem. He values the ability of the ith arrived interviewee as a number from 0 to 1000. Of course, the better one is, the higher ability value one has. He wants his employees good enough, so the sum of the ability values of his employees must exceed his target k (exceed means strictly large than). On the other hand, he wants to employ as less people as possible because of the high salary nowadays. Could you help him to find the smallest m?<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input consists of multiple cases.<br>In the first line of each case, there are two numbers n and k, indicating the number of the original people and the sum of the ability values of employees YaoYao wants to hire (n≤200000, k≤1000000000). In the second line, there are n numbers v1, v2, …, vn (each number is between 0 and 1000), indicating the ability value of each arrived interviewee respectively.<br>The input ends up with two negative numbers, which should not be processed as a case.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, print only one number indicating the smallest m you can find. If you can’t find any, output -1 instead</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>输入<br>11 300<br>7 100 7 101 100 100 9 100 100 110 110<br>-1 -1</li>
<li>输出<br>3</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：给出n个数和一个k，要求把这n个数分成m段，多出来的不要，使得这m段中每一段的最大值加起来大于k，同时要求m尽可能小，求m。</li>
<li>所有数的和小于k则无解，整个序列的最大值maxval大于k则m=1，m从max(2,k/maxval)开始递增，对于每个m，找出每一段的最大值和，直到其大于k。</li>
<li>一维ST表存最值。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200007</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,num[maxn],st[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            st[i][j]=max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log</span>(r-l+<span class="number">1.0</span>)/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k))&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;k==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> maxval=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">            st[i][<span class="number">0</span>]=num[i];</span><br><span class="line">            maxval=max(maxval,num[i]);</span><br><span class="line">            sum+=num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxval&gt;=k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Init();</span><br><span class="line">        <span class="keyword">int</span> m=max(<span class="number">2</span>,k/maxval);<span class="comment">//m最小值</span></span><br><span class="line">        <span class="keyword">while</span>(m&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>,x=n/m;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">                ans+=Query((i<span class="number">-1</span>)*x+<span class="number">1</span>,i*x);</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;k)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>倍增求RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Cornfields —二维RMQ</title>
    <url>/Cornfields%20/</url>
    <content><![CDATA[<h1 id="传送门-POJ-2019"><a href="#传送门-POJ-2019" class="headerlink" title="传送门 POJ - 2019"></a>传送门 <a href="http://poj.org/problem?id=2019" target="_blank" rel="noopener">POJ - 2019</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>给出一个N*N （N&lt;=250）的方阵，以及K（&lt;=100000）个询问。每次询问如下：以（Xi,Yi）为左上角，边长为B的子方阵中，最大值和最小值的差是多少？<br>注意对于所有的询问，B都是一个定值。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行N，B（&lt;=N），K。含义如上。<br>接下来N行N列的一个矩阵，每个数&lt;=250。<br>接下来K行表示询问，每行两个数Xi, Yi 表示询问的方阵的左上角。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>一行一个正整数，含义如上。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>输入<br>5 3 1<br>5 1 2 6 3<br>1 3 5 2 7<br>7 2 4 6 1<br>9 9 8 6 5<br>0 6 9 3 9<br>1 2</li>
<li>输出<br>5</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>二维ST表。用st[i][j][k]表示第i行区间[j,j+(1&lt;&lt;k)]的最值。</li>
<li>O(n^2lgn)预处理，O(n)查询</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> n,b,k;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn],st1[maxn][maxn][<span class="number">30</span>],st2[maxn][maxn][<span class="number">30</span>];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;k)&lt;=n;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=n;j++)&#123;</span><br><span class="line">                st1[i][j][k]=max(st1[i][j][k<span class="number">-1</span>],st1[i][j+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">                st2[i][j][k]=min(st2[i][j][k<span class="number">-1</span>],st2[i][j+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;b,&amp;k))&#123;</span><br><span class="line">        INIT(st1,<span class="number">128</span>);INIT(st2,INF);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">                st1[i][j][<span class="number">0</span>]=a[i][j];</span><br><span class="line">                st2[i][j][<span class="number">0</span>]=a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        Init();</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">int</span> ans1=MIN,ans2=MAX;         <span class="comment">//max min</span></span><br><span class="line">            <span class="keyword">int</span> k=<span class="built_in">log</span>(<span class="keyword">double</span>(b))/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">            <span class="keyword">int</span> l=y,r=y+b<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;x+b;i++)&#123;        <span class="comment">//you will TLE if you call function</span></span><br><span class="line">                ans1=max(ans1,max(st1[i][l][k],st1[i][r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]));</span><br><span class="line">                ans2=min(ans2,min(st2[i][l][k],st2[i][r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans1-ans2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>倍增求RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Frequent values ——RMQ</title>
    <url>/Frequent%20values%20%E2%80%94%E2%80%94RMQ/</url>
    <content><![CDATA[<h1 id="传送门-POJ-3368"><a href="#传送门-POJ-3368" class="headerlink" title="传送门 POJ - 3368"></a>传送门 <a href="http://poj.org/problem?id=3368" target="_blank" rel="noopener">POJ - 3368</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>You are given a sequence of n integers a1 , a2 , … , an in non-decreasing order. In addition to that, you are given several queries consisting of indices i and j (1 ≤ i ≤ j ≤ n). For each query, determine the most frequent value among the integers ai , … , aj.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>he input consists of several test cases. Each test case starts with a line containing two integers n and q (1 ≤ n, q ≤ 100000). The next line contains n integers a1 , … , an (-100000 ≤ ai ≤ 100000, for each i ∈ {1, …, n}) separated by spaces. You can assume that for each i ∈ {1, …, n-1}: ai ≤ ai+1. The following q lines contain one query each, consisting of two integers i and j (1 ≤ i ≤ j ≤ n), which indicate the boundary indices for the<br>query.<br>The last test case is followed by a line containing a single 0.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each query, print one line with one integer: The number of occurrences of the most frequent value within the given range.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>输入<br>10 3<br>-1 -1 1 1 1 1 3 10 10 10<br>2 3<br>1 10<br>5 10<br>0</li>
<li>输出<br>1<br>4<br>3</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：给n个数和m次询问，这n个数严格递增。对每次询问，找出区间[l,r]中出现次数最多的数，输出它出现的次数。</li>
<li>先预处理，用st[i][0]记录a[i]是在相同位置中第几个出现的，如样例中，<code>st[i][0]（i=1-&gt;n）={1,2,1,2,3,4,1,1,2,3}</code>。</li>
<li>st[i][j]记录[i,i+(1&lt;&lt;j)]中最大的st[x][0]。但这并不一定是[i,i+(1&lt;&lt;j)]中出现最多的次数</li>
<li>对于询问的每个区间[l,r]，先找到第一个比a[l]大的数，假如得出有x个a[l]，那么st[l+x,r]就一定是区间[l+x,r]中出现最多的次数。这样就得到答案为max(x,Find(l+x,r))。<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rmq</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">			ans[i][j]=max(ans[i][j<span class="number">-1</span>],ans[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log</span>(<span class="keyword">double</span>(r-l+<span class="number">1</span>))/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">	<span class="keyword">return</span> max(ans[l][k],ans[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">		INIT(ans,<span class="number">0</span>);ans[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])</span><br><span class="line">				ans[i][<span class="number">0</span>]=ans[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> ans[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Rmq();</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;l,&amp;r);</span><br><span class="line">			<span class="keyword">if</span>(l==r)&#123;                   <span class="comment">//只有一个数</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(a[l]==a[r])&#123;             <span class="comment">//所有数相同</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r-l+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> al=upper_bound(a+<span class="number">1</span>,a+n,a[l])-a;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(al-l,Find(al,r)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>倍增求RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Balanced Lineup——RMQ</title>
    <url>/Balanced-Lineup%E2%80%94%E2%80%94RMQ/</url>
    <content><![CDATA[<h1 id="传送门-POJ-3264"><a href="#传送门-POJ-3264" class="headerlink" title="传送门 POJ - 3264"></a>传送门 <a href="https://cn.vjudge.net/problem/10244/origin" target="_blank" rel="noopener">POJ - 3264</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.<br>Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>Line 1: Two space-separated integers, N and Q.<br>Lines 2.. N+1: Line i+1 contains a single integer that is the height of cow i<br>Lines N+2.. N+ Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Lines 1.. Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>输入<br>6 3<br>1<br>7<br>3<br>4<br>2<br>5<br>1 5<br>4 6<br>2 2</li>
<li>输出<br>6<br>3<br>0</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：给n个数和m次询问，每次询问给l和r，求区间[l,r]中最大值和最小值的差值。</li>
<li>st[i][j]表示区间[i,i+2^j-1]内的最值。</li>
<li>以最大值为例，<code>st[i][j]=max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1])</code>。</li>
<li>询问区间[l,r]时，取区间<code>[l,l+(1&lt;&lt;k)]</code>和<code>[r-(1&lt;&lt;k)+1][r]</code>，其中<code>k=log(r-l+1.0)/log(2.0)</code>，这样两个区间必有交集，则两个区间的最大值的最大值就一定是[l,r]的最大值。</li>
<li>st表构造O(nlgn)，查找O(1)。当需要多次查找区间最值，不需要进行修改操作时，st表比线段树、树状数组更好用。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50007</span>;</span><br><span class="line"><span class="keyword">int</span> st1[maxn][<span class="number">20</span>],st2[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,l,r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rmq</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)                <span class="comment">//外层j，稍加推导即可理解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;       <span class="comment">//st[i][j]包含区间 [i,i+2^j-1]</span></span><br><span class="line">            st1[i][j]=max(st1[i][j<span class="number">-1</span>],st1[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">            st2[i][j]=min(st2[i][j<span class="number">-1</span>],st2[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log</span>(<span class="keyword">double</span>(r-l+<span class="number">1</span>))/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans1=max(st1[l][k],st1[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">int</span> ans2=min(st2[l][k],st2[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(ans1-ans2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    INIT(st2,INF);INIT(st1,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;st1[i][<span class="number">0</span>]);</span><br><span class="line">        st2[i][<span class="number">0</span>]=st1[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Rmq();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Find(l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>倍增求RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>处女座与小姐姐（三）</title>
    <url>/%E5%A4%84%E5%A5%B3%E5%BA%A7%E4%B8%8E%E5%B0%8F%E5%A7%90%E5%A7%90%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>经过了选号和漫长的等待，处女座终于拿到了给小姐姐定制的手环，小姐姐看到以后直呼666！<br>处女座其实也挺喜欢6这个数字的，实际上他做手环的时候选取的k=6。所以他对于包含数码6的数字极其敏感。每次看到像4567这样的数字的时候他的心就像触电了一样，想起了小姐姐。<br>现在你要给处女座展示一系列数字，你想知道他的内心会激动多少次。对于同一个数字，他最多只会激动一次，即如果这个数是66666，他还是只会激动一次。</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>一行包括两个数字l,r，表示你给处女座展示的数字范围为[l,r]。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>一行一个整数，表示处女座内心激动的次数。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>10 20</li>
<li>Output<br>1</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>数位dp，dp[len]表示长度为len的数里面不包含6的数的个数</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL dp[<span class="number">20</span>],num[<span class="number">20</span>];</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(LL len,<span class="keyword">bool</span> limit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!len)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; dp[len])</span><br><span class="line">		<span class="keyword">return</span> dp[len];</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	LL up=limit?num[len]:<span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(LL i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>)<span class="keyword">continue</span>;</span><br><span class="line">		ans+=dfs(len<span class="number">-1</span>,limit &amp;&amp; (i==up));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> limit?ans:dp[len]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		num[++k]=n%<span class="number">10</span>;</span><br><span class="line">		n/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(k,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,m-n+<span class="number">1</span>-(solve(m)-solve(n<span class="number">-1</span>))); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>不要62</title>
    <url>/%E4%B8%8D%E8%A6%8162/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1 100<br>0 0</li>
<li>Output<br>80</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>数位dp，dp[len][0]和dp[len][1]表示长为len，最高位不为6和为6的数以下（包括自身）有多少不是不吉利数，</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=-MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>],dp[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">bool</span> if6,<span class="keyword">bool</span> limit)</span></span>&#123;   <span class="comment">//当前长度为len，上一位是否为6，这一位是否有最大限制</span></span><br><span class="line">	<span class="keyword">if</span>(!len)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; dp[len][if6]) <span class="keyword">return</span> dp[len][if6];</span><br><span class="line">	<span class="keyword">int</span> up=limit?num[len]:<span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((if6&amp;&amp;i==<span class="number">2</span>)||i==<span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">		ans+=dfs(len<span class="number">-1</span>,i==<span class="number">6</span>,limit&amp;&amp;i==up);  <span class="comment">//当上一位是达到上限且这一位也达到上限时下一位才有比9小的上限</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> limit?ans:dp[len][if6]=ans;      <span class="comment">//这一位达到上限的话就不能记忆，因为记录的只有最高位是6和不是6（9）的答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		num[++k]=n%<span class="number">10</span>;</span><br><span class="line">		n/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(k,<span class="literal">false</span>,<span class="literal">true</span>);   <span class="comment">//第一位当然是有上限的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)&amp;&amp;(n||m))&#123;</span><br><span class="line">		INIT(num,<span class="number">0</span>);INIT(dp,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(m)-solve(n<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Applese 涂颜色（欧拉降幂）</title>
    <url>/Applese-%E6%B6%82%E9%A2%9C%E8%89%B2%EF%BC%88%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%EF%BC%89/</url>
    <content><![CDATA[<h1 id="传送门-牛客训练赛4E"><a href="#传送门-牛客训练赛4E" class="headerlink" title="传送门 牛客训练赛4E"></a>传送门 <a href="https://ac.nowcoder.com/acm/contest/330/E" target="_blank" rel="noopener">牛客训练赛4E</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>精通程序设计的 Applese 叕写了一个游戏。<br>在这个游戏中，有一个 n 行 m 列的方阵。现在它要为这个方阵涂上黑白两种颜色。规定左右相邻两格的颜色不能相同。请你帮它统计一下有多少种涂色的方法。由于答案很大，你需要将答案对 1e9+7 取模。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>仅一行两个正整数 n, m，表示方阵的大小。（1&lt;=n,m&lt;=10^100000)</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出一个正整数，表示方案数对 1e9+7取模。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1 1<br>2 2</li>
<li>Output<br>2<br>4</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>显然答案是(2^n)%mod,但是n太大，需要欧拉降幂，也就是n=n%phi(mod)+phi(mod)，然后快速幂；</li>
<li>n采用字符串读入，按位模<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(LL i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		sum=(sum*<span class="number">10</span>+n[i]-<span class="string">'0'</span>)%p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*x)%mod;</span><br><span class="line">		x=(x*x)%mod;</span><br><span class="line">		n/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	LL p=mod<span class="number">-1</span>,len=n.size(); <span class="comment">//mod是素数  phi(mod)=mod-1</span></span><br><span class="line">	LL sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(LL i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		sum=(sum*<span class="number">10</span>+n[i]-<span class="string">'0'</span>)%p;</span><br><span class="line">	sum+=p;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;qpow(<span class="number">2</span>,sum)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Who Gets the Most Candies?(约瑟夫环+反素数+插队)</title>
    <url>/Who-Gets-the-Most-Candies-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="传送门POJ-2886"><a href="#传送门POJ-2886" class="headerlink" title="传送门POJ - 2886"></a>传送门<a href="http://poj.org/problem?id=2886" target="_blank" rel="noopener">POJ - 2886</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>N children are sitting in a circle to play a game.<br>The children are numbered from 1 to N in clockwise order. Each of them has a card with a non-zero integer on it in his/her hand. The game starts from the K-th child, who tells all the others the integer on his card and jumps out of the circle. The integer on his card tells the next child to jump out. Let A denote the integer. If A is positive, the next child will be the A-th child to the left. If A is negative, the next child will be the (−A)-th child to the right.<br>The game lasts until all children have jumped out of the circle. During the game, the p-th child jumping out will get F(p) candies where F(p) is the number of positive integers that perfectly divide p. Who gets the most candies?<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are several test cases in the input. Each test case starts with two integers N (0 &lt; N ≤ 500,000) and K (1 ≤ K ≤ N) on the first line. The next N lines contains the names of the children (consisting of at most 10 letters) and the integers (non-zero with magnitudes within 108) on their cards in increasing order of the children’s numbers, a name and an integer separated by a single space in a line with no leading or trailing spaces.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Output one line for each test case containing the name of the luckiest child and the number of candies he/she gets. If ties occur, always choose the child who jumps out of the circle first.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>4 2<br>Tom 2<br>Jack 4<br>Mary -1<br>Sam 1</li>
<li>Output<br>Sam 3</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：约瑟夫出列问题，给出人数n和初始出列位置k，然后给出每个人的id和val，val&gt;0则从k右边数val个，val<0则从k左边数val个。样例出队顺序：jack->Mary-&gt;Tom-&gt;Sam，我们给他们顺序标号tem，那么每个人出队的时候都可以得到p(tem)个糖果，p(tem)表示tem的因子个数，如p(4)=3(1,2,4);求得到糖果最多的人和糖果数</0则从k左边数val个。样例出队顺序：jack-></li>
<li>我们通过k和当前的val[i]可以确定下一个要出队的人是 <strong>剩下的</strong> 队伍中的第几个：若val&gt;0,从k-1(因为自己被移除了)往后面数val个然后%剩余人数，即：<code>k=(k-1+val[i])%(n-i)</code>为了防止1%1=0的情况，写成这种方式：<code>k=(k-1+val[i]-1)%(n-i)+1</code>;若val<0，则从k往前数val个再加上剩余人数，然后%剩余人数，同样要防止1%1=0的情况，即`k=((k+mes[tem].val-1)%(n-i)+n-i)%(n-i)+1;`。 样例的k值为2-="">2-&gt;1-&gt;1。</0，则从k往前数val个再加上剩余人数，然后%剩余人数，同样要防止1%1=0的情况，即`k=((k+mes[tem].val-1)%(n-i)+n-i)%(n-i)+1;`。></li>
<li>确定了下一个出队的人在第几个剩余人中的第几个之后，就要通过线段树插队找到他原来的位置，如果他现在是第k个，而前面k已经有人了，那么就往后摞，直到有位置可以放，这个位置就是它原来的位置。</li>
<li>反素数：对于数n，任何小于n的数的因子数都小于n的因子数，那么n就是一个反素数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ip[] = &#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">180</span>, <span class="number">240</span>, <span class="number">360</span>, <span class="number">720</span>,</span><br><span class="line">            <span class="number">840</span>, <span class="number">1260</span>, <span class="number">1680</span>, <span class="number">2520</span>, <span class="number">5040</span>, <span class="number">7560</span>, <span class="number">10080</span>, <span class="number">15120</span>, <span class="number">20160</span>,</span><br><span class="line">            <span class="number">25200</span>, <span class="number">27720</span>, <span class="number">45360</span>, <span class="number">50400</span>, <span class="number">55440</span>, <span class="number">83160</span>, <span class="number">110880</span>,</span><br><span class="line">            <span class="number">166320</span>, <span class="number">221760</span>, <span class="number">277200</span>, <span class="number">332640</span>, <span class="number">498960</span>, <span class="number">500001</span></span><br><span class="line">           &#125;; <span class="comment">//反素数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> div1[] = &#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">36</span>,</span><br><span class="line">             <span class="number">40</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">80</span>, <span class="number">84</span>, <span class="number">90</span>, <span class="number">96</span>, <span class="number">100</span>, <span class="number">108</span>, <span class="number">120</span>,</span><br><span class="line">             <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">168</span>, <span class="number">180</span>, <span class="number">192</span>, <span class="number">200</span></span><br><span class="line">            &#125;;<span class="comment">//反素数对应的约数个数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>我们要找到小于n且最接近n的反素数，答案就是它的因子个数。<br><em>也可以直接打表求每个数的因子个数</em></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) mamset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> ip[] = &#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">180</span>, <span class="number">240</span>, <span class="number">360</span>, <span class="number">720</span>,</span><br><span class="line">            <span class="number">840</span>, <span class="number">1260</span>, <span class="number">1680</span>, <span class="number">2520</span>, <span class="number">5040</span>, <span class="number">7560</span>, <span class="number">10080</span>, <span class="number">15120</span>, <span class="number">20160</span>,</span><br><span class="line">            <span class="number">25200</span>, <span class="number">27720</span>, <span class="number">45360</span>, <span class="number">50400</span>, <span class="number">55440</span>, <span class="number">83160</span>, <span class="number">110880</span>,</span><br><span class="line">            <span class="number">166320</span>, <span class="number">221760</span>, <span class="number">277200</span>, <span class="number">332640</span>, <span class="number">498960</span>, <span class="number">500001</span></span><br><span class="line">           &#125;; <span class="comment">//反素数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> div1[] = &#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">36</span>,</span><br><span class="line">             <span class="number">40</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">80</span>, <span class="number">84</span>, <span class="number">90</span>, <span class="number">96</span>, <span class="number">100</span>, <span class="number">108</span>, <span class="number">120</span>,</span><br><span class="line">             <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">168</span>, <span class="number">180</span>, <span class="number">192</span>, <span class="number">200</span></span><br><span class="line">            &#125;;<span class="comment">//反素数对应的约数个数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">20</span>];<span class="comment">//string直接t掉 </span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125;mes[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	tree[d]=r-l+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	build(l,mid,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	build(mid+<span class="number">1</span>,r,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	tree[d]--;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(num&lt;=tree[d&lt;&lt;<span class="number">1</span>]) <span class="keyword">return</span> update(l,mid,num,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> update(mid+<span class="number">1</span>,r,num-tree[d&lt;&lt;<span class="number">1</span>],d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k,tem,res;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">    	res=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;ip[i]&lt;=n;i++) res=i;</span><br><span class="line">    	build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    		<span class="built_in">cin</span>&gt;&gt;mes[i].s&gt;&gt;mes[i].val;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    		tem=update(<span class="number">1</span>,n,k,<span class="number">1</span>);</span><br><span class="line">    		<span class="keyword">if</span>(i==ip[res])&#123;</span><br><span class="line">    			<span class="built_in">cout</span>&lt;&lt;mes[tem].s&lt;&lt;<span class="string">" "</span>&lt;&lt;div1[res]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mes[tem].val&gt;<span class="number">0</span>) k=(k<span class="number">-1</span>+mes[tem].val<span class="number">-1</span>)%(n-i)+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> k=((k+mes[tem].val<span class="number">-1</span>)%(n-i)+n-i)%(n-i)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Buy Tickets (插队问题)</title>
    <url>/Buy-Tickets-%E6%8F%92%E9%98%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="传送门HDU-1754"><a href="#传送门HDU-1754" class="headerlink" title="传送门HDU - 1754"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">HDU - 1754</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Railway tickets were difficult to buy around the Lunar New Year in China, so we must get up early and join a long queue…<br>The Lunar New Year was approaching, but unluckily the Little Cat still had schedules going here and there. Now, he had to travel by train to Mianyang, Sichuan Province for the winter camp selection of the national team of Olympiad in Informatics.<br>It was one o’clock a.m. and dark outside. Chill wind from the northwest did not scare off the people in the queue. The cold night gave the Little Cat a shiver. Why not find a problem to think about? That was none the less better than freezing to death!<br>People kept jumping the queue. Since it was too dark around, such moves would not be discovered even by the people adjacent to the queue-jumpers. “If every person in the queue is assigned an integral value and all the information about those who have jumped the queue and where they stand after queue-jumping is given, can I find out the final order of people in the queue?” Thought the Little Cat.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There will be several test cases in the input. Each test case consists of N + 1 lines where N (1 ≤ N ≤ 200,000) is given in the first line of the test case. The next N lines contain the pairs of values Posi and Vali in the increasing order of i (1 ≤ i ≤ N). For each i, the ranges and meanings of Posi and Vali are as follows:</p>
<ul>
<li>Posi ∈ [0, i − 1] — The i-th person came to the queue and stood right behind the Posi-th person in the queue. The booking office was considered the 0th person and the person at the front of the queue was considered the first person in the queue.</li>
<li>Vali ∈ [0, 32767] — The i-th person was assigned the value Vali.<br>There no blank lines between test cases. Proceed to the end of input.</li>
</ul>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test cases, output a single line of space-separated integers which are the values of people in the order they stand in the queue.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>4<br>0 77<br>1 51<br>1 33<br>2 69<br>4<br>0 20523<br>1 19243<br>1 3890<br>0 31492</li>
<li>Output<br>77 33 69 51<br>31492 20523 3890 19243</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：pos[i]表示这个人现在要插入的位置，如果原来pos[i]有人，那么这个人就往pos[i]+1摞，如果pos[i]+1有人，那么原来pos[i]+1的人就往后摞……，每个人带有一个权值val[i]，给出每个人想要插入的位置，依次输出最后每个人的权值<br><img src="../image/插队.png" alt=""></li>
<li>逆向思考一波，最后一个人的位置一定是确定的，然后我们从后往前去安排每个人的位置，当安排pos[i]时如果pos[i]有人，那么他自己就往后面摞，直到有位置可以放为止</li>
<li>线段树维护区间内能存放的空位数，对于要存放的pos，如果pos&lt;=tree[d&lt;&lt;1],那么左子树区间一定可以放下它，否则就把pos-tree[d&lt;&lt;1]往右子树放（这里的pos和pos-tree[d&lt;&lt;1]分别对应区间的左数第pos、pos-tree[d&lt;&lt;1]个位置，最后节点的位置才是真正存放的位置）</li>
<li>不需要结构体，存放区间空位数即可</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">200007</span>],val[<span class="number">200007</span>];</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">800007</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">200007</span>];</span><br><span class="line"><span class="keyword">int</span> n,tem;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	tree[d]=r-l+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	build(l,mid,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	build(mid+<span class="number">1</span>,r,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	tree[d]--;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;=tree[d&lt;&lt;<span class="number">1</span>]) <span class="keyword">return</span> update(l,mid,p,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//位置小于左区间能存放的个数时就一定能在左边存下 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> update(mid+<span class="number">1</span>,r,p-tree[d&lt;&lt;<span class="number">1</span>],d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">		INIT(tree,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;pos[i],&amp;val[i]);</span><br><span class="line">		build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			tem=update(<span class="number">1</span>,n,pos[i]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">			ans[tem]=val[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans[i],<span class="string">" \n"</span>[i==n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Inversion Number（逆序数）</title>
    <url>/Minimum-Inversion-Number%EF%BC%88%E9%80%86%E5%BA%8F%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="传送门HDU-1394"><a href="#传送门HDU-1394" class="headerlink" title="传送门HDU - 1394"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1394" target="_blank" rel="noopener">HDU - 1394</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>The inversion number of a given number sequence a1, a2, …, an is the number of pairs (ai, aj) that satisfy i &lt; j and ai &gt; aj.<br>For a given sequence of numbers a1, a2, …, an, if we move the first m &gt;= 0 numbers to the end of the seqence, we will obtain another sequence. There are totally n such sequences as the following:<br>a1, a2, …, an-1, an (where m = 0 - the initial seqence)<br>a2, a3, …, an, a1 (where m = 1)<br>a3, a4, …, an, a1, a2 (where m = 2)<br>…<br>an, a1, a2, …, an-1 (where m = n-1)<br>You are asked to write a program to find the minimum inversion number out of the above sequences.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input consists of a number of test cases. Each case consists of two lines: the first line contains a positive integer n (n &lt;= 5000); the next line contains a permutation of the n integers from 0 to n-1. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each case, output the minimum inversion number on a single line. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>10<br>1 3 6 9 0 8 5 7 4 2</li>
<li>Output<br>16</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：给n个数，范围是0~n-1，并且每个数出现一次，每次可以将第一个数移到最后，求最大的逆序数（前面比他大的数的个数）之和</li>
<li>将a[i]填入对应位置，然后求1到a[i]中已经出现的数(这些数都小于等于a[i])的个数p，则a[i]的逆序数为i-p。当然这种方法的空间占用为max(a[i])，最好还是先离散化：<a href="http://bamboo-rat.cn/Ultra-QuickSort-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E9%80%86%E5%BA%8F%E6%95%B0/" target="_blank" rel="noopener">逆序数求法</a>，然后求出初始的逆序数和sum。</li>
<li>，因为每个数的范围是0~n-1且只出现一次，所以当a[i]从第一个位移到最后一位时，后面比他小的数的逆序数-1，逆序数和sum就要-(a[i])，自身的逆序数要加上整个序列里比他大的数，也就是(n-1)-a[i]，所以sum+=n-1-a[i]-a[i];</li>
<li>单点修改区间查询</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num,k,l,r;</span><br><span class="line">&#125;tree[<span class="number">20001</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5001</span>],sum,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	tree[d]=(Tree)&#123;<span class="number">0</span>,<span class="number">0</span>,l,r&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> mid=(tree[d].l+tree[d].r)/<span class="number">2</span>;</span><br><span class="line">	build(l,mid,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	build(mid+<span class="number">1</span>,r,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> a,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[d].l==tree[d].r)&#123;</span><br><span class="line">		tree[d].num+=a;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(tree[d].l+tree[d].r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=mid)add(i,a,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> add(i,a,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	tree[d].num=tree[d&lt;&lt;<span class="number">1</span>].num+tree[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[d].l==l&amp;&amp;tree[d].r==r)</span><br><span class="line">		<span class="keyword">return</span> tree[d].num;</span><br><span class="line">	<span class="keyword">int</span> mid=(tree[d].l+tree[d].r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> find(l,r,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;l) <span class="keyword">return</span> find(l,r,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> find(l,mid,d&lt;&lt;<span class="number">1</span>)+find(mid+<span class="number">1</span>,r,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">		build(<span class="number">1</span>,n,<span class="number">1</span>); sum=<span class="number">0</span>;ans=<span class="number">0x7fffffff</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">			add(a[i]+<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">			sum+=i-find(<span class="number">1</span>,a[i]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			sum+=n<span class="number">-2</span>*a[i]<span class="number">-1</span>;</span><br><span class="line">			ans=min(sum,ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树 逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title>I hate it （最值单点修改区间查询）</title>
    <url>/I-Hate-It/</url>
    <content><![CDATA[<h1 id="传送门HDU-1754"><a href="#传送门HDU-1754" class="headerlink" title="传送门HDU - 1754"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">HDU - 1754</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。<br>这让很多学生很反感。<br>不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>本题目包含多组测试，请处理到文件结束。<br>在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。<br>学生ID编号分别从1编到N。<br>第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。<br>接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。<br>当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。<br>当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每一次询问操作，在一行里面输出最高成绩。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5 6<br>1 2 3 4 5<br>Q 1 5<br>U 3 6<br>Q 3 4<br>Q 4 5<br>U 2 9<br>Q 1 5</li>
<li>Output<br>5<br>6<br>5<br>9</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>最值单点修改区间查询</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[d]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>,r,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    tree[d]=max(tree[d&lt;&lt;<span class="number">1</span>],tree[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r&amp;&amp;l==x) &#123;</span><br><span class="line">        tree[d]=y;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) update(d&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line">    <span class="keyword">else</span> update(d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    tree[d]=max(tree[d&lt;&lt;<span class="number">1</span>],tree[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ul,<span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=l&amp;&amp;r&lt;=ur) <span class="keyword">return</span> tree[d];</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=-inf;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=mid) ans=max(ans,query(d&lt;&lt;<span class="number">1</span>,l,mid,ul,ur));</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;ur) ans=max(ans,query(d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ul,ur));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">5</span>];<span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,s,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,n,a,b));</span><br><span class="line">            <span class="keyword">else</span> update(<span class="number">1</span>,<span class="number">1</span>,n,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>A Simple Problem with Integers(模板)</title>
    <url>/A-Simple-Problem-with-Integers-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="传送门POJ-3468"><a href="#传送门POJ-3468" class="headerlink" title="传送门POJ - 3468"></a>传送门<a href="https://cn.vjudge.net/problem/14607/origin" target="_blank" rel="noopener">POJ - 3468</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.<br>The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.<br>Each of the next Q lines represents an operation.<br>“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.<br>“Q a b” means querying the sum of Aa, Aa+1, … , Ab.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>You need to answer all Q commands in order. One answer in a line.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>10 5<br>1 2 3 4 5 6 7 8 9 10<br>Q 4 4<br>Q 1 10<br>Q 2 4<br>C 3 6 3<br>Q 2 4</li>
<li>Output<br>4<br>55<br>9<br>15</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：给1到n个数，输入Q，则询问[x,y]区间和；输入C，则在区间[x,y]加上z；</li>
<li>线段树，区间修改区间查询</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL sum[maxn&lt;&lt;<span class="number">2</span>],lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(LL d,LL len)</span></span>&#123;</span><br><span class="line">    lazy[d&lt;&lt;<span class="number">1</span>]+=lazy[d];</span><br><span class="line">    lazy[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[d];</span><br><span class="line">    sum[d&lt;&lt;<span class="number">1</span>]+=lazy[d]*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    sum[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[d]*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    lazy[d]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL l,LL r,LL d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[d]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>,r,d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum[d]=sum[d&lt;&lt;<span class="number">1</span>]+sum[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(LL d,LL l,LL r,LL ul,LL ur,LL num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=l&amp;&amp;r&lt;=ur)&#123;</span><br><span class="line">        lazy[d]+=num;</span><br><span class="line">        sum[d]+=num*(r-l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lazy[d]) down(d,r-l+<span class="number">1</span>);</span><br><span class="line">    LL mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=mid) update(d&lt;&lt;<span class="number">1</span>,l,mid,ul,ur,num);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;ur) update(d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ul,ur,num);</span><br><span class="line">    sum[d]=sum[d&lt;&lt;<span class="number">1</span>]+sum[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL d,LL l,LL r,LL ul,LL ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=l&amp;&amp;r&lt;=ur) <span class="keyword">return</span> sum[d];</span><br><span class="line">    <span class="keyword">if</span>(lazy[d]) down(d,r-l+<span class="number">1</span>);</span><br><span class="line">    LL mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=mid) ans+=query(d&lt;&lt;<span class="number">1</span>,l,mid,ul,ur);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;ur) ans+=query(d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ul,ur);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n,q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;q);</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];LL x,y;LL z;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            update(<span class="number">1</span>,<span class="number">1</span>,n,x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯消元模板</title>
    <url>/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="整数类型高斯消元"><a href="#整数类型高斯消元" class="headerlink" title="整数类型高斯消元"></a>整数类型高斯消元</h1><h2 id="返回值的情况"><a href="#返回值的情况" class="headerlink" title="返回值的情况"></a>返回值的情况</h2><blockquote>
<ul>
<li>-2表示有浮点数解，但无整数解</li>
<li>-1表示无解</li>
<li>0表示唯一解</li>
<li>大于0表示无穷解，并返回自由变元的个数<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2></li>
<li>有equ个方程，var个变元。 </li>
<li>增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.<a id="more"></a>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nmax 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[nmax][nmax];</span><br><span class="line"><span class="keyword">int</span> x[nmax];</span><br><span class="line"><span class="keyword">int</span> free_x[nmax];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> equ,<span class="keyword">int</span> var)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,max_r,col = <span class="number">0</span>,ta,tb;</span><br><span class="line">    <span class="keyword">int</span> LCM,temp,num = <span class="number">0</span>,free_index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=var;i++)&#123;</span><br><span class="line">        x[i]=<span class="number">0</span>;</span><br><span class="line">        free_x[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>;k &lt; equ &amp;&amp; col &lt; var;k++,col++)&#123;</span><br><span class="line">        max_r=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;equ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][col])&gt;<span class="built_in">abs</span>(a[max_r][col])) max_r=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_r!=k)&#123;<span class="comment">// 与第k行交换.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;var+<span class="number">1</span>;j++) swap(a[k][j],a[max_r][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[k][col]==<span class="number">0</span>)&#123;<span class="comment">// 说明该col列第k行以下全是0了，则处理当前行的下一列.</span></span><br><span class="line">            free_x[num++] = col;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;equ;i++)&#123;<span class="comment">// 枚举要删去的行.</span></span><br><span class="line">            <span class="keyword">if</span>(a[i][col]!=<span class="number">0</span>)&#123;</span><br><span class="line">                LCM = lcm(<span class="built_in">abs</span>(a[i][col]),<span class="built_in">abs</span>(a[k][col]));</span><br><span class="line">                ta = LCM/<span class="built_in">abs</span>(a[i][col]);</span><br><span class="line">                tb = LCM/<span class="built_in">abs</span>(a[k][col]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][col]*a[k][col]&lt;<span class="number">0</span>)tb=-tb;<span class="comment">//异号的情况是相加</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=col;j&lt;var+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                    a[i][j] = a[i][j]*ta-a[k][j]*tb;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; equ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i][col] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无穷解</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; var)&#123;</span><br><span class="line">        <span class="keyword">return</span> var - k; <span class="comment">// 自由变元有var - k个.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唯一解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        temp = a[i][var];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; var; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != <span class="number">0</span>) temp -= a[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp % a[i][i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// 说明有浮点数解，但无整数解.</span></span><br><span class="line">        x[i] = temp / a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h1><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS=<span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">double</span> a[N][N],x[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col=<span class="number">0</span>, k=<span class="number">0</span>;<span class="comment">//col为列号,k为行号</span></span><br><span class="line">    <span class="keyword">for</span> (;k&lt;m&amp;&amp;col&lt;n;++k,++col)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;m;++i)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][col])&gt;<span class="built_in">fabs</span>(a[r][col]))r=i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[r][col])&lt;EPS)&#123;k--;<span class="keyword">continue</span>;&#125;<span class="comment">//列全为0</span></span><br><span class="line">        <span class="keyword">if</span> (r!=k)<span class="keyword">for</span>(<span class="keyword">int</span> i=col;i&lt;=n;++i)</span><br><span class="line">            swap(a[k][i],a[r][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;m;++i)<span class="comment">//消元</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][col])&gt;EPS)&#123;</span><br><span class="line">            <span class="keyword">double</span> t = a[i][col]/a[k][col];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=col;j&lt;=n;j++)a[i][j]-=a[k][j]*t;</span><br><span class="line">            a[i][col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k ;i&lt;m ;++i)<span class="comment">//无解</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n])&gt;EPS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; n) <span class="keyword">return</span> n - k;  <span class="comment">//自由元个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;<span class="comment">//回带求解</span></span><br><span class="line">        <span class="keyword">double</span> temp = a[i][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">            temp -= x[j] * a[i][j];</span><br><span class="line">        x[i] = (temp / a[i][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求解异或方程组"><a href="#求解异或方程组" class="headerlink" title="求解异或方程组"></a>求解异或方程组</h1><blockquote>
<p>经常需要枚举自由元</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nmax 35</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[nmax][nmax];</span><br><span class="line"><span class="keyword">int</span> x[nmax];</span><br><span class="line"><span class="keyword">int</span> hashback[nmax][nmax];</span><br><span class="line"><span class="keyword">int</span> free_x[nmax];</span><br><span class="line"><span class="keyword">char</span> mp[nmax][nmax];</span><br><span class="line"><span class="keyword">int</span> ans1,ans2;</span><br><span class="line"><span class="keyword">int</span> equ,var;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_r;</span><br><span class="line">    <span class="keyword">int</span> col=<span class="number">0</span>,num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=var;++i) x[i] = free_x[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>;k &lt; equ &amp;&amp; col &lt; var;k++,col++)&#123;</span><br><span class="line">        max_r=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;equ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][col])&gt;<span class="built_in">abs</span>(a[max_r][col])) max_r=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_r!=k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k ;j&lt;var+<span class="number">1</span>;j++) swap(a[k][j],a[max_r][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[k][col]==<span class="number">0</span>)&#123;</span><br><span class="line">            free_x[num++] = col;</span><br><span class="line">            k--; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;equ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][col]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=col;j&lt;var+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                    a[i][j]^=a[k][j];;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i&lt;equ;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][col] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; var) <span class="keyword">return</span> var - k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        x[i]=a[i][var];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; var; j++)&#123;</span><br><span class="line">            x[i] ^= ( a[i][j] &amp;&amp; x[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enum_freex</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="number">1</span>&lt;&lt;(n));</span><br><span class="line">    ans = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                x[free_x[j]] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> x[free_x[j]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = var-n<span class="number">-1</span>;k&gt;=<span class="number">0</span>;--k)&#123;<span class="comment">// 没有自由元的最下面一行</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(index = k;k&lt;var;index++)&#123;<span class="comment">// 在当前行找到第一个非0自由元(如果存在的话)</span></span><br><span class="line">                <span class="keyword">if</span>(a[k][index]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x[index] = a[k][var];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index+<span class="number">1</span>;j&lt;var;++j)&#123;<span class="comment">// 向后依次计算出结果</span></span><br><span class="line">                <span class="keyword">if</span>(a[k][j]) x[index] ^= x[j];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += x[index]; <span class="comment">// 如果结果为1，则统计</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = min(ans,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><em>取自[pengwill97 ][<a href="https://blog.csdn.net/pengwill97/article/details/77282328" target="_blank" rel="noopener">https://blog.csdn.net/pengwill97/article/details/77282328</a> ]</em></p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元的具体求法</title>
    <url>/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E5%85%B7%E4%BD%93%E6%B1%82%E6%B3%95/</url>
    <content><![CDATA[<h1 id="费马小定理求逆元"><a href="#费马小定理求逆元" class="headerlink" title="费马小定理求逆元"></a>费马小定理求逆元</h1><blockquote>
<ul>
<li>费马小定理：a是不能被质数p整除的正整数，则有 a^(p-1) ≡ 1 (mod p)<br>求a关于p的乘法逆元，即为a*c≡ 1 (mod p),那么a^(p-2)就是a的逆元<a id="more"></a></li>
<li>Code<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">quickpow</span><span class="params">(LL x,LL n,LL Mod)</span></span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">    x%=Mod;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=(ans*x)%Mod;   <span class="comment">//n%2==1 			</span></span><br><span class="line">		x=(x*x)%Mod;</span><br><span class="line">		n/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getInv</span><span class="params">(LL a,LL mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> quickpow(a,mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O（logMod），且当Mod为不能整除a的素数时可用，一般题目给出1e9+7；</span></span><br><span class="line"><span class="comment">//当Mod-2过大的时候可以使用欧拉降幂防T，a^(Mod-2)%Mod=a^((Mod-2)%phi(Mod)+phi(Mod)) %Mod;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="扩欧求逆元"><a href="#扩欧求逆元" class="headerlink" title="扩欧求逆元"></a>扩欧求逆元</h1><blockquote>
<ul>
<li>给定模数m，求a的逆相当于求解ax=1(mod m)<br>这个方程可以转化为ax-my=1<br>然后套用求二元一次方程的方法，用扩展欧几里得算法求得一组x0,y0和gcd<br>检查gcd是否为1<br>gcd不为1则说明逆元不存在<br>若为1，则调整x0到0~m-1的范围中即可</li>
<li>Code<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span><span class="comment">//扩展欧几里得算法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getInv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> mod)</span><span class="comment">//求a在mod下的逆元，不存在逆元返回-1 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL d=exgcd(a,mod,x,y);</span><br><span class="line">    <span class="keyword">return</span> d==<span class="number">1</span>?(x%mod+mod)%mod:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(logn)，只要存在逆元均可求</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="线性推逆元"><a href="#线性推逆元" class="headerlink" title="线性推逆元"></a>线性推逆元</h1><blockquote>
<ul>
<li>求1,2,…,N关于mod的逆元（mod为质数）</li>
<li>Code<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> inv[maxn];</span><br><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    inv[i] = inv[mod % i] * (mod - mod / i) % mod;</span><br><span class="line"><span class="comment">//时间复杂度O(N),求1到N所有数的逆元</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="递归求逆元"><a href="#递归求逆元" class="headerlink" title="递归求逆元"></a>递归求逆元</h1><blockquote>
<ul>
<li>Code<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mod-mod/i)*inv(mod%i)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(logmod),mod是素数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数性质、证明及求法</title>
    <url>/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8%E3%80%81%E8%AF%81%E6%98%8E%E5%8F%8A%E6%B1%82%E6%B3%95/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<ul>
<li>欧拉函数φ(n)表示1~n中与n互质的数的个数<a id="more"></a></li>
<li><code>φ(n)=n(1-1/p1)(1-1/p2)(1-1/p3)......</code>;其中p1、p2、p3…为n的质因数，n为正整数 ;<br>比如x=12，其质因数为2,3。在1到12中，有1/2 的数是2的倍数，那么就有(1-1/2)的数不是2的倍数，<br>及1,3,5,7,9,11；在这些数中，有1/2的数是3的倍数，那么就有(1-1/3)的数不是3的倍数，及1,5,7,11；<br>这四个数即不是2的倍数，也不是3的倍数，故<code>φ(12)=12*(1-1/2)*(1-1/3)=4</code></li>
</ul>
</blockquote>
<h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h1><blockquote>
<p>若当m与n互质时f(mn)=f(m)f(n),那么f是积性函数。若对任意正整数，都有f(nm)=f(n)f(m)成立，则f是完全积性函数。</p>
</blockquote>
<h1 id="欧拉函数的重要性质"><a href="#欧拉函数的重要性质" class="headerlink" title="欧拉函数的重要性质"></a>欧拉函数的重要性质</h1><blockquote>
<ul>
<li>对于质数p，φ(p)=p−1;</li>
<li>若p为质数，n=p^k，则<code>φ(n)=p^k-p^(k-1)</code>;</li>
<li>欧拉函数是积性函数，但不是完全积性函数。若m,n互质，则<code>φ(m*n)=φ(m)*φ(n)</code>特殊的，当m=2，n为奇数时，<code>φ(2n)=φ(n)</code>;</li>
<li>当n&gt;2时，φ(n)是偶数;</li>
<li>小于n的数中，与n互质的数的总和为：<code>φ(n)*n / 2 (n&gt;1)</code>;</li>
<li>n的因数（包括1和它自己）的欧拉函数之和等于n</li>
<li>设p为质数，若p|n且p^2|n，则φ(n)=φ(n/p)*p</li>
<li>设p为质数，若p|n但n%p^2!=0，则φ(n)=φ(n/p)*(p-1)</li>
</ul>
</blockquote>
<h1 id="性质证明"><a href="#性质证明" class="headerlink" title="性质证明"></a>性质证明</h1><blockquote>
<p><img src="https://wx2.sinaimg.cn/mw690/006bDeXUgy1fzgllpqpv7j30v40bkgq0.jpg" alt="截自https://blog.csdn.net/liuzibujian/article/details/81086324"></p>
</blockquote>
<h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><blockquote>
<ul>
<li><p>直接使用公式求一个数n的欧拉函数值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">phi</span><span class="params">(LL n)</span></span>&#123;<span class="comment">//欧拉函数 </span></span><br><span class="line">     LL i,rea=n;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">             rea=rea-rea/i;          <span class="comment">//res=res*(1-(1/i))</span></span><br><span class="line">             <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(n&gt;<span class="number">1</span>) rea=rea-rea/n;          <span class="comment">//res=res*(1-(1/n)) 最后一个质因数</span></span><br><span class="line">     <span class="keyword">return</span> rea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用埃拉托斯特尼筛法<br><code>φ(n)=n(1-1/p1)(1-1/p2)....(1-1/pk)</code>,其中p1、p2…pk为n的所有素因子。<br>比如：<code>φ(12)=12*(1-1/2)*(1-1/3)=4</code>。<br>利用这个就比较好求了，可以用类似求素数的筛法。<br>先筛出N以内的所有素数，再以素数筛每个数的φ值。<br>比如求10以内所有数的φ值：<br>设一数组phi[11]，赋初值phi[1]=1,phi[2]=2…phi[10]=10；<br>然后从2开始循环，把2的倍数的φ值 <code>*(1-1/2)</code>，则<code>phi[2]=2*(1/2)=1,phi[4]=4*(1/2)=2,phi[6]=6*(1/2)=3....；</code><br>再是3，3的倍数的φ值<code>*(1-1/3)</code>，则<code>phi[3]=3*(2/3)=2,phi[6]=3*(2/3)=2，phi[9]=.....；</code><br>再5，再7…因为对每个素数都进行如此操作，因此任何一个n都得到了<code>φ(n)=n（1-1/p1)(1-1/p2)....(1-1/pk)</code>的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> Max)</span></span>&#123;   </span><br><span class="line">     phi[<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;Max;i++)  </span><br><span class="line">       phi[i]=i;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;Max;i++)  </span><br><span class="line">        <span class="keyword">if</span>(phi[i]==i)  </span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;Max;j+=i)  </span><br><span class="line">              phi[j]=phi[j]/i*(i<span class="number">-1</span>);    <span class="comment">//先进行除法是为了防止中间数据的溢出   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>小a与黄金街道(欧拉函数)</title>
    <url>/%E5%B0%8Fa%E4%B8%8E%E9%BB%84%E9%87%91%E8%A1%97%E9%81%93-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>小a和小b来到了一条布满了黄金的街道上。它们想要带几块黄金回去，然而这里的城管担心他们拿走的太多，于是要求小a和小b通过做一个游戏来决定最后得到的黄金的数量。<br>游戏规则是这样的：<br>假设道路长度为n米(左端点为0，右端点为n)，同时给出一个数k(下面会提到kk的用法)<br>设小a初始时的黄金数量为A，小b初始时的黄金数量为B<br>小a从11出发走向n−1，小b从n−1出发走向11，两人的速度均为1m/s<br>假设某一时刻(必须为整数)小a的位置为x，小b的位置为y，若gcd(n,x)=1且gcd(n,y)=1，那么小a的黄金数量A会变为A∗kx(kg)，小b的黄金数量B会变为B∗ky(kg)<br>当小a到达n−1时游戏结束<br>小a想知道在游戏结束时A+B的值<br>答案对10^9+7取模<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>一行四个整数n,k,a,b</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出一个整数表示答案</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input</li>
<li>4 2 1 1</li>
<li><p>5 1 1 1</p>
</li>
<li><p>Output</p>
</li>
<li>32</li>
<li>2</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li><img src="../image/欧拉.jpg" alt=""></li>
<li>求出1到n中与n互质的数的和sum，最后答案为k^sum*(A+B)</li>
<li>sum=phi(n)*n/2,phi(n)为<a href="http://bamboo-rat.cn/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8%E3%80%81%E8%AF%81%E6%98%8E%E5%8F%8A%E6%B1%82%E6%B3%95/" target="_blank" rel="noopener">欧拉函数</a>;</li>
<li>当sum过大时（此处不用），需要使用欧拉降幂，即x^sum%Mod=x^(sum%phi(Mod)+phi(Mod)) %Mod;</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL c=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">LL <span class="title">phi</span><span class="params">(LL n)</span></span>&#123;<span class="comment">//欧拉函数 </span></span><br><span class="line">     LL i,rea=n;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">             rea=rea-rea/i;</span><br><span class="line">             <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(n&gt;<span class="number">1</span>) rea=rea-rea/n;</span><br><span class="line">     <span class="keyword">return</span> rea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">PowerMod</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    a = a % c;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        ans = (ans * a) % c;</span><br><span class="line">        b = b/<span class="number">2</span>;</span><br><span class="line">        a = (a * a) % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    LL n,k,a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld %lld"</span>,&amp;n,&amp;k,&amp;a,&amp;b);</span><br><span class="line">	LL sum=n*phi(n)/<span class="number">2</span>;</span><br><span class="line">	LL tem=phi(c); </span><br><span class="line">	sum=sum%tem+tem;</span><br><span class="line">	LL res=PowerMod(k,sum)*(a+b)%c;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>没有上司的舞会</title>
    <url>/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行一个整数N。(1&lt;=N&lt;=6000)<br>接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127)<br>接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。<br>最后一行输入0 0</p>
</blockquote>
<h1 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h1><blockquote>
<p>输出最大的快乐指数。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>7<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1 3<br>2 3<br>6 4<br>7 4<br>4 5<br>3 5<br>0 0</li>
<li>Output<br>5</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>树形dp是建立在树这种数据结构上的dp,一般状态比较好想，通过dfs维护从根到叶子或从叶子到根的状态转移。</li>
<li>用dp[i][0]表示不选i结点的最优结果，dp[i][1]表示选i结点的最优结果<br>则：1.dp[fa][0]+=max(dp[son][1],dp[son][0])<br>  2.dp[fa][1]+=max(dp[son][0])<br>通过dfs从下往上遍历树的节点，通过子节点更新父节点，最后max(dp[root][0],dp[root][1])就是答案。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">6001</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">6001</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">6001</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">6001</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tree[<span class="number">6001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dp[fa][<span class="number">1</span>]=val[fa];</span><br><span class="line">    vis[fa]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[fa].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> son=tree[fa][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[son])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(son);</span><br><span class="line">        dp[fa][<span class="number">1</span>]+=dp[son][<span class="number">0</span>];</span><br><span class="line">        dp[fa][<span class="number">0</span>]+=max(dp[son][<span class="number">0</span>],dp[son][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        INIT(f,<span class="number">-1</span>);INIT(dp,<span class="number">0</span>);INIT(vis,<span class="number">0</span>);INIT(val,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">            tree[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fa,z;</span><br><span class="line">        <span class="keyword">while</span>((<span class="built_in">cin</span>&gt;&gt;fa&gt;&gt;z)&amp;&amp;(fa!=<span class="number">0</span>&amp;&amp;z!=<span class="number">0</span>))&#123;</span><br><span class="line">            f[fa]=z;</span><br><span class="line">            tree[z].push_back(fa);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(f[t]!=<span class="number">-1</span>) t=f[t];</span><br><span class="line">        dfs(t);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;max(dp[t][<span class="number">0</span>],dp[t][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>石子合并</title>
    <url>/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有n堆石子排成一行，每次选择相邻的两堆石子，将其合并为一堆，该次合并的消费为两堆石子个数之和。已知每堆石子的石子个数，求当所有石子合并为一堆时，最小的消费。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>有多组测试数据，输入到文件结束。<br>每组测试数据第一行有一个整数n，表示有n堆石子。<br>接下来的一行有n（0&lt; n &lt;200）个数，分别表示这n堆石子的数目，用空格隔开 </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出总代价的最小值，占单独的一行</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3<br>1 2 3<br>7<br>13 7 8 16 21 4 18</li>
<li>Output<br>9<br>239</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>用dp[i][j]表示区间[i,j]的最小花费。(N^2)枚举区间[i,j]，用断点k遍历i~j，则dp[i][j]=min(dp[i][k]+dp[k][j]+sum[j]-sum[i-1])，其中sum[i]为i的前缀和。时间复杂度为O(N^3)</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,dp[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">201</span>],x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    INIT(sum,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Intervals</title>
    <url>/Intervals/</url>
    <content><![CDATA[<h1 id="传送门Poj1201"><a href="#传送门Poj1201" class="headerlink" title="传送门Poj1201"></a>传送门<a href="http://poj.org/problem?id=1201" target="_blank" rel="noopener">Poj1201</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>You are given n closed, integer intervals [ai, bi] and n integers c1, …, cn.<br>Write a program that:<br>reads the number of intervals, their end points and integers c1, …, cn from the standard input,<br>computes the minimal size of a set Z of integers which has at least ci common elements with interval [ai, bi], for each i=1,2,…,n,<br>writes the answer to the standard output.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line of the input contains an integer n (1 &lt;= n &lt;= 50000) — the number of intervals. The following n lines describe the intervals. The (i+1)-th line of the input contains three integers ai, bi and ci separated by single spaces and such that 0 &lt;= ai &lt;= bi &lt;= 50000 and 1 &lt;= ci &lt;= bi - ai+1.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>The output contains exactly one integer equal to the minimal size of set Z sharing at least ci elements with interval [ai, bi], for each i=1,2,…,n.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5<br>3 7 3<br>8 10 3<br>6 8 1<br>1 3 1<br>10 11 1</li>
<li>Output<br>6</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：找一个区间z的大小，满足给定n组abc中,z在[a,b]中至少c个数，求最小的区间大小</li>
<li>求最小值，找最长路</li>
<li>用i表示0~i中在z的数，对于相邻的两个数i和i+1，满足：i+1 - i&lt;=1 , i+1 - i &gt;=0,故建边i+1 i -1，i i+1 0</li>
<li>对于给定的a,b,c：因为是闭区间，所以满足b+1 - a &gt;=c,故建边 a b+1 c</li>
<li>spfa 链式向前星</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> To,Dis,Next;&#125;;</span><br><span class="line">Node Edge[<span class="number">500005</span>];<span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],used[maxn],dis[maxn],n=<span class="number">-1</span>,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    Edge[top]=(Node)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    INIT(used,<span class="number">0</span>);INIT(dis,<span class="number">-1</span>);</span><br><span class="line">    dis[t]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;road;</span><br><span class="line">    road.push(t);used[t]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!road.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=road.front();used[now]=<span class="number">0</span>;road.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];i!=<span class="number">-1</span>;i=Edge[i].Next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ne=Edge[i].To;</span><br><span class="line">            <span class="keyword">if</span>(dis[ne]&lt;dis[now]+Edge[i].Dis)&#123;</span><br><span class="line">                dis[ne]=dis[now]+Edge[i].Dis;</span><br><span class="line">                <span class="keyword">if</span>(!used[ne])used[ne]=<span class="number">1</span>,road.push(ne);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    INIT(Begin,<span class="number">-1</span>);<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y+<span class="number">1</span>,z);</span><br><span class="line">        n=max(n,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        add(i,i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        add(i+<span class="number">1</span>,i,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,spfa(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>Is the Information Reliable?（判负环）</title>
    <url>/Is-the-Information-Reliable/</url>
    <content><![CDATA[<h1 id="传送门-Poj2983"><a href="#传送门-Poj2983" class="headerlink" title="传送门 Poj2983"></a>传送门 <a href="http://poj.org/problem?id=2983" target="_blank" rel="noopener">Poj2983</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>The galaxy war between the Empire Draco and the Commonwealth of Zibu broke out 3 years ago. Draco established a line of defense called Grot. Grot is a straight line with N defense stations. Because of the cooperation of the stations, Zibu’s Marine Glory cannot march any further but stay outside the line.<br>A mystery Information Group X benefits form selling information to both sides of the war. Today you the administrator of Zibu’s Intelligence Department got a piece of information about Grot’s defense stations’ arrangement from Information Group X. Your task is to determine whether the information is reliable.<br>The information consists of M tips. Each tip is either precise or vague.<br>Precise tip is in the form of P A B X, means defense station A is X light-years north of defense station B.<br>Vague tip is in the form of V A B, means defense station A is in the north of defense station B, at least 1 light-year, but the precise distance is unknown.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are several test cases in the input. Each test case starts with two integers N (0 &lt; N ≤ 1000) and M (1 ≤ M ≤ 100000).The next M line each describe a tip, either in precise form or vague form.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Output one line for each test case in the input. Output “Reliable” if It is possible to arrange N defense stations satisfying all the M tips, otherwise output “Unreliable”.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3 4<br>P 1 2 1<br>P 2 3 1<br>V 1 3<br>P 1 3 1<br>5 5<br>V 1 2<br>V 2 3<br>V 3 4<br>V 4 5<br>V 3 5</li>
<li>Output<br>Unreliable<br>Reliable</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：一天南北线上有n个防御站，给出他们之间的位置关系，问有没有可能存在这样一种位置布置符合所给的位置关系。关系有两种，一种是 P A B X，表示A在B北边X光年的位置，V A B表示A在B北边至少1光年位置。</li>
<li>若出现负环则不满足情况，求最长路最短路都可以，这里用最长路</li>
<li>用vis数组存下每个点的访问次数，如果&gt;=n,则必有负环</li>
<li>对P：B-A=X =&gt; B-A&gt;=x&amp;&amp;B-A&lt;=x,所以建两条边B A -X和 A B X;<br>对V：B-A&gt;=1，建边 A B 1；<br>另外，对所有的点，i-0&gt;=0，建边 0 i 0；</li>
<li>spfa 链式向前星</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1007</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Begin[maxn],used[maxn],dis[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> To,Dis,Next;&#125;;</span><br><span class="line">Node Edge[<span class="number">1000007</span>];<span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    Edge[top]=(Node)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    INIT(vis,<span class="number">0</span>);INIT(used,<span class="number">0</span>);INIT(dis,<span class="number">-1</span>);dis[t]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;lroad;</span><br><span class="line">    lroad.push(t);used[t]=<span class="number">1</span>;vis[t]++;</span><br><span class="line">    <span class="keyword">while</span>(!lroad.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=lroad.front();used[now]=<span class="number">0</span>;lroad.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];~i;i=Edge[i].Next)&#123;</span><br><span class="line">            <span class="keyword">int</span> tem=Edge[i].To;</span><br><span class="line">            <span class="keyword">if</span>(dis[tem]&lt;dis[now]+Edge[i].Dis)&#123;</span><br><span class="line">                dis[tem]=dis[now]+Edge[i].Dis;</span><br><span class="line">                <span class="keyword">if</span>(!used[tem])&#123;</span><br><span class="line">                    vis[tem]++;</span><br><span class="line">                    <span class="keyword">if</span>(vis[tem]&gt;=n)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    used[tem]=<span class="number">1</span>;</span><br><span class="line">                    lroad.push(tem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        INIT(Begin,<span class="number">-1</span>);top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> s;<span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;s);</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">'P'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">                add(a,b,c);</span><br><span class="line">                add(b,a,-c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">'V'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">                add(a,b,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) add(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(spfa(<span class="number">0</span>))<span class="built_in">printf</span>(<span class="string">"Reliable\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Unreliable\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>House Man</title>
    <url>/House-Man/</url>
    <content><![CDATA[<h1 id="传送门-Poj2983"><a href="#传送门-Poj2983" class="headerlink" title="传送门 Poj2983"></a>传送门 <a href="http://poj.org/problem?id=2983" target="_blank" rel="noopener">Poj2983</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>In Fuzhou, there is a crazy super man. He can’t fly, but he could jump from housetop to housetop. Today he plans to use N houses to hone his house hopping skills. He will start at the shortest house and make N-1 jumps, with each jump taking him to a taller house than the one he is jumping from. When finished, he will have been on every house exactly once, traversing them in increasing order of height, and ending up on the tallest house.<br>The man can travel for at most a certain horizontal distance D in a single jump. To make this as much fun as possible, the crazy man want to maximize the distance between the positions of the shortest house and the tallest house.<br>The crazy super man have an ability—move houses. So he is going to move the houses subject to the following constraints: </p>
<ol>
<li>All houses are to be moved along a one-dimensional path. </li>
<li>Houses must be moved at integer locations along the path, with no two houses at the same location. </li>
<li>Houses must be arranged so their moved ordering from left to right is the same as their ordering in the input. They must NOT be sorted by height, or reordered in any way. They must be kept in their stated order. </li>
<li>The super man can only jump so far, so every house must be moved close enough to the next taller house. Specifically, they must be no further than D apart on the ground (the difference in their heights doesn’t matter).<br>Given N houses, in a specified order, each with a distinct integer height, help the super man figure out the maximum possible distance they can put between the shortest house and the tallest house, and be able to use the houses for training. <a id="more"></a>
</li>
</ol>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>In the first line there is an integer T, indicates the number of test cases.(T&lt;=500)<br>Each test case begins with a line containing two integers N (1 ≤ N ≤ 1000) and D (1 ≤ D ≤1000000). The next line contains N integer, giving the heights of the N houses, in the order that they should be moved. Within a test case, all heights will be unique. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case , output “Case %d: “first where d is the case number counted from one, then output a single integer representing the maximum distance between the shortest and tallest house, subject to the constraints above, or -1 if it is impossible to lay out the houses. Do not print any blank lines between answers.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3<br>4 4<br>20 30 10 40<br>5 6<br>20 34 54 10 15<br>4 2<br>10 20 16 13 </li>
<li>Output<br>Case 1: 3<br>Case 2: 3<br>Case 3: -1</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：给个n个不同高度的房子，一个人从最低点跳跃，每次可以跳到第一个比它高的位置，最后跳到最高点，然后每次最多可以跳的距离为D，可以移动房子的水平位置，但是不能打乱房子的顺序，求从最低的房子到最高的房子之间的最大距离，没有满足情况则输出-1</li>
<li>若出现负环则不满足情况，题中求最大距离，所以建图求最短路</li>
<li>用vis数组存下每个点的访问次数，如果&gt;=n,则必有负环</li>
<li>首先存下每个房子的位置信息set，然后根据高度排序；<br>排序前，相邻房子之间：<code>(i+1 - i &gt;=1) =&gt; (i - i+1 &lt;=-1)</code>建边i+1 i -1（从右指左）;<br>排序后，i+1必然比i高，此时需比较两个房子原来的位置set，要从小的指向大的，即从左指到右</li>
<li>spfa 链式向前星</li>
<li>在spfa遍历的时候，要注意最矮的房子a和最高的房子b的位置，如果a在左边，就从a跑到b；如果a在b的右边，就从b跑到a；如果a在b的右边还是从a跑到b，因为我们之前从右到左都建了权值-1的边，那么从a跑到b就一直走-1，显然是不正确的。<br><img src="../image/差分约束.jpg" alt=""><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,d,Begin[maxn],used[maxn],vis[maxn],dis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> To,Dis,Next;&#125;;</span><br><span class="line">Node Edge[<span class="number">10007</span>];<span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">House</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> high,book;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> House&amp; e)&#123;<span class="keyword">return</span> high&lt;e.high;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">House hou[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    Edge[top]=(Node)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=INF;</span><br><span class="line">    dis[t]=<span class="number">0</span>;</span><br><span class="line">    INIT(used,<span class="number">0</span>);INIT(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;sroad;</span><br><span class="line">    sroad.push(t);used[t]=<span class="number">1</span>;vis[t]++;</span><br><span class="line">    <span class="keyword">while</span>(!sroad.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=sroad.front();used[now]=<span class="number">0</span>;sroad.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];i!=<span class="number">-1</span>;i=Edge[i].Next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ne=Edge[i].To;</span><br><span class="line">            <span class="keyword">if</span>(dis[ne]&gt;dis[now]+Edge[i].Dis)&#123;</span><br><span class="line">                dis[ne]=dis[now]+Edge[i].Dis;</span><br><span class="line">                <span class="keyword">if</span>(!used[ne])&#123;</span><br><span class="line">                    vis[ne]++;</span><br><span class="line">                    <span class="keyword">if</span>(vis[ne]&gt;=n)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    used[ne]=<span class="number">1</span>;</span><br><span class="line">                    sroad.push(ne);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[hou[n].book]==INF)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> max( dis[hou[n].book],dis[hou[<span class="number">1</span>].book] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _=<span class="number">1</span>;_&lt;=T;_++)&#123;</span><br><span class="line">        INIT(Begin,<span class="number">-1</span>);top=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;hou[i].high);</span><br><span class="line">            hou[i].book=i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(hou+<span class="number">1</span>,hou+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hou[i].book&lt;hou[i+<span class="number">1</span>].book) add(hou[i].book,hou[i+<span class="number">1</span>].book,d);</span><br><span class="line">            <span class="keyword">else</span> add(hou[i+<span class="number">1</span>].book,hou[i].book,d);</span><br><span class="line">            add(i+<span class="number">1</span>,i,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,_,spfa(min(hou[<span class="number">1</span>].book,hou[n].book)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>World Exhibition </title>
    <url>/World-Exhibition/</url>
    <content><![CDATA[<h1 id="传送门-HDU3592"><a href="#传送门-HDU3592" class="headerlink" title="传送门 HDU3592"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3592" target="_blank" rel="noopener">HDU3592</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Nowadays, many people want to go to Shanghai to visit the World Exhibition. So there are always a lot of people who are standing along a straight line waiting for entering. Assume that there are N (2 &lt;= N &lt;= 1,000) people numbered 1..N who are standing in the same order as they are numbered. It is possible that two or more person line up at exactly the same location in the condition that those visit it in a group.<br>There is something interesting. Some like each other and want to be within a certain distance of each other in line. Some really dislike each other and want to be separated by at least a certain distance. A list of X (1 &lt;= X &lt;= 10,000) constraints describes which person like each other and the maximum distance by which they may be separated; a subsequent list of Y constraints (1 &lt;= Y &lt;= 10,000) tells which person dislike each other and the minimum distance by which they must be separated.<br>Your job is to compute, if possible, the maximum possible distance between person 1 and person N that satisfies the distance constraints.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>First line: An integer T represents the case of test.<br>The next line: Three space-separated integers: N, X, and Y.<br>The next X lines: Each line contains three space-separated positive integers: A, B, and C, with 1 &lt;= A &lt; B &lt;= N. Person A and B must be at most C (1 &lt;= C &lt;= 1,000,000) apart.<br>The next Y lines: Each line contains three space-separated positive integers: A, B, and C, with 1 &lt;= A &lt; B &lt;= C. Person A and B must be at least C (1 &lt;= C &lt;= 1,000,000) apart.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>First line: An integer T represents the case of test.<br>The next line: Three space-separated integers: N, X, and Y.<br>The next X lines: Each line contains three space-separated positive integers: A, B, and C, with 1 &lt;= A &lt; B &lt;= N. Person A and B must be at most C (1 &lt;= C &lt;= 1,000,000) apart.<br>The next Y lines: Each line contains three space-separated positive integers: A, B, and C, with 1 &lt;= A &lt; B &lt;= C. Person A and B must be at least C (1 &lt;= C &lt;= 1,000,000) apart.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1<br>4 2 1<br>1 3 8<br>2 4 15<br>2 3 4</li>
<li>Output<br>19</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>题意：1~N人排队，X行中a和b最多距离c，Y行中a和b最少距离c，求最后1和N之间的最大距离</li>
<li>题目求1到N的最大距离，则求图中1到N的最短路</li>
<li>对于x，b-a&lt;=c,a到b建权值为c的有向边；<br>对于y,b-a&gt;=c =&gt; a-b&lt;=-c,b到a建权值-c的有向边;<br>另外，对于第i个人，i+1 - i &gt;=0 =&gt; i - i+1&lt;=0,i+1到i建权值为0的有向边。</li>
<li>spfa 链式向前星</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> Begin[maxn],used[maxn],dis[maxn],n,vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> To,Dis,Next;&#125;;</span><br><span class="line">Node Edge[<span class="number">100007</span>];<span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    Edge[top]=(Node)&#123;y,z,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    INIT(used,<span class="number">0</span>);INIT(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dis[i]=INF;</span><br><span class="line">    dis[t]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;road;</span><br><span class="line">    road.push(t);used[t]=<span class="number">1</span>;vis[t]++;</span><br><span class="line">    <span class="keyword">while</span>(!road.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=road.front();used[now]=<span class="number">0</span>;road.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];i!=<span class="number">-1</span>;i=Edge[i].Next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ne=Edge[i].To;</span><br><span class="line">            <span class="keyword">if</span>(dis[ne]&gt;dis[now]+Edge[i].Dis)&#123;</span><br><span class="line">                dis[ne]=dis[now]+Edge[i].Dis;</span><br><span class="line">                <span class="keyword">if</span>(!used[ne])&#123;</span><br><span class="line">                    used[ne]=<span class="number">1</span>,road.push(ne);</span><br><span class="line">                    vis[ne]++;</span><br><span class="line">                    <span class="keyword">if</span>(vis[ne]&gt;=n)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==INF)<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> t,x,y;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        INIT(Begin,<span class="number">-1</span>);top=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="keyword">while</span>(x--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            add(a,b,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            add(b,a,-c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) add(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,spfa(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>heap</title>
    <url>/heap/</url>
    <content><![CDATA[<blockquote>
<p>建堆 插入元素 删除元素 堆排序 判断堆 寻找第一个不符合堆的位置 ——algorithm<br><a id="more"></a></p>
<h1 id="建堆-make-heap"><a href="#建堆-make-heap" class="headerlink" title="建堆 make_heap"></a>建堆 make_heap</h1><p>默认建大根堆，O(n)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;                         <span class="comment">//注意是大于</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    make_heap(v1.begin(),v1.end());       <span class="comment">//默认构建大根堆</span></span><br><span class="line">    make_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h1 id="插入元素-push-heap"><a href="#插入元素-push-heap" class="headerlink" title="插入元素 push_heap"></a>插入元素 push_heap</h1><blockquote>
<p>将最后一个元素插入原来的堆中（要保证在调用push_heap前，除开最后一个数已经是一个堆），O(nlgn)<br>并且制定堆的类型要与之前构建的相同</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;                         <span class="comment">//注意是大于</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    make_heap(v1.begin(),v1.end());       <span class="comment">//默认构建大根堆</span></span><br><span class="line">    make_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    v1.push_back(<span class="number">20</span>);</span><br><span class="line">    push_heap(v1.begin(),v1.end());       <span class="comment">//同样  默认大根堆</span></span><br><span class="line">    v2.push_bavk(<span class="number">20</span>);</span><br><span class="line">    push_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="删除元素-pop-heap"><a href="#删除元素-pop-heap" class="headerlink" title="删除元素 pop_heap"></a>删除元素 pop_heap</h1><blockquote>
<p>交换首尾元素，然后将除了最后一个元素的部分重新调整成堆。<br>要保证在调用pop_heap前已经是一个堆<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;                         <span class="comment">//注意是大于</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    make_heap(v1.begin(),v1.end());       <span class="comment">//默认构建大根堆</span></span><br><span class="line">    make_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    pop_heap(v1.begin(),v1.end());       <span class="comment">//同样  默认大根堆</span></span><br><span class="line">    v1.pop_back();                       <span class="comment">//删除最后一个元素</span></span><br><span class="line">    pop_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line">    v2.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h1 id="堆排序-sort-heap"><a href="#堆排序-sort-heap" class="headerlink" title="堆排序 sort_heap"></a>堆排序 sort_heap</h1><blockquote>
<p>在原来已经是堆的情况下调用进行排序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;                         <span class="comment">//注意是大于</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    make_heap(v1.begin(),v1.end());       <span class="comment">//默认构建大根堆</span></span><br><span class="line">    make_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    sort_heap(v1.begin(),v1.end());       <span class="comment">//同样  默认大根堆         </span></span><br><span class="line">    sort_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h1 id="C-11新成员"><a href="#C-11新成员" class="headerlink" title="C++11新成员"></a>C++11新成员</h1><h2 id="判断是否为堆-is-heap"><a href="#判断是否为堆-is-heap" class="headerlink" title="判断是否为堆 is_heap"></a>判断是否为堆 is_heap</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;                         <span class="comment">//注意是大于</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    make_heap(v1.begin(),v1.end());       <span class="comment">//默认构建大根堆</span></span><br><span class="line">    make_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> judge1=is_heap(v1.begin(),v1.end());       <span class="comment">//同样  默认大根堆         </span></span><br><span class="line">    <span class="keyword">bool</span> judge2=is_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="找到第一个不构成堆的元素-is-heap-until"><a href="#找到第一个不构成堆的元素-is-heap-until" class="headerlink" title="找到第一个不构成堆的元素 is_heap_until"></a>找到第一个不构成堆的元素 is_heap_until</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;                         <span class="comment">//注意是大于</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    make_heap(v1.begin(),v1.end());       <span class="comment">//默认构建大根堆</span></span><br><span class="line">    make_heap(v2.begin(),v2.end(),cmp);   <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;:: iteraotr it=is_heap_until(v1.begin(),v1.end());         <span class="comment">//同样  默认大根堆         </span></span><br><span class="line">    vecotr&lt;<span class="keyword">int</span>&gt;:: iterator it2=is_heap_until(v2.begin(),v2.end(),cmp);    <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Mondriaan&#39;s Dream——状压dp</title>
    <url>/Mondriaan-s-Dream%E2%80%94%E2%80%94dfs-%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Squares and rectangles fascinated the famous Dutch painter Piet Mondriaan. One night, after producing the drawings in his ‘toilet series’ (where he had to use his toilet paper to draw on, for all of his paper was filled with squares and rectangles), he dreamt of filling a large rectangle with small rectangles of width 2 and height 1 in varying ways.<br><img src="../image/状压1.jpg" alt=""><br>Expert as he was in this material, he saw at a glance that he’ll need a computer to calculate the number of ways to fill the large rectangle whose dimensions were integer values, as well. Help him, so that his dream won’t turn into a nightmare!<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The input contains several test cases. Each test case is made up of two integer numbers: the height h and the width w of the large rectangle. Input is terminated by h=w=0. Otherwise, 1&lt;=h,w&lt;=11.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, output the number of different ways the given rectangle can be filled with small rectangles of size 2 times 1. Assume the given large rectangle is oriented, i.e. count symmetrical tilings multiple times.<br><img src="../image/状压.jpg" alt=""></p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1 2<br>1 3<br>1 4<br>2 2<br>2 3<br>2 4<br>2 11<br>4 11<br>0 0</li>
<li>Output<br>1<br>0<br>1<br>2<br>3<br>5<br>144<br>51205</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意很简单，就是一个n<em>m的矩阵，要求用1 </em> 2的方格来填满它，问有多少种填法</li>
<li>对于每个位置，放置方块的上半部分用1表示，其他的用0表示</li>
</ul>
<ul>
<li>当状态j,k满足以下条件时可用于转移：<ul>
<li>j&amp;k == 0，即不能一列的相邻位置都放上半部分</li>
<li>j|k中所有连续的0都必须有偶数个<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(a,i,n) printf(<span class="meta-string">"c"</span>,a,<span class="meta-string">" \n"</span>[i==n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll linf=(<span class="number">1l</span>l&lt;&lt;<span class="number">62</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=(<span class="number">1</span>&lt;&lt;<span class="number">13</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">11380</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;<span class="keyword">int</span> sign=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;c=getchar();<span class="keyword">if</span>(c==<span class="string">'-'</span>)sign=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;c=getchar();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>);</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line">ll f[N][M],can[M];</span><br><span class="line"><span class="keyword">int</span> n,m,num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>((m*n)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; (<span class="number">1</span>&lt;&lt;m); i++)&#123;</span><br><span class="line">            can[i] = <span class="number">1</span>, num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i&gt;&gt;j &amp; <span class="number">1</span>) == <span class="number">0</span>) num++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(num &amp; <span class="number">1</span>) can[i] = <span class="number">0</span>;</span><br><span class="line">                    num=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &amp; <span class="number">1</span>) can[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(f,<span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; <span class="number">1</span>&lt;&lt;m; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt; <span class="number">1</span>&lt;&lt;m; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(k &amp; j) &amp;&amp; can[k|j])</span><br><span class="line">                        f[i][j] += f[i<span class="number">-1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hie with the Pie  poj3311——Floyd+状压dp</title>
    <url>/Hie-with-the-Pie-poj3311%E2%80%94%E2%80%94Floyd-%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>The Pizazz Pizzeria prides itself in delivering pizzas to its customers as fast as possible. Unfortunately, due to cutbacks, they can afford to hire only one driver to do the deliveries. He will wait for 1 or more (up to 10) orders to be processed before he starts any deliveries. Needless to say, he would like to take the shortest route in delivering these goodies and returning to the pizzeria, even if it means passing the same location(s) or the pizzeria more than once on the way. He has commissioned you to write a program to help him.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>Input will consist of multiple test cases. The first line will contain a single integer n indicating the number of orders to deliver, where 1 ≤ n ≤ 10. After this will be n + 1 lines each containing n + 1 integers indicating the times to travel between the pizzeria (numbered 0) and the n locations (numbers 1 to n). The jth value on the ith line indicates the time to go directly from location i to location j without visiting any other locations along the way. Note that there may be quicker ways to go from i to j via other locations, due to different speed limits, traffic lights, etc. Also, the time values may not be symmetric, i.e., the time to go directly from location i to j may not be the same as the time to go directly from location j to i. An input value of n = 0 will terminate input.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each test case, you should output a single number indicating the minimum time to deliver all of the pizzas and return to the pizzeria.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3<br>0 1 10 10<br>1 0 1 2<br>10 1 0 10<br>10 2 10 0<br>0</li>
<li>Output<br>8</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给定n个点，从0开始走完这n个点然后回到0点，两个点之间的往返距离可能会不同，求最小距离</li>
<li>先用Floyd进行预处理，求出从i点到j点之间的最小距离dis[i][j]。</li>
<li>用dp[sta][i]表示在sta状态下，当前走到的最后一个点是i的最小距离，sta中1表示已经走过该点</li>
<li>首先我们枚举每一个状态，对当前状态sta，我们遍历sta的二进制的每一个为1的位置i（即每一个走过点），如果sta中只有一个1，即sta==(1&lt;&lt;(i-1)),则dp[sta][i]=dis[0][i],否则的话，我们取sta1=sta^(1&lt;&lt;(i-1))表示没有走过i点的上一个状态（因为sta1是必然小于sta的，所以在处理sta的时候sta1是已经处理好的数据）。对于上一个状态sta1，我们遍历其二进制中每一个为1的位置j，则dp[sta][i]=max(dp[sta][i],dp[sta1][j]+dis[j][i]),这里可以理解为是一个松弛的操作。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,dis[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">3000</span>][<span class="number">20</span>];         <span class="comment">//dp[sta][i]表示sta状态下，结尾为i的最小消费</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        INIT(dp,<span class="number">0</span>);INIT(dis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dis[i][j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预处理两两点之间的最短距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta=<span class="number">1</span>;sta&lt;(<span class="number">1</span>&lt;&lt;n);sta++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                dp[sta][i]=INF;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta=<span class="number">1</span>;sta&lt;(<span class="number">1</span>&lt;&lt;n);sta++)<span class="comment">//枚举所有状态，1表示这个位置走过</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">if</span>(sta&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))&#123;     <span class="comment">//枚举这个状态中的每一个1点，对这个点进行松弛</span></span><br><span class="line">                    <span class="keyword">if</span>(sta==(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))) dp[sta][i]=dis[<span class="number">0</span>][i];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> sta1=sta^(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));<span class="comment">//得到i点没走过的上一状态stai</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;  <span class="comment">//枚举sta1中的每一个走过的点</span></span><br><span class="line">                            <span class="keyword">if</span>(sta1&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))</span><br><span class="line">                                dp[sta][i]=min(dp[sta][i],dp[sta1][j]+dis[j][i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=min(dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]+dis[i][<span class="number">0</span>],ans);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子矩阵——dp</title>
    <url>/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E2%80%94%E2%80%94dp/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 <em> 1)子矩阵。<br>比如，如下4 </em> 4的矩阵<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4 1<br>-1 8 0 -2<br>的最大子矩阵是<br>9 2<br>-4 1<br>-1 8<br>这个子矩阵的大小是15。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出最大子矩阵的大小。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>4<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4  1<br>-1 8  0 -2</li>
<li>Output<br>15</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>用Map[i][j]来表示ij位置的矩阵前缀和。如下图（借用一波左学姐的图/xyx），要求宽为(i−j)这么宽的最大区间和，就可以把i到j行按列加到一起，然后就转换成了求<strong>一维数组最大子段和</strong>，每一个元素就是红色区域。下图矩阵a的红色区域就可以表示为: Map[i][k]−Map[i][k−1]−Map[j−1][k]+Map[j−1][k−1]。<br><img src="../image/最大子矩阵.jpg" alt=""></p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">105</span>][<span class="number">105</span>],N;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">            Map[i][j]+=(Map[i<span class="number">-1</span>][j]+Map[i][j<span class="number">-1</span>]-Map[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;Map[i][j];</span><br><span class="line">    initMap();</span><br><span class="line">    <span class="keyword">int</span> ans=MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tem=Map[i][k]-Map[i][k<span class="number">-1</span>]-Map[j<span class="number">-1</span>][k]+Map[j<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">//maxn[i]表示以a[i]为结尾的最大连续和，maxn[i]=max(a[i],maxn[i-1]+a[i]),这里不需要保存数据，直接用一个临时变量即可</span></span><br><span class="line">                res=max(res+tem,tem);</span><br><span class="line">                ans=max(res,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Maximum sum——dp</title>
    <url>/Maximum-sum%E2%80%94%E2%80%94dp/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Given a set of n integers: A={a1, a2,…, an}, we define a function d(A) as below:</p>
<pre><code>                t1     t2 
    d(A) = max{ ∑ai + ∑aj | 1 &lt;= s1 &lt;= t1 &lt; s2 &lt;= t2 &lt;= n }
               i=s1   j=s2
</code></pre><p>Your task is to calculate d(A).<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The input consists of T(&lt;=30) test cases. The number of test cases (T) is given in the first line of the input.<br>Each test case contains two lines. The first line is an integer n(2&lt;=n&lt;=50000). The second line contains n integers: a1, a2, …, an. (|ai| &lt;= 10000).There is an empty line after each case.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Print exactly one line for each test case. The line should contain the integer d(A).</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1<br>10<br>1 -1 2 2 3 -3 4 -4 5 -5</li>
<li>Output<br>13</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意就是给一个序列，找其中两个不相交的子串s1、s2，使得s1+s2最大 </li>
<li>用dpl[i]表示以i为结尾的最大子串和，用dpr[i]表示以i为开头的最大子串和，再用一个dpres[i]表示在i后面（包括i）的最大子串和，即max(dpr[j] (i &lt;= j &lt; n))。<br>状态转移方程：<br>dpl[i]=max(dpl[i-1]+num[i],num[i]);<br>dpr[i]=max(dpr[i+1]+num[i],num[i]);<br>dpres[i]=max(dpres[i+1],dpr[i]);</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dpl[<span class="number">50005</span>],dpr[<span class="number">50005</span>],num[<span class="number">50005</span>],dpres[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">	<span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        INIT(dpl,<span class="number">0</span>);INIT(dpr,<span class="number">0</span>);INIT(dpres,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line"></span><br><span class="line">        dpl[<span class="number">1</span>]=num[<span class="number">1</span>],dpr[n]=dpres[n]=num[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            dpl[i]=max(dpl[i<span class="number">-1</span>]+num[i],num[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            dpr[i]=max(dpr[i+<span class="number">1</span>]+num[i],num[i]);</span><br><span class="line">            dpres[i]=max(dpres[i+<span class="number">1</span>],dpr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans=MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            ans=max(dpres[i]+dpl[i<span class="number">-1</span>],ans);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).<br>你的任务，就是对于给定的序列，求出最长上升子序列的长度.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>最长上升子序列的长度。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>7<br>1 7 3 5 9 4 8</li>
<li>Output<br>4</li>
</ul>
</blockquote>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><blockquote>
<ul>
<li><p>法一：普通dp。用dp[i]以a[i]为结尾的最长上升子序列，则状态转移方程为：<br>dp[i]=max(dp[i],dp[j]+1)(0&lt;=j &lt; i,a[i]&gt;a[j])<br>时间复杂度 <script type="math/tex">O(n^2)</script></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n,a[<span class="number">1005</span>],dp[<span class="number">1005</span>];</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                dp[i]=max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                ans=max(dp[i],ans);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>法二：dp+二分。用dp[i]表示长为i的上升串中最小的末尾数，用len记录当前上升子序列的最大长度，当处理a[i]时，先比较a[i]和dp[len]的大小，如果a[i]&gt;dp[len]，则dp[++len]=a[i];如果a[i]&lt;=dp[len]，则在dp序列中找到第一个比a[i]大的最小末位数并用a[i]替换掉。时间复杂度<script type="math/tex">O(nlgn)</script>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N,len,a[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];<span class="comment">//dp[i]表示长为i的上升串中最小的末尾数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        dp[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>],len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[len])dp[++len]=a[i];</span><br><span class="line">        <span class="keyword">else</span> *upper_bound(dp+<span class="number">1</span>,dp+N+<span class="number">1</span>,a[i])=a[i];<span class="comment">//找到第一个比a[i]大的最小末尾数并替换</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>法三：dp+树状数组。在<script type="math/tex">O(n^2)</script>的DP中，dp[i]=max(dp[j])+1(0&lt;=j &lt; i,a[i]&gt;a[j])。现在我们用树状数组来维护dp[j]的最大值（a[i]&gt;a[j]），这样的话查找max(dp[j])的复杂度就从O(n)降到了O(lgn).但是我们在用树状数组处理之前，对a数组进行排序（注意先保存各个数的位置）。时间复杂度O(nlgn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>],N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,key;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Num&amp; e)<span class="keyword">const</span>&#123;<span class="keyword">return</span> val==e.val?key&gt;e.key:val&lt;e.val;&#125;</span><br><span class="line">    <span class="comment">//数值相同序号大的放前面，防止相等</span></span><br><span class="line">&#125;num[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> New)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=N;x+=lowbit(x))</span><br><span class="line">        dp[x]=max(dp[x],New);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=MIN;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=lowbit(x))</span><br><span class="line">       res=max(res,dp[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num[i].val;</span><br><span class="line">        num[i].key=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num+<span class="number">1</span>,num+N+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> Max=que(num[i].key);<span class="comment">//找到编号小于num[i].key的最长上升子序列大小</span></span><br><span class="line">        update(num[i].key,++Max);<span class="comment">//长度+1，然后更新后面，因为num有序，所以保证能够接在后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;<span class="number">0</span>;i-=lowbit(i))</span><br><span class="line">        ans=max(ans,dp[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title>炮兵布阵(状压dp)</title>
    <url>/%E7%82%AE%E5%85%B5%E5%B8%83%E9%98%B5-%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[<h1 id="传送门-poj1185"><a href="#传送门-poj1185" class="headerlink" title="传送门 poj1185"></a>传送门 <a href="http://poj.org/problem?id=1185" target="_blank" rel="noopener">poj1185</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>司令部的将军们打算在NxM的网格地图上部署他们的炮兵部队。一个NxM的地图由N行M列组成，地图的每一格可能是山地（用”H” 表示），也可能是平原（用”P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：<br><img src="../image/炮兵.jpg" alt=""><br>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。<br>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>第一行包含两个由空格分割开的正整数，分别表示N和M；<br>接下来的N行，每一行含有连续的M个字符(‘P’或者’H’)，中间没有空格。按顺序表示地图中每一行的数据。N &lt;= 100；M &lt;= 10。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5 4<br>PHPP<br>PPHH<br>PPPP<br>PHPP<br>PHHP</li>
<li>Output<br>6</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>跟前面的玉米地类似，但是这道题不仅要跟上一行进行比较，还要跟上上行进行比较。</li>
<li>我们用数组sta来存放所有不会产生横向冲突的状态，用数组num来存放每个状态所对应的炮兵数，用dp[i][stai][pre]表示第i行中第stai个状态、i-1行pre状态下的炮兵最大数，用dp[i-1][pre][prepre]表示i-1行pre状态、i-2行prepre状态下的炮兵最大数，中间需要判断stai、pre、以及prepre三种状态之间是否相互冲突。状态转移方程为：<br>dp[i][stai][pre]=max(dp[i][stai][pre],dp[i-1][pre][prepre]+num[stai])</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(a,i,n) printf(<span class="meta-string">"%d%c"</span>,a,<span class="meta-string">" \n"</span>[i==n])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll linf=(<span class="number">1l</span>l&lt;&lt;<span class="number">62</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">120</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;<span class="keyword">int</span> sign=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;c=getchar();<span class="keyword">if</span>(c==<span class="string">'-'</span>)sign=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;c=getchar();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>);</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cant[N],f[N][M][M];</span><br><span class="line"><span class="keyword">int</span> sta[M],tot=<span class="number">0</span>,num[M];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &amp; cant[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &amp; cant[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(z &amp; cant[i<span class="number">-2</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;y || y&amp;z || x&amp;z) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    rep(i,<span class="number">3</span>,n+<span class="number">2</span>)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">        rep(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getchar() == <span class="string">'H'</span>)</span><br><span class="line">                cant[i] += (<span class="number">1</span>&lt;&lt;(m-j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1</span>&lt;&lt;m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((i&lt;&lt;<span class="number">1</span>)&amp;i) || ((i&lt;&lt;<span class="number">2</span>)&amp;i)) <span class="keyword">continue</span>;</span><br><span class="line">        sta[++tot] = i;</span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            num[tot] += k&amp;<span class="number">1</span>;</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">3</span>,n+<span class="number">2</span>)</span><br><span class="line">        rep(x,<span class="number">1</span>,tot)</span><br><span class="line">            rep(y,<span class="number">1</span>,tot)</span><br><span class="line">                rep(z,<span class="number">1</span>,tot)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!check(i,sta[x],sta[y],sta[z])) <span class="keyword">continue</span>;</span><br><span class="line">                    f[i][x][y] = max(f[i][x][y], f[i<span class="number">-1</span>][y][z] + num[x]);</span><br><span class="line">                    <span class="keyword">if</span>(i == n+<span class="number">2</span>) ans = max(ans, f[i][x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Most Powerful(状压dp)</title>
    <url>/Most-Powerful-%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[<h1 id="传送门-zoj3471"><a href="#传送门-zoj3471" class="headerlink" title="传送门 zoj3471"></a>传送门 <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3471" target="_blank" rel="noopener">zoj3471</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>Recently, researchers on Mars have discovered N powerful atoms. All of them are different. These atoms have some properties. When two of these atoms collide, one of them disappears and a lot of power is produced. Researchers know the way every two atoms perform when collided and the power every two atoms can produce.<br>You are to write a program to make it most powerful, which means that the sum of power produced during all the collides is maximal.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>There are multiple cases. The first line of each case has an integer N (2 &lt;= N &lt;= 10), which means there are N atoms: A1, A2, … , AN. Then N lines follow. There are N integers in each line. The j-th integer on the i-th line is the power produced when Ai and Aj collide with Aj gone. All integers are positive and not larger than 10000.<br>The last case is followed by a 0 in one line.<br>There will be no more than 500 cases including no more than 50 large cases that N is 10.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Output the maximal power these N atoms can produce in a line for each case.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2<br>0 4<br>1 0<br>3<br>0 20 1<br>12 0 1<br>1 10 0<br>0</li>
<li>Output<br>4<br>22</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：有n个原子，原子i碰撞j可产生能量w[i][j]，然后被撞原子j会消失。给出原子数n和所有的w[i][j]，求出能产生的最大能量</li>
<li>我们用sta=0到sta=1&lt;&lt;n-1来表示碰撞过程中所有的状态，1表示原子存在，0表示消失。用dp[sta]来表示当前状态下能达到的最大能量值，那么当只剩下一个原子p的时候，dp[1&lt;&lt;p]就是只剩p时的最大能量值。枚举每一种状态，在该状态下枚举两个存在的原子i和j，用i去碰撞j，状态转移方程为： <strong>dp[sta^(1&lt;&lt;j)]=max(dp[sta^(1&lt;&lt;j)],dp[sta]+w[i][j])</strong></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">        INIT(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;w[i][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;sta&gt;=<span class="number">0</span>;sta--)<span class="comment">//(1)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="keyword">if</span>(sta&amp;(<span class="number">1</span>&lt;&lt;i))<span class="comment">//第i个原子存在</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                        <span class="keyword">if</span>((sta&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;(i!=j))<span class="comment">//第j个原子存在且不是i</span></span><br><span class="line">                            dp[sta^(<span class="number">1</span>&lt;&lt;j)]=max(dp[sta^(<span class="number">1</span>&lt;&lt;j)],dp[sta]+w[i][j]);</span><br><span class="line">        <span class="keyword">int</span> Max=MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//枚举只剩下一个原子的状态并找到最大值</span></span><br><span class="line">            Max=max(Max,dp[<span class="number">1</span>&lt;&lt;i]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;Max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*因为后面是用dp[sta]来推出dp[sta^(1&lt;&lt;j)]，很明显前面的数是比后面大的，所以注释(1)处需要反向枚举状态*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Corn Fields(状压dp模板题)</title>
    <url>/Corn-Fields-%E7%8A%B6%E5%8E%8Bdp%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
    <content><![CDATA[<h1 id="传送门-poj-3254"><a href="#传送门-poj-3254" class="headerlink" title="传送门 poj 3254"></a>传送门 <a href="http://poj.org/problem?id=3254" target="_blank" rel="noopener">poj 3254</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p>
<p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>Line 1: Two space-separated integers: M and N<br>Lines 2..M+1: Line i+1 describes row i of the pasture with N space-separated integers indicating whether a square is fertile (1 for fertile, 0 for infertile)</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>Line 1: One integer: the number of ways that FJ can choose the squares modulo 100,000,000.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2 3<br>1 1 1<br>0 1 0</li>
<li>Output<br>9</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>友情翻译一波：农夫有一块地，被划分为m行n列大小相等的格子，其中一些格子是可以种植的（用1标记），农夫可以在这些格子里种上玉米，其他格子则不能种植（用0标记），并且要求不可以使相邻格子都玉米。现在输入数据给出这块地的大小及可否种植的情况，求该农夫有多少种种植方案可以选择（注意：任何格子都不放也是一种选择，不要忘记考虑！</li>
<li>思路：<br>样例第一行状态数：</li>
</ul>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th style="text-align:center">状压（压缩前）</th>
<th style="text-align:right">状态（压缩后）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">0 0 0</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">0 0 1</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">0 1 0</td>
<td style="text-align:right">2</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">1 0 0</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">1 0 1</td>
<td style="text-align:right">5</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>我们用1表示在这块地上种上了玉米，用0表示没有种植玉米，这样我们就可以用0和1表示每一行的所有状态，也就是每一种状态可以用一个二进制数表示。当我们需要对状态之间进行处理，即判断是否有两块地相邻时，我们判断是否有两个1相邻即可。但这种方法未免太过复杂，并且时间也不允许，所以我们对于每一种状态，用一个十进制数替换掉它所对应的二进制数。</li>
<li>当我们要判断一行的某种状态a是否有两个玉米相邻的时候，我们只需要将这个十进制数a左移一位，然后对原来的数进行&amp;运算( a &amp; (a&lt;&lt;1) )，若得到的结果不为0，则有两个玉米相邻。</li>
<li>当我们要判断当前行的某种状态a是否与上一行的某种状态b有冲突（即列相邻）时，只需要判断 a &amp; b是否为零即可。</li>
<li>我们用dp[i][j]表示第i行第j种可行状态与前面有多少种组合方式，状态转移方程为：dp[i][j]=dp[i-1][k1]+dp[i-1][k2]+…+dp[i-1][kt]。kt为上一行可行方案的编号，共有t种（前提是状态之间不会冲突）。<br>若第i行有num种可行方案，则从1到i行的总的可行方案就有dp[i][1]+dp[i][2]+…+dp[i][num]种。那么从1到m行的可行方案总和就是dp[m][1]+dp[m][2]+…+dp[m][num]种。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Min=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> state[<span class="number">5000</span>],cant[<span class="number">20</span>];                                  <span class="comment">//所有可行状态和不能放的状态</span></span><br><span class="line"><span class="keyword">int</span> Num;                                                   <span class="comment">//可行状态数</span></span><br><span class="line"><span class="keyword">int</span> M,N;                                                   <span class="comment">//M行N列</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">1000</span>];                                          <span class="comment">//dp[i][j]:第i行第j种状态的情况数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindState</span><span class="params">()</span></span>&#123;                                          <span class="comment">//排除掉有相邻1的状态</span></span><br><span class="line">    Num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> all=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;all;i++)                                 <span class="comment">//不能包括all，因为all比要求多一位</span></span><br><span class="line">        <span class="keyword">if</span>((i&amp;(i&lt;&lt;<span class="number">1</span>))==<span class="number">0</span>)                                  <span class="comment">//(i&amp;(i&lt;&lt;1))  ==优先级比&amp;高</span></span><br><span class="line">            state[++Num]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span>&#123;                            <span class="comment">//排除包含禁止种植区域的状态</span></span><br><span class="line">    <span class="keyword">if</span>(x&amp;cant[i])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N)&#123;</span><br><span class="line">        FindState();INIT(cant,<span class="number">0</span>);INIT(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> tem;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;                         <span class="comment">//储存每一行不能放的状态</span></span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;tem;</span><br><span class="line">                <span class="keyword">if</span>(tem==<span class="number">0</span>)</span><br><span class="line">                    cant[i]+=(<span class="number">1</span>&lt;&lt;(N-j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Num;i++)                            <span class="comment">//处理第一行</span></span><br><span class="line">            <span class="keyword">if</span>(Judge(state[i],<span class="number">1</span>))</span><br><span class="line">                dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)&#123;                             <span class="comment">//枚举每一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Num;j++)&#123;                       <span class="comment">//枚举第i行的所有状态</span></span><br><span class="line">                <span class="keyword">if</span>(!Judge(state[j],i))<span class="keyword">continue</span>;            <span class="comment">//若这些状态里面跟cant[i]有重合部分则continue</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=Num;k++)&#123;                   <span class="comment">//枚举第i-1行的所有状态</span></span><br><span class="line">                    <span class="keyword">if</span>(!Judge(state[k],i<span class="number">-1</span>))<span class="keyword">continue</span>;      <span class="comment">//若这些状态里面跟cant[i-1]有重合部分则continue</span></span><br><span class="line">                    <span class="keyword">if</span>(state[k]&amp;state[j])<span class="keyword">continue</span>;         <span class="comment">//若有上下相邻 则continue</span></span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k])%Mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Num;i++)</span><br><span class="line">            ans=(ans+dp[M][i])%Mod;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix (二维树状数组)</title>
    <url>/Matrix-%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="传送门：POJ-2155"><a href="#传送门：POJ-2155" class="headerlink" title="传送门：POJ - 2155"></a>传送门：<a href="https://vjudge.net/contest/244678#problem/E" target="_blank" rel="noopener">POJ - 2155</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>Given an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N).<br>We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. </p>
<ol>
<li>C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2). </li>
<li>Q x y (1 &lt;= x, y &lt;= n) querys A[x, y]. <a id="more"></a>
</li>
</ol>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line of the input is an integer X (X &lt;= 10) representing the number of test cases. The following X blocks each represents a test case.<br>The first line of each block contains two numbers N and T (2 &lt;= N &lt;= 1000, 1 &lt;= T &lt;= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format “Q x y” or “C x1 y1 x2 y2”, which has been described above. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For each querying output one line, which has an integer representing A[x, y].<br>There is a blank line between every two continuous test cases. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>1<br>2 10<br>C 2 1 2 2<br>Q 2 2<br>C 2 1 2 1<br>Q 1 1<br>C 1 1 2 1<br>C 1 2 1 2<br>C 1 1 2 2<br>Q 1 1<br>C 1 1 2 1<br>Q 2 1</li>
<li>Output<br>1<br>0<br>0<br>1</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：<br>C——以(x1,y1)为左上角，(x2,y2)为右上角的矩阵，每个元素01取反<br>Q——询问(x,y)的值</li>
<li>结合矩阵翻转，将区间修改单点查询转变成单点修改区间求和。</li>
<li>用二维树状数组保存点的修改次数，修改的时候进行如下操作：<br><img src="../image/二维浅醉he.jpg" alt=""><br>黄色部分为本次需要修改的区间，我们对四个绿色点进行add操作，也就是将每个绿色点右下角部分的矩阵进行翻转，这样我们进行四次单点修改就完成了整个区间的修改。而要查询某个点的值时，求出它的翻转次数即可</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>); </span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N,M,tree[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=N;i+=lowbit(i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;=N;j+=lowbit(j))</span><br><span class="line">            tree[i][j]+=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;<span class="number">0</span>;j-=lowbit(j))</span><br><span class="line">            sum+=tree[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _,x1,y1,x2,y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)&#123;</span><br><span class="line">        INIT(tree,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="keyword">char</span> x;</span><br><span class="line">        <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="string">'C'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">                add(x1,y1,<span class="number">1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>,y1,<span class="number">1</span>);</span><br><span class="line">                add(x1,y2+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>,y2+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x1,&amp;y1);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count(x1,y1)%<span class="number">2</span>);</span><br><span class="line">            &#125;			</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(M)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobile phones(二维树状数组)</title>
    <url>/Mobile-phones-%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="传送门：Poj-1195"><a href="#传送门：Poj-1195" class="headerlink" title="传送门：Poj-1195"></a>传送门：<a href="https://vjudge.net/contest/244678#problem/D" target="_blank" rel="noopener">Poj-1195</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>Suppose that the fourth generation mobile phone base stations in the Tampere area operate as follows. The area is divided into squares. The squares form an S * S matrix with the rows and columns numbered from 0 to S-1. Each square contains a base station. The number of active mobile phones inside a square can change because a phone is moved from a square to another or a phone is switched on or off. At times, each base station reports the change in the number of active phones to the main base station along with the row and the column of the matrix.<br>Write a program, which receives these reports and answers queries about the current total number of active mobile phones in any rectangle-shaped area.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input is read from standard input as integers and the answers to the queries are written to standard output as integers. The input is encoded as follows. Each input comes on a separate line, and consists of one instruction integer and a number of parameter integers according to the following table.<br><img src="../image/二维树状数组.png" alt=""><br>The values will always be in range, so there is no need to check them. In particular, if A is negative, it can be assumed that it will not reduce the square value below zero. The indexing starts at 0, e.g. for a table of size 4 <em> 4, we have 0 &lt;= X &lt;= 3 and 0 &lt;= Y &lt;= 3.<br>Table size: 1 </em> 1 &lt;= S <em> S &lt;= 1024 </em> 1024<br>Cell value V at any time: 0 &lt;= V &lt;= 32767<br>Update amount: -32768 &lt;= A &lt;= 32767<br>No of instructions in input: 3 &lt;= U &lt;= 60002<br>Maximum number of phones in the whole table:$M=2^{30}$</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>0 4<br>1 1 2 3<br>2 0 0 2 2<br>1 1 1 2<br>1 1 2 -1<br>2 1 1 2 3<br>3</li>
<li>Output<br>3<br>4</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意： 1——在(x,y)加上A ；  2——求左上角为(L,B)，右下角为(R,T)的矩阵和</li>
<li>裸的二维树状数组。二维数组的思路和一维类似，一维中第x个元素的值为x的前缀和，而二维中(x,y)的值为以(0,0)为左上角，以(x,y)为右下角的矩阵和(这里的求和都是以树状数组lowbit规则计算的)。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://vjudge.net/contest/244678#problem/D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">1030</span>][<span class="number">1030</span>];</span><br><span class="line"><span class="keyword">int</span> que,s,x,y,a,l,b,r,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=s;i+=lowbit(i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&lt;=s;j+=lowbit(j))</span><br><span class="line">            tree[i][j]+=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i-=lowbit(i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;<span class="number">0</span>;j-=lowbit(j))</span><br><span class="line">            cnt+=tree[i][j];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;que))&#123;</span><br><span class="line">        <span class="keyword">if</span>(que==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">            INIT(tree,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(que==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;a);</span><br><span class="line">            x++;y++;</span><br><span class="line">            update(x,y,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(que==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;l,&amp;b,&amp;r,&amp;t);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum(r+<span class="number">1</span>,t+<span class="number">1</span>)-sum(r+<span class="number">1</span>,b)-sum(l,t+<span class="number">1</span>)+sum(l,b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>I hate it</title>
    <url>/I%20hate%20it%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC/</url>
    <content><![CDATA[<h1 id="传送门I-Hate-It"><a href="#传送门I-Hate-It" class="headerlink" title="传送门I Hate It"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="noopener">I Hate It</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。<br>这让很多学生很反感。<br>不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>本题目包含多组测试，请处理到文件结束。<br>在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。<br>学生ID编号分别从1编到N。<br>第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。<br>接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。<br>当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。<br>当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每一次询问操作，在一行里面输出最高成绩。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5 6<br>1 2 3 4 5<br>Q 1 5<br>U 3 6<br>Q 3 4<br>Q 4 5<br>U 2 9<br>Q 1 5</li>
<li>Output<br>5<br>6<br>5<br>9</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>更新：与维护区间和无太大差异，将tree[x]+=val改成tree[x]=max(tree[x],val)即可</li>
<li>查询：此处查询[l,r]必然不能像区间求和一样找l和r的前缀和相减。显然，我们要避开[1-l]。<br><img src="../image/树状数组.jpg" alt=""><br>我们根据lowbit的规则，从右向左遍历区间块，如果区间lowbit(x)在我们要考虑的范围内就取这个区间最大值tree[x]，如果发现当前的区间超出我们要考虑的范围就只取当前区间最末尾的值num[x]，然后x - 1，然后继续从右向左遍历，直到所有区间取完为止。</li>
<li>根据上图的步骤，下标为12的这个位置是 9 到 12的最大值，我们能通过lowbit知道当前区间的长度是多少，由此能知道当前区间是不是在我们要考虑的范围内；当遇到下标为8，区间长度大于当前我们要考虑的长度时，我们就只取最末尾的值，也就是对应数组a[8]，lowbit - 1 到下标为7这个位置后继续从右向左判断，直到结束。 从图中可以很容易发现，以这种方式遍历，能把所有我们需要考虑的部分都遍历了一遍。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Min=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> num[maxn],tree[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">		tree[x]=max(tree[x],val);</span><br><span class="line">		x+=lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=r-l+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=Min;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(lowbit(r)&lt;=len)&#123;</span><br><span class="line">			ans=max(ans,tree[r]);</span><br><span class="line">			len-=lowbit(r);</span><br><span class="line">			r-=lowbit(r);               <span class="comment">//注意先后顺序</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans=max(ans,num[r]);</span><br><span class="line">			r--,len--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		INIT(tree,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">			update(i,num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span> c;<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%c %d %d"</span>,&amp;c,&amp;l,&amp;r);</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="string">'U'</span>)&#123;</span><br><span class="line">				num[l]=r;</span><br><span class="line">				update(l,r);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l,r));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Stars(树状数组)</title>
    <url>/Stars-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="传送门Stars"><a href="#传送门Stars" class="headerlink" title="传送门Stars "></a>传送门<a href="https://vjudge.net/problem/14610/origin" target="_blank" rel="noopener">Stars </a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>Astronomers often examine star maps where stars are represented by points on a plane and each star has Cartesian coordinates. Let the level of a star be an amount of the stars that are not higher and not to the right of the given star. Astronomers want to know the distribution of the levels of the stars.<br><img src="../image/二维偏序.jpg" alt=""><br>For example, look at the map shown on the figure above. Level of the star number 5 is equal to 3 (it’s formed by three stars with a numbers 1, 2 and 4). And the levels of the stars numbered by 2 and 4 are 1. At this map there are only one star of the level 0, two stars of the level 1, one star of the level 2, and one star of the level 3.<br>You are to write a program that will count the amounts of the stars of each level on a given map.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The first line of the input file contains a number of stars N (1&lt;=N&lt;=15000). The following N lines describe coordinates of stars (two integers X and Y per line separated by a space, 0&lt;=X,Y&lt;=32000). There can be only one star at one point of the plane. Stars are listed in ascending order of Y coordinate. Stars with equal Y coordinates are listed in ascending order of X coordinate. </p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>The output should contain N lines, one number per line. The first line contains amount of stars of the level 0, the second does amount of stars of the level 1 and so on, the last line contains amount of stars of the level N-1.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5<br>1 1<br>5 1<br>7 1<br>3 3<br>5 5</li>
<li>Output<br>1<br>2<br>1<br>1<br>0</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意就是每个星星有一个坐标，如果在一颗星星左下角有k个星星，那么这颗星星就是第k级。现在给定n个星星的坐标，且给定的条件中星星的y坐标递增，求出0到n-1每一级的星星的个数。</li>
<li>对于当前的星星，统计前面x比它小的星星个数，就是他的级数</li>
<li>由于时间复杂度的关系，这里要用到树状数组。用star[x]保存横坐标覅为x的星星的出现次数，对于每个星星，求一次前缀和即可。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;<span class="keyword">int</span> tree[<span class="number">40000</span>];<span class="keyword">int</span> num[<span class="number">40000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;<span class="number">40000</span>)&#123;</span><br><span class="line">        tree[x]+=p;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        t+=tree[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        INIT(tree,<span class="number">0</span>);INIT(num,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            x++;</span><br><span class="line">            num[sum(x)]++;</span><br><span class="line">            add(x,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Ultra-QuickSort(树状数组+逆序数)</title>
    <url>/Ultra-QuickSort-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E9%80%86%E5%BA%8F%E6%95%B0/</url>
    <content><![CDATA[<h1 id="传送门-POJ2299"><a href="#传送门-POJ2299" class="headerlink" title="传送门 POJ2299"></a>传送门 <a href="http://poj.org/problem?id=2299" target="_blank" rel="noopener">POJ2299</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence<br>9 1 0 5 4 ,<br>Ultra-QuickSort produces the output<br>0 1 4 5 9 .<br>Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0</li>
<li>Output<br>6<br>0</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>题意：给你一个整型数组，用相邻两个元素两两交换的方式使得整个数列从小到大排列，求出需要交换的次数</li>
<li>题意简单来说就是用冒泡排序需要交换多少次，但是我们都知道冒泡排序的时间复杂度是<script type="math/tex">O(n^2)</script>，暴力模拟肯定是会超时的。通过观察我们不难发现，交换次数的总和其实就是数列的逆序数之和(所谓逆序数就是在该元素之前比他大的元素个数)，所以我们求出每一个元素的逆序数然后加起来就可以求出总共的交换次数。</li>
</ul>
<ul>
<li>在序列a的<strong>数组范围</strong>上建立树状数组，初始化全为0。倒序扫描给定的序列a，对每个a[i]：<ul>
<li>在树状数组中查询前缀和[1,a[i]-1]（a[i]后有多少个比他小的数），累加到答案ans中；</li>
<li>执行”单点增加”操作，即把位置a[i]上的数+1，相当于t[a[i]]++，同时维护t的前缀和，表示a[i]又出现了一次。</li>
</ul>
</li>
</ul>
<ul>
<li>数据过大需要离散化。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(d) scanf(<span class="meta-string">"%d"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLL(d) scanf(<span class="meta-string">"%lld"</span>,&amp;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(d) printf(<span class="meta-string">"%d\n"</span>,d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL(d) printf(<span class="meta-string">"%lld\n"</span>,d)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=m;x+=lowbit(x))</span><br><span class="line">        c[x]+=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=lowbit(x))</span><br><span class="line">        ans+=c[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        INIT(c,<span class="number">0</span>);</span><br><span class="line">        rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">        m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        repd(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,a[i])-b;</span><br><span class="line">            ans+=query(t<span class="number">-1</span>);</span><br><span class="line">            add(t,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组 逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title>一个人的旅行（链式向前星spfa）</title>
    <url>/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%97%85%E8%A1%8C%EF%BC%88%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9Fspfa%EF%BC%89/</url>
    <content><![CDATA[<h1 id="传送门-HDU2066"><a href="#传送门-HDU2066" class="headerlink" title="传送门 HDU2066"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2066" target="_blank" rel="noopener">HDU2066</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br>接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)<br>接着的第T+1行有S个数，表示和草儿家相连的城市；<br>接着的第T+2行有D个数，表示草儿想去地方。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>输出草儿能去某个喜欢的城市的最短时间。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>6 2 3<br>1 3 5<br>1 4 7<br>2 8 12<br>3 8 4<br>4 9 12<br>9 10 2<br>1 2<br>8 9 10</li>
<li>Output<br>9</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>单源最短路，相邻城市与家建权值为零的边</li>
<li>spfa求家到个点的最短路，然后找满足答案的值</li>
<li>链式向前星存图</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> To,Dis,Next;&#125;;<span class="comment">//指向的节点，长度，上一条进入的边 </span></span><br><span class="line">Edge AE[<span class="number">1111</span>];<span class="keyword">int</span> top=<span class="number">0</span>;<span class="comment">//存储所有的边 </span></span><br><span class="line"><span class="keyword">int</span> Begin[<span class="number">1111</span>];<span class="comment">//每个节点的最新进入的边 </span></span><br><span class="line"><span class="keyword">int</span> used[<span class="number">1111</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1111</span>];</span><br><span class="line"><span class="keyword">int</span> T,S,D;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	AE[top]=(Edge)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">	Begin[x]=top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; road;</span><br><span class="line">	road.push(t);dis[t]=<span class="number">0</span>;used[t]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!road.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> now=road.front();used[now]=<span class="number">0</span>;road.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[now];i!=<span class="number">-1</span>;i=AE[i].Next )&#123;</span><br><span class="line">			<span class="keyword">int</span> ne=AE[i].To ;</span><br><span class="line">			<span class="keyword">if</span>(dis[ne]&gt;dis[now]+AE[i].Dis )&#123;</span><br><span class="line">				dis[ne]=dis[now]+AE[i].Dis;</span><br><span class="line">				<span class="keyword">if</span>(!used[ne])used[ne]=<span class="number">1</span>,road.push(ne);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,w;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;T,&amp;S,&amp;D))&#123;</span><br><span class="line">		INIT(Begin,<span class="number">-1</span>);INIT(used,<span class="number">0</span>);INIT(dis,<span class="number">127</span>);top=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">			add(x,y,w);</span><br><span class="line">			add(y,x,w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">			add(<span class="number">0</span>,x,<span class="number">0</span>);</span><br><span class="line">			add(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		spfa(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> ans=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;D;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">			ans=min(ans,dis[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路——Dijkstra+优先队列</title>
    <url>/%E6%9C%80%E7%9F%AD%E8%B7%AF%E2%80%94%E2%80%94Dijkstra+%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="传送门HDU2544"><a href="#传送门HDU2544" class="headerlink" title="传送门HDU2544"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544" target="_blank" rel="noopener">HDU2544</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2 1<br>1 2 3<br>3 3<br>1 2 5<br>2 3 5<br>3 1 2<br>0 0</li>
</ul>
</blockquote>
<ul>
<li>Output<br>3<br>2</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>链式向前星+Dijkstra+优先队列。通过优先队列取到每次距原点最近的点，通过这个点进行松弛</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w,next;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;<span class="comment">//点v,原点到点v的距离</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;e)<span class="keyword">const</span> &#123;<span class="keyword">return</span> w&gt;e.w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,Begin[maxn],dis[maxn],n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[tot]=(Edge)&#123;y,w,Begin[x]&#125;;</span><br><span class="line">    Begin[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=inf;</span><br><span class="line">    dis[t]=<span class="number">0</span>;</span><br><span class="line">    que.push((Node)&#123;t,dis[t]&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        Node now=que.top();que.pop();</span><br><span class="line">        <span class="keyword">int</span> x=now.v;          <span class="comment">//距离最小点x</span></span><br><span class="line">        <span class="keyword">if</span>(dis[x]!=now.w)<span class="keyword">continue</span>;           <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Begin[x];~i;i=e[i].next)&#123;   <span class="comment">//通过x进行松弛</span></span><br><span class="line">            <span class="keyword">int</span> ne=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[ne]&gt;dis[x]+e[i].w)&#123;</span><br><span class="line">                dis[ne]=dis[x]+e[i].w;</span><br><span class="line">                que.push((Node)&#123;ne,dis[ne]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;(n||m))&#123;</span><br><span class="line">        INIT(Begin,<span class="number">-1</span>);tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            Add(x,y,w);</span><br><span class="line">            Add(y,x,w);</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路——SPFA</title>
    <url>/%E6%9C%80%E7%9F%AD%E8%B7%AF%E2%80%94%E2%80%94SPFA/</url>
    <content><![CDATA[<h1 id="传送门HDU1874"><a href="#传送门HDU1874" class="headerlink" title="传送门HDU1874"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU1874</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。<br>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1. </p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3 3<br>0 1 1<br>0 2 3<br>1 2 1<br>0 2<br>3 1<br>0 1 1<br>1 2</li>
<li>Output<br>2<br>-1</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>spfa——设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，通过该点的每一条边对下一个点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。<br>松弛操作的原理是著名的定理：“三角形两边之和大于第三边”，在信息学中我们叫它三角不等式。所谓对结点i,j进行松弛，就是判定是否dis[j]&gt;dis[i]+w[i,j]，如果该式成立则将dis[j]减小到dis[i]+w[i,j]，否则不动。</li>
<li>和广搜bfs的区别：<br>SPFA 在形式上和广度(宽度)优先搜索非常类似，不同的是bfs中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进(重新入队)，于是再次用来改进其它的点，这样反复迭代下去。</li>
<li>存储方式——邻接表</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> weigh;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; Node[<span class="number">220</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">220</span>];<span class="keyword">bool</span> used[<span class="number">220</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">220</span>;i++)&#123;dis[i]=INF;used[i]=<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Road;</span><br><span class="line">    used[a]=<span class="literal">true</span>;Road.push(a);dis[a]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Road.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=Road.front();used[now]=<span class="literal">false</span>;Road.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[now].size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[Node[now][i].next]&gt;dis[now]+Node[now][i].weigh)&#123;</span><br><span class="line">                dis[Node[now][i].next]=dis[now]+Node[now][i].weigh;</span><br><span class="line">                <span class="keyword">if</span>(!used[Node[now][i].next])&#123;</span><br><span class="line">                    used[Node[now][i].next]=<span class="literal">true</span>;</span><br><span class="line">                    Road.push(Node[now][i].next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> a,b,w,S,T;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">220</span>;i++)</span><br><span class="line">            Node[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">            Edge Temp=(Edge)&#123;b,w&#125;;</span><br><span class="line">            Node[a].push_back(Temp);</span><br><span class="line">            Temp=(Edge)&#123;a,w&#125; ;</span><br><span class="line">            Node[b].push_back(Temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;S&gt;&gt;T;</span><br><span class="line">        spfa(S);</span><br><span class="line">        <span class="keyword">if</span>(dis[T]==INF)<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[T]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>棋盘游戏(特殊建图匈牙利)</title>
    <url>/%E6%A3%8B%E7%9B%98%E6%B8%B8%E6%88%8F-%E7%89%B9%E6%AE%8A%E5%BB%BA%E5%9B%BE%E5%8C%88%E7%89%99%E5%88%A9/</url>
    <content><![CDATA[<h1 id="传送门HDU-1281"><a href="#传送门HDU-1281" class="headerlink" title="传送门HDU 1281"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1281" target="_blank" rel="noopener">HDU 1281</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>小希和Gardon在玩一个游戏：对一个N*M的棋盘，在格子里放尽量多的一些国际象棋里面的“车”，并且使得他们不能互相攻击，这当然很简单，但是Gardon限制了只有某些格子才可以放，小希还是很轻松的解决了这个问题（见下图）注意不能放车的地方不影响车的互相攻击。<br>所以现在Gardon想让小希来解决一个更难的问题，在保证尽量多的“车”的前提下，棋盘里有些格子是可以避开的，也就是说，不在这些格子上放车，也可以保证尽量多的“车”被放下。但是某些格子若不放子，就无法保证放尽量多的“车”，这样的格子被称做重要点。Gardon想让小希算出有多少个这样的重要点，你能解决这个问题么？<br><img src="../image/棋.jpg" alt=""><br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>输入包含多组数据，<br>第一行有三个数N、M、K(1&lt;N,M&lt;=100 1&lt;K&lt;=N*M)，表示了棋盘的高、宽，以及可以放“车”的格子数目。接下来的K行描述了所有格子的信息：每行两个数X和Y，表示了这个格子在棋盘中的位置。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对输入的每组数据，按照如下格式输出：<br>Board T have C important blanks for L chessmen.</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3 3 4<br>1 2<br>1 3<br>2 1<br>2 2<br>3 3 4<br>1 2<br>1 3<br>2 1<br>3 2</li>
<li>Output<br>Board 1 have 0 important blanks for 2 chessmen.<br>Board 2 have 3 important blanks for 3 chessmen.</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>我们把行和列分开看成两个点集，可以放棋子的格子就看作两点（某行和某列）之间的对应关系，这样的话就形成一个二分图，如果有两个棋子能相互攻击的话就说明他们在同一行或者同一列，所以该图的最大匹配就是最多能放的棋子个数。然而题中所说的重要点的意思就是，如果去掉这一个格子（也就是二分图中一条边），二分图的最大匹配就会减少。我们只需要枚举每一个格子求出删掉它后的最大匹配值，如果算出来比一开始的最大匹配小，那么这个格子就是重要点</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> line[<span class="number">505</span>][<span class="number">505</span>],used[<span class="number">505</span>],another[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(line[x][i]==<span class="number">1</span>&amp;&amp;used[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            used[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(another[i]==<span class="number">0</span>||find(another[i]))&#123;</span><br><span class="line">                another[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(used,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(find(i))sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> k,x[<span class="number">10005</span>],y[<span class="number">10005</span>],_=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(another,<span class="number">0</span>);INIT(line,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">            line[x[i]][y[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> all=count(),sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            line[x[i]][y[i]]=<span class="number">0</span>;</span><br><span class="line">            INIT(another,<span class="number">0</span>);<span class="comment">//注意这里每一次求的最大匹配都是相互独立的，所以要清空</span></span><br><span class="line">            <span class="keyword">if</span>(count()&lt;all)sum++;</span><br><span class="line">            line[x[i]][y[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Board %d have %d important blanks for %d chessmen.\n"</span>,_,sum,all);</span><br><span class="line">        _++;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title>过山车(匈牙利模板)</title>
    <url>/%E8%BF%87%E5%B1%B1%E8%BD%A6-%E5%8C%88%E7%89%99%E5%88%A9%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="传送门HDU-2063"><a href="#传送门HDU-2063" class="headerlink" title="传送门HDU 2063"></a>传送门<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063" target="_blank" rel="noopener">HDU 2063</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>输入数据的第一行是三个整数K , N， M ，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000<br>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>6 3 3<br>1 1<br>1 2<br>1 3<br>2 1<br>2 3<br>3 1<br>0</li>
<li>Output<br>3</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>这道题意思就是让男女生在满足规定条件下尽可能多得匹配，由此我们可以想到离散数学中的二部图，男生和女生分为两个点集，心仪关系作为边，从中找出最大匹配即可满足条件。也就是说，这是一道匈牙利模板题，关于匈牙利算法，<a href="https://blog.csdn.net/cillyb/article/details/55511666" target="_blank" rel="noopener">请戳这里</a>。<em>注意在HDU上面样例的M，N跟说明中的M，N是反过来的</em>.</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> K,M,N;</span><br><span class="line"><span class="keyword">int</span> line[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> another[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i]==<span class="number">0</span>&amp;&amp;line[x][i]==<span class="number">1</span>)&#123;</span><br><span class="line">            used[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(another[i]==<span class="number">0</span>||Find(another[i]))&#123;</span><br><span class="line">                another[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(used,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(find(i))sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;K &amp;&amp; K)</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(line,<span class="number">0</span>);INIT(another,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            line[x][y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title>求解背包具体方案</title>
    <url>/%E6%B1%82%E8%A7%A3%E8%83%8C%E5%8C%85%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p>
<p>第 i 件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。<br><a id="more"></a></p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>用二维记录01背包。为了保证答案字典序最小，dp时从n到1反向推，获取方案数时正向扫描。</li>
<li>从f[][m]往回推,如果f[i][m]==f[i+1][m-v[i]]+w[i]的话说明选了第i个物品</li>
<li>此题需要做边界判定</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(register int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(register int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N],n,m;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    repd(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        rep(j,<span class="number">0</span>,m)&#123;</span><br><span class="line">            f[i][j]=f[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i+<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vol=m;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="comment">//最后一个物品n的状态不是由n+1推来的</span></span><br><span class="line">        <span class="keyword">if</span>(vol&gt;=v[i] &amp;&amp; i==n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vol&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要保证vol-v[i]不会越界</span></span><br><span class="line">        <span class="keyword">if</span>(vol-v[i]&gt;=<span class="number">0</span> &amp;&amp; f[i][vol] == f[i+<span class="number">1</span>][vol-v[i]] + w[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">            vol-=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>求解背包方案数</title>
    <url>/%E6%B1%82%E8%A7%A3%E8%83%8C%E5%8C%85%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p>
<p>第 i 件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 最优选法的方案数。注意答案可能很大，请输出答案模 109+7 的结果。<br><a id="more"></a></p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>f[j]表示体积刚好为j时的最大价值，g[j]表示体积刚好为j时的方案数。</li>
<li>除f[0]=0外f初始化为-inf，保证所有状态从0开始计数，g[0]=1.</li>
<li>f[j]=max(f[j],f[j-v[i]]+w[i]),若f[j] == f[j-v[i]] + w[i],则g[j]=g[j] + g[j-v[i]]，否则g[j] = (f[j] &gt; f[j-v[i]]+w[i]) ? g[j] : g[j-v[i]]。</li>
<li>枚举找到最大价值，然后统计方案数即可。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(a,i,n) printf(<span class="meta-string">"%d%c"</span>,a,<span class="meta-string">" \n"</span>[i==n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mit map<span class="meta-string">&lt;double ,vector&lt;int&gt;&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll linf=(<span class="number">1l</span>l&lt;&lt;<span class="number">62</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;<span class="keyword">int</span> sign=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;c=getchar();<span class="keyword">if</span>(c==<span class="string">'-'</span>)sign=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;c=getchar();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>);</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N],g[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,N<span class="number">-1</span>) f[i]=-inf;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v,&amp;w);</span><br><span class="line">        repd(j,m,v)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=max(f[j],f[j-v]+w);</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == f[j]) s += g[j];</span><br><span class="line">            <span class="keyword">if</span>(t == f[j-v]+w) s += g[j-v];</span><br><span class="line">            <span class="keyword">if</span>(s &gt;= mod) s -= mod;</span><br><span class="line">            f[j] = t,g[j] = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mx=-inf,ans=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,m) mx=max(mx,f[i]);</span><br><span class="line">    rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mx == f[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt;= mod) ans-=mod;</span><br><span class="line">            ans+=g[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>有依赖的背包问题</title>
    <url>/%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有 N 个物品和一个容量是 V 的背包。</p>
<p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p>
<p>如下图所示：<br><img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" alt=""><br>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p>
<p>每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。<br><a id="more"></a></p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>f[i][j]表示选了节点i，最大体积为j时，以i为根的子树的最大价值</li>
<li>树形dp+分组背包</li>
<li>细节待补充</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=N;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> pre[N],val[N];</span><br><span class="line"><span class="keyword">int</span> f[N][M];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[x].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=son[x][i];</span><br><span class="line">        dp(y);</span><br><span class="line">        repd(t,m,<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x!=<span class="number">0</span>)</span><br><span class="line">                rep(j,<span class="number">0</span>,t<span class="number">-1</span>)</span><br><span class="line">                    f[x][t]=max(f[x][t],f[x][t-j]+f[y][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rep(j,<span class="number">0</span>,t)</span><br><span class="line">                    f[x][t]=max(f[x][t],f[x][t-j]+f[y][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        repd(i,m,<span class="number">1</span>) f[x][i]=f[x][i]+val[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;pre[i],&amp;val[i]);</span><br><span class="line">        son[pre[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dp(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">0</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>分组背包问题</title>
    <url>/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 v[i][j]，价值是 w[i][j]，其中 i 是组号，j 是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。<br><a id="more"></a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>对比01背包，01背包的决策是对每个物品选或者不选两种状态，分组背包是每组物品不选或选某一个共s+1种状态</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(register int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(register int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],num[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">        rep(j,<span class="number">1</span>,num[i])</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i][j],&amp;w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        repd(j,m,<span class="number">0</span>)&#123;</span><br><span class="line">            rep(k,<span class="number">0</span>,num[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;v[i][k]) <span class="keyword">continue</span>;</span><br><span class="line">                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>二维费用背包问题</title>
    <url>/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
</blockquote>
<p>每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。<br><a id="more"></a></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>在一维背包的基础上加一维状态表示，加一层循环即可</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> n,v,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;v,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&gt;=a;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=m;k&gt;=b;k--)</span><br><span class="line">                f[j][k]=max(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[v][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>混合背包问题</title>
    <url>/%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<p>   第一类物品只能用1次（01背包）；<br>   第二类物品可以用无限次（完全背包）；<br>   第三类物品最多只能用 si 次（多重背包）；<br>   每种体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。<br><a id="more"></a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>每种背包问题分开处理即可，其中多重背包用二进制拆分转01即可满足时间复杂度</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for(int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(a,i,n) printf(<span class="meta-string">"%d%c"</span>,a,<span class="meta-string">" \n"</span>[i==n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mit map<span class="meta-string">&lt;double ,vector&lt;int&gt;&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll linf=(<span class="number">1l</span>l&lt;&lt;<span class="number">62</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;<span class="keyword">int</span> sign=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;c=getchar();<span class="keyword">if</span>(c==<span class="string">'-'</span>)sign=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;c=getchar();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>);</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> n,m,v,w,s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,tag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Thing&gt;things;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;v,&amp;w,&amp;s);</span><br><span class="line">        <span class="keyword">if</span>(s &lt; <span class="number">0</span>) things.push_back(&#123;v,w,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">0</span>) things.push_back(&#123;v,w,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//二进制拆分</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;=s ;k*=<span class="number">2</span> )&#123;</span><br><span class="line">                s -= k;</span><br><span class="line">                things.push_back(&#123;v*k, w*k,<span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;<span class="number">0</span>) things.push_back(&#123;v*s,w*s,<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//01</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; things.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(things[i].tag &lt; <span class="number">0</span>)&#123; <span class="comment">//01</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= things[i].v; j--)</span><br><span class="line">                f[j]=max(f[j],f[j-things[i].v]+things[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//完全</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = things[i].v ; j &lt;=m ; j++)</span><br><span class="line">                f[j]=max(f[j],f[j-things[i].v]+things[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集<br><a id="more"></a></p>
<blockquote>
<p>用数组f[]存放每一个节点的父节点，通过find（a）递归访问最终父节点，若两个节点的最终父节点相等，则在同一个集合，否则通过f[find（a）]=find（b）的方式将两树结合<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[n]==n?n:f[n]=find(f[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">	<span class="keyword">if</span>(fa!=fb) f[fa]=fb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1005</span>;i++)f[i]=i;</span><br><span class="line">		<span class="keyword">int</span> m,n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> sa,sb;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;sa,&amp;sb);</span><br><span class="line">			unit(sa,sb);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> cnt[<span class="number">1005</span>];</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			cnt[find(i)]++;</span><br><span class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)num++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树(Prim算法)</title>
    <url>/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最小生成树——Prim算法<br><a id="more"></a></p>
<h1 id="prim算法简单来说就是加点法，如下图所示："><a href="#prim算法简单来说就是加点法，如下图所示：" class="headerlink" title="prim算法简单来说就是加点法，如下图所示："></a>prim算法简单来说就是加点法，如下图所示：</h1><p><img src="../image/prime.jpg" alt=""></p>
<blockquote>
<p>用邻接矩阵存放整个图的信息（注意无向图的对称性），用一个整型数组on[]来存放已经加入的点，用一个结构体数组存放每个点的信息，包括与之距离最短的点another，两点的权值weigh，以及flag标记是否已被选取。<br>先将第一个点放入on[]数组中，每次放入的时候所有未选用的点信息都需要更新（即比较上一次最短距离和与新点之间的距离大小，然后修改weigh和another），然后从中选取weigh最小的点，输出其another与其自身，表示一条新的边，然后将该点存入on[]数组，其flag置为1，重复操作，直到点全部被选完</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0xfffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> weigh;<span class="comment">//与已有点的最短距离</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> another;<span class="comment">//最近距离的点</span></span><br><span class="line">&#125; d;</span><br><span class="line">d dian[<span class="number">100</span>];<span class="comment">//存放点的信息</span></span><br><span class="line"><span class="keyword">int</span> ok[<span class="number">100</span>];<span class="comment">//存放已连接点</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dian[i].flag ==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dian[i].weigh &gt;<span class="built_in">map</span>[i][j]) &#123;</span><br><span class="line">            dian[i].weigh =<span class="built_in">map</span>[i][j];</span><br><span class="line">            dian[i].another =j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        dian[i].flag =<span class="number">0</span>;</span><br><span class="line">        dian[i].weigh =MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            <span class="built_in">map</span>[i][j]=MAX;</span><br><span class="line">    <span class="keyword">while</span>(e--) &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">char</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        <span class="built_in">map</span>[change(a)][change(b)]=w;</span><br><span class="line">        <span class="built_in">map</span>[change(b)][change(a)]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    ok[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dian[<span class="number">0</span>].flag =<span class="number">1</span>;<span class="comment">//已拿</span></span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;n) &#123;</span><br><span class="line">        find(ok[top]);<span class="comment">//更新剩余点信息</span></span><br><span class="line">        <span class="keyword">int</span> min=MAX;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dian[i].flag ==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dian[i].weigh &lt;min) &#123;</span><br><span class="line">                min=dian[i].weigh ;</span><br><span class="line">                p=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&lt;n<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;str[dian[p].another ]&lt;&lt;<span class="string">","</span>&lt;&lt;str[p]&lt;&lt;<span class="string">")"</span>;<span class="comment">//边比点少一</span></span><br><span class="line">        top++;</span><br><span class="line">        ok[top]=p;</span><br><span class="line">        dian[ok[top]].flag =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树(Kruskal算法)</title>
    <url>/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Kruskal%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最小生成树原理及实现<br><a id="more"></a></p>
<h1 id="关于图的几个概念定义："><a href="#关于图的几个概念定义：" class="headerlink" title="关于图的几个概念定义："></a>关于图的几个概念定义：</h1><blockquote>
<ul>
<li><strong>连通图:</strong>在无向图中，若任意两个顶点与都有路径相通，则称该无向图为连通图。</li>
<li><strong>强连通图：</strong>在有向图中，若任意两个顶点与都有路径相通，则称该有向图为强连通图。</li>
<li><strong>连通网：</strong>在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li>
<li><strong>生成树：</strong>一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li>
<li><strong>最小生成树：</strong>在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。<br><img src="../image/mst.jpg" alt=""></li>
<li>Kruskal算法即为加边法<br><img src="../image/kruskal.jpg" alt=""></li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">120</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dao</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">double</span> dis;</span><br><span class="line">&#125; dao;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmd</span><span class="params">(dao a,dao b)</span> </span>&#123; <span class="comment">//排序 </span></span><br><span class="line">    <span class="keyword">return</span> a.dis &lt;b.dis;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//找根节点 </span></span><br><span class="line">    <span class="keyword">return</span> f[n]==n?n:f[n]=find(f[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">120</span>; i++)</span><br><span class="line">        f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">heb</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//合并并判断是否为环</span></span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb) &#123;</span><br><span class="line">        f[fa]=fb;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t) &#123;</span><br><span class="line">        <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">            dao s[<span class="number">10005</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">            <span class="keyword">double</span> x[<span class="number">101</span>],y[<span class="number">101</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c; i++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;c; j++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> num=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);</span><br><span class="line">                    <span class="keyword">if</span>(num&gt;=<span class="number">100</span>&amp;&amp;num&lt;=<span class="number">1000000</span>) &#123;</span><br><span class="line">                        s[k].a =i;</span><br><span class="line">                        s[k].b =j;</span><br><span class="line">                        s[k].dis =<span class="built_in">sqrt</span>(num);</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(s,s+k,cmd);</span><br><span class="line">            init();</span><br><span class="line">            <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(heb(s[i].a,s[i].b )) &#123;</span><br><span class="line">                    sum+=s[i].dis ;</span><br><span class="line">                    flag++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==c<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,sum*<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"oh!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>string函数</title>
    <url>/string%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>………….<br><a id="more"></a></p>
<h1 id="变量申请"><a href="#变量申请" class="headerlink" title="变量申请"></a>变量申请</h1><blockquote>
<ul>
<li>string str;  //定义了一个空字符串str</li>
<li>string s1(str);       //调用复制构造函数生成s1，s1为str的复制品</li>
<li>string s2(str,6);     //将str内，开始于位置6的部分当作s2的初值</li>
<li>string s3(str,6,3);  //将str内，开始于6且长度顶多为3的部分作为s3的初值</li>
<li>string s4(cstr);   //将C字符串作为s4的初值</li>
<li>string s5(cstr,3);  //将C字符串前3个字符作为字符串s5的初值。</li>
<li>string s6(5,’A’);  //生成一个字符串，包含5个’A’字符</li>
<li>string s7(str.begin(),str.begin()+5); //区间str.begin()和str.begin()+5内的字符作为初值<br>输出结果：Hello world<pre><code>   world
   wor
   abcde
   abc
   AAAAA
   Hello
</code></pre></li>
</ul>
</blockquote>
<h1 id="获取特性的函数"><a href="#获取特性的函数" class="headerlink" title="获取特性的函数"></a>获取特性的函数</h1><blockquote>
<ul>
<li>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）</li>
<li>int max_size()const;    //返回string对象中可存放的最大字符串的长度</li>
<li>int size()const;        //返回当前字符串的大小</li>
<li>int length()const;       //返回当前字符串的长度</li>
<li>bool empty()const;        //当前字符串是否为空</li>
<li>void resize(int len,char c);  //把字符串当前大小置为len，多去少补，多出的字符c填充不足的部分<br>如：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">if</span> (str.empty())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is NULL."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is not NULL."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str = str + <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's size is "</span>&lt;&lt;str.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">　　     <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's capacity is "</span>&lt;&lt;str.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's max size is "</span>&lt;&lt;str.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's length is "</span>&lt;&lt;str.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str.resize(<span class="number">20</span>,<span class="string">'c'</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str.resize(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序执行结果为：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str is NULL.</span></span><br><span class="line"><span class="comment">str is abcdefg</span></span><br><span class="line"><span class="comment">str's size is 7</span></span><br><span class="line"><span class="comment">str's capacity is 15</span></span><br><span class="line"><span class="comment">str's max size is 4294967294</span></span><br><span class="line"><span class="comment">str's length is 7</span></span><br><span class="line"><span class="comment">str is abcdefgccc</span></span><br><span class="line"><span class="comment">str is abcde</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h1><blockquote>
<ul>
<li>size_type find( const basic_string &amp;str, size_type index );  //返回str在字符串中第一次出现的位置（从index开始查找），如果没找到则返回string::npos</li>
<li>size_type find( const char *str, size_type index );  // 同上</li>
<li>size_type find( const char *str, size_type index, size_type length );  //返回str在字符串中第一次出现的位置（从index开始查找，长度为length），如果没找到就返回string::npos</li>
<li>size_type find( char ch, size_type index );  // 返回字符ch在字符串中第一次出现的位置（从index开始查找），如果没找到就返回string::npos<br><strong>注意：查找字符串a是否包含子串b,不是用 strA.find(strB) &gt; 0 而是 strA.find(strB) != string::npos</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loc;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">"study hard and make progress everyday! every day!!"</span>;</span><br><span class="line">    loc=s.rfind(<span class="string">"make"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word make is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//-1表示没找到</span></span><br><span class="line">    loc=s.rfind(<span class="string">"make"</span>);<span class="comment">//缺省状态下，从最后一个往前找</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word make is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_first_of(<span class="string">"day"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word day(first) is at index "</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_first_not_of(<span class="string">"study"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the first word not of study is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_last_of(<span class="string">"day"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the last word of day is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find(<span class="string">"day"</span>);<span class="comment">//缺陷状态下从第一个往后找</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;loc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the word make is at index-1</span></span><br><span class="line"><span class="comment">the word is at index45</span></span><br><span class="line"><span class="comment">the word day(first) is at index3</span></span><br><span class="line"><span class="comment">the first word not of study is at index5</span></span><br><span class="line"><span class="comment">the last word of day is at index47</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h1><blockquote>
<ul>
<li>string &amp;insert(int p,const string &amp;s);  //在p位置插入字符串s</li>
<li>string &amp;replace(int p, int n,const char *s); //删除从p开始的n个字符，然后在p处插入串s</li>
<li>string &amp;erase(int p, int n);  //删除p开始的n个字符，返回修改后的字符串</li>
<li>string substr(int pos = 0,int n = npos) const;  //返回pos开始的n个字符组成的字符串</li>
<li>void swap(string &amp;s2);    //交换当前字符串与s2的值</li>
<li>string &amp;append(const char *s);   //把字符串s连接到当前字符串结尾</li>
<li>void push_back(char c)   //当前字符串尾部加一个字符c</li>
<li>const char <em> data()const;   //返回一个非null终止的c字符数组，data():与c_str()类似，用于string转const char</em>其中它返回的数组是不以空字符终止,</li>
<li>const char <em> c_str()const;  //返回一个以null终止的c字符串，即c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同,用于string转const char</em><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">"abc123defg"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"swap!"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.erase(<span class="number">3</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//从索引3开始的3个字符,即删除掉了"123"</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.insert(<span class="number">0</span>,<span class="string">"123"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//在头部插入</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.append(<span class="string">"123"</span>)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//append()方法可以添加字符串</span></span><br><span class="line">    str1.push_back(<span class="string">'A'</span>);  <span class="comment">//push_back()方法只能添加一个字符</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.replace(<span class="number">0</span>,<span class="number">3</span>,<span class="string">"hello"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//即将索引0开始的3个字符替换成"hello"</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.substr(<span class="number">5</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//从索引5开始7个字节</span></span><br><span class="line">    str1.swap(str2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = str.c_str();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abc123defg</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">123abcdefg</span></span><br><span class="line"><span class="comment">123abcdefg123</span></span><br><span class="line"><span class="comment">123abcdefg123A</span></span><br><span class="line"><span class="comment">helloabcdefg123A</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">swap!</span></span><br><span class="line"><span class="comment">swap!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>调查问卷</title>
    <url>/%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7/</url>
    <content><![CDATA[<h1 id="传送门-HDU-6344"><a href="#传送门-HDU-6344" class="headerlink" title="传送门 HDU 6344"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6344" target="_blank" rel="noopener">HDU 6344</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>度度熊为了完成毕业论文，需要收集一些数据来支撑他的论据，于是设计了一份包含 m 个问题的调查问卷，每个问题只有 ‘A’ 和 ‘B’ 两种选项。<br>将问卷散发出去之后，度度熊收到了 n 份互不相同的问卷，在整理结果的时候，他发现可以只保留其中的一部分问题，使得这 n 份问卷仍然是互不相同的。这里认为两张问卷是不同的，当且仅当存在至少一个被保留的问题在这两份问卷中的回答不同。<br>现在度度熊想知道，存在多少个问题集合，使得这 n 份问卷在只保留这个集合的问题之后至少有 k 对问卷是不同的。</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行包含一个整数 T，表示有 T 组测试数据。<br>接下来依次描述 T 组测试数据。对于每组测试数据：<br>第一行包含三个整数 n，m 和 k，含义同题目描述。<br>接下来 n 行，每行包含一个长度为 m 的只包含 ‘A’ 和 ‘B’ 的字符串，表示这份问卷对每个问题的回答。<br>保证<script type="math/tex">1≤T≤100，1≤n≤10^3，1≤m≤10，1≤k≤10^6</script>，给定的 n 份问卷互不相同。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每组测试数据，输出一行信息 “Case #x: y”（不含引号），其中 x 表示这是第 x 组测试数据，y 表示满足条件的问题集合的个数，行末不要有多余空格。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>2<br>2 2 1<br>AA<br>BB<br>2 2 2<br>AA<br>BB</li>
<li>Output<br>Case #1: 3<br>Case #2: 0</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>可以看到这里问卷长度m最多为10，再加上时间给定6m，我们可以枚举每一种问卷的选择方式，最多也就<script type="math/tex">2^m（1024）</script>种</li>
<li>如何枚举呢？难道要枚举每一种字符串然后一个一个比对吗？想都不用想，这样必然会炸。所以采用状态压缩的方式，把问卷中的AB当作01，最后形成一个二进制数，然后转换成十进制。比如问卷ABABA，我们可以表示成10101,其十进制为21。这样的话就用一个十进制数代替了一张问卷的答案，并且不会有重复的情况（除非问卷本身就相同）</li>
<li>用数字表示之后怎样才能找到答案呢？很简单，只需要用每一张问卷去合取（&amp;）我们所枚举的那一种状态即可，因为它们的二进制位数相同，所以不同的问卷答案跟相同的值合取得到的答案必不相同</li>
<li>用map存下每次得到的答案的种类和个数，然后凑一下对数，最后凑出的对数大于k则满足情况，计数器+1</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> Num=<span class="number">1</span>;Num&lt;=T;Num++)</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(num,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">                num[i]= x==<span class="string">'A'</span>? num[i]&lt;&lt;<span class="number">1</span>|<span class="number">1</span>:num[i]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//通过位运算获取当前状态的十进制数</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,t,he[<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta=<span class="number">1</span>;sta&lt;<span class="number">1</span>&lt;&lt;m;sta++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt.clear();INIT(he,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                t=num[i]&amp;sta;</span><br><span class="line">                <span class="keyword">if</span>(cnt[t]==<span class="number">0</span>)cnt[t]=<span class="number">0</span>;</span><br><span class="line">                cnt[t]++;</span><br><span class="line">            &#125;	</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=cnt.begin();it!=cnt.end();it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t==<span class="number">0</span>)he[t]=it-&gt;second;</span><br><span class="line">                <span class="keyword">else</span> he[t]=he[t<span class="number">-1</span>]+it-&gt;second;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;<span class="comment">//求前缀和，用以计算不同答案的对数</span></span><br><span class="line">            t=<span class="number">0</span>;<span class="keyword">int</span> Sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=cnt.begin();it!=cnt.end();it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(it==cnt.begin())<span class="keyword">continue</span>;</span><br><span class="line">                Sum+=it-&gt;second*he[t++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Sum&gt;=k)sum++;							</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;Num&lt;&lt;<span class="string">": "</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;		</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>三原色图(最小生成树)</title>
    <url>/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="传送门-HDU6349"><a href="#传送门-HDU6349" class="headerlink" title="传送门 HDU6349"></a>传送门 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6349" target="_blank" rel="noopener">HDU6349</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>度度熊有一张 n 个点 m 条边的无向图，所有点按照 1,2,⋯,n 标号，每条边有一个正整数权值以及一种色光三原色红、绿、蓝之一的颜色。<br>现在度度熊想选出恰好 k 条边，满足只用这 k 条边之中的红色边和绿色边就能使 n 个点之间两两连通，或者只用这 k 条边之中的蓝色边和绿色边就能使 n 个点之间两两连通，这里两个点连通是指从一个点出发沿着边可以走到另一个点。<br>对于每个 k=1,2,⋯,m，你都需要帮度度熊计算选出恰好 k 条满足条件的边的权值之和的最小值。</p>
</blockquote>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行包含一个正整数 T，表示有 T 组测试数据。<br>接下来依次描述 T 组测试数据。对于每组测试数据：<br>第一行包含两个整数 n 和 m，表示图的点数和边数。<br>接下来 m 行，每行包含三个整数 a,b,w 和一个字符 c，表示有一条连接点 a 与点 b 的权值为 w、颜色为 c 的无向边。<br>保证 1≤T≤100，1≤n,m≤100，1≤a,b≤n，1≤w≤1000，c∈{R,G,B}，这里 R,G,B 分别表示红色、绿色和蓝色。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>对于每组测试数据，先输出一行信息 “Case #x:”（不含引号），其中 x 表示这是第 x 组测试数据，接下来 m 行，每行包含一个整数，第 i 行的整数表示选出恰好 i 条满足条件的边的权值之和的最小值，如果不存在合法方案，输出 −1，行末不要有多余空格。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li><p>input<br>1<br>5 8<br>1 5 1 R<br>2 1 2 R<br>5 4 5 R<br>4 5 3 G<br>1 3 3 G<br>4 3 5 G<br>5 4 1 B<br>1 2 2 B</p>
</li>
<li><p>output<br>Case #1:<br>-1<br>-1<br>-1<br>9<br>10<br>12<br>17<br>22</p>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>按两种选取颜色的方法建立两个最小生成树，然后每次分别加上剩下的边中最小的那一条，用两个数组分别保存采用两种方法得出的答案，最后比较两个数组中每个元素的大小，输出小的值</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> Flag1[<span class="number">105</span>],Flag2[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> road1[<span class="number">105</span>],road2[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cun</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;<span class="keyword">int</span> b;<span class="keyword">int</span> dis;<span class="keyword">char</span> color;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (cun e) <span class="keyword">const</span>&#123;<span class="keyword">return</span> dis&lt;e.dis;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">"%d %d %d %c"</span>,&amp;a,&amp;b,&amp;dis,&amp;color);&#125;</span><br><span class="line">&#125;bian[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">105</span>;i++)f[i]=i;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">return</span> f[n]==n?n:f[n]=find(f[n]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">heb</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> fa=find(a),fb=find(b);<span class="keyword">if</span>(fa!=fb)&#123;f[fa]=fb;<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildtree1</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bian[i].color ==<span class="string">'B'</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(heb(bian[i].a ,bian[i].b ))</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=bian[i].dis;</span><br><span class="line">            Flag1[i]=<span class="number">1</span>;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag&lt;n<span class="number">-1</span>)INIT(road1,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;flag<span class="number">-1</span>)road1[i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==flag<span class="number">-1</span>)road1[i]=sum;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(Flag1[p]==<span class="number">1</span>)p++;</span><br><span class="line">                road1[i]=road1[i<span class="number">-1</span>]+bian[p].dis ;</span><br><span class="line">                Flag1[p]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildtree2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bian[i].color ==<span class="string">'R'</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(heb(bian[i].a ,bian[i].b ))</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=bian[i].dis ;</span><br><span class="line">            Flag2[i]=<span class="number">1</span>;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag&lt;n<span class="number">-1</span>)INIT(road2,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;flag<span class="number">-1</span>)road2[i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==flag<span class="number">-1</span>)road2[i]=sum;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(Flag2[p]==<span class="number">1</span>)p++;</span><br><span class="line">                road2[i]=road2[i<span class="number">-1</span>]+bian[p].dis ;</span><br><span class="line">                Flag2[p]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">1</span>;q&lt;=T;q++)</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(Flag1,<span class="number">0</span>);INIT(Flag2,<span class="number">0</span>);</span><br><span class="line">        INIT(road1,<span class="number">0</span>);INIT(road2,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)bian[i].read();</span><br><span class="line">            </span><br><span class="line">        sort(bian,bian+m);		</span><br><span class="line">        buildtree1(n,m);</span><br><span class="line">        buildtree2(n,m);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(road1[i]==road2[i]&amp;&amp;road1[i]==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(road1[i]==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,road2[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(road2[i]==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,road1[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(road1[i],road2[i]));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="附加彩蛋"><a href="#附加彩蛋" class="headerlink" title="附加彩蛋"></a>附加彩蛋</h1><blockquote>
<p>这是百度之星资格赛中的一道题，虽然很简单，但是因为一个不起眼的越界问题，导致其他的变量被无意中修改而wa了无数发，真是菜。。。<br>当然，这一次也是很赚的，那就是我在看其他大佬的代码时发现了一些骚气的写法<br>比如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cun</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;<span class="keyword">int</span> b;<span class="keyword">int</span> dis;<span class="keyword">char</span> color;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (cun e)&#123;<span class="keyword">return</span> dis&lt;e.dis;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">"%d %d %d %c"</span>,&amp;a,&amp;b,&amp;dis,&amp;color);&#125;</span><br><span class="line">&#125;bian[<span class="number">1005</span>];</span><br><span class="line">sort(bian,bian+m);		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)bian[i].read();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>也就是结构体中的运算符重载（再写cmp我是狗/kb）和函数用法，以及通过结构体的构造函数赋值的方法<br>不得不说，这一波之后，虽然我没有变强，但是…我变骚了许多hhhhhhh</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包</title>
    <url>/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>现有n个物体和容量为V的背包，每个物体i都有对应的重量w[i]和价值v[i]，每个物体可以拿num[i]次，在所取物体总重量不超过V的情况下，能获得的最大价值是多少？<br><a id="more"></a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>还记得01背包吗，两者大意相同，区别在于01背包最多取1次，而多重背包却给定每件物品不同的选取次数。理论上来讲只需要在01背包的基础上遍历每一个物体的每一种取法就完成了,时间复杂度为$O(N^3)$。</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=number[i] &amp;&amp; k*value[i]&lt;=j; k++)</span><br><span class="line">           f[j]=max(f[j],f[j-k*value[i]]+k*value[i]);</span><br></pre></td></tr></table></figure>
<h1 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h1><blockquote>
<ul>
<li>当num[i]==1时，当作01背包来处理，而当第i个物体的w[i]*num[i]&gt;V时，直接当作完全背包来处理，而其他的时候，我们采用通过二进制拆分转换成01背包的方法</li>
<li>二进制拆分法：首先我们要知道将一个数n按一定规律拆分成几个数，这几个数就可以组合出从1到n的任何一个数（每个数只能取一次）。比如给出一个数13(1101)，那么我们可以将其拆分成1(0001),2(0010),4(0100),6(13-1-2-4)这四个数，而这四个数可以组合成1~13中的任意一个数（可以自己验证一下）， 也就是说，我们每一种物体的选取方法从遍历1~num[i]变成了枚举这几个数，达到相同的效果，时间复杂度为$O(N·V·log(num))$。<ul>
<li>具体方法：将每个物品对个数进行二进制拆分并打包成多个物品存放起来，最后对整体做01背包。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> n,m,v,w,s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Thing&gt;things;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//二进制拆分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;v,&amp;w,&amp;s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;=s ;k*=<span class="number">2</span> )&#123;</span><br><span class="line">            s -= k;</span><br><span class="line">            things.push_back(&#123;v*k, w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) things.push_back(&#123;v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//01</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; things.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= things[i].v; j--)</span><br><span class="line">            f[j]=max(f[j],f[j-things[i].v]+things[i].w);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优先队列优化"><a href="#优先队列优化" class="headerlink" title="优先队列优化"></a>优先队列优化</h1><blockquote>
<p>待补充</p>
</blockquote>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包</title>
    <url>/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h1><blockquote>
<p>现有n个物体和容量为V的背包，每个物体i都有对应的重量w[i]和价值v[i]，每个物体可以拿无数次，在所取物体总重量不超过V的情况下，能获得的最大价值是多少？<br><a id="more"></a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<ul>
<li>之前在01背包的问题中我们提到了逆序遍历重量的原因，当时只是说如果正向遍历的话dp[j-w[i]]的值会因为物品重选而发生改变，无法满足每个物体只拿一次条件下的dp[j]，但是没有解释到dp[j-w[i]]到底变成了什么样子，正序的话求出的dp[j]又是什么样子。</li>
<li>通过简单的推导后不难发现，当我们正序地从w[i]-&gt;V处理物体i时，dp[j]正是在前i件物体中，在满足总重量小于V并且可重复拿取的情况下所得到的最大价值，刚好符合完全背包的要求</li>
<li>综上所述，只需要将01背包中的内层循环从逆序改为正序，就能满足完全背包，最后dp[V]就是答案（如果对于01背包不太了解，那么…<a href="https://aaaaalen.github.io/01%E8%83%8C%E5%8C%85/">戳这里 /xyx</a>）</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=V;j++)</span><br><span class="line">        dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包</title>
    <url>/01%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h1><blockquote>
<p>现有n个物体和容量为V的背包，每个物体i都有对应的重量w[i]和价值v[i]，每个物体最多拿一次，在所取物体总重量不超过V的情况下，能获得的最大价值是多少？<br><a id="more"></a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<ul>
<li>每个物体只有拿和不拿两种情况，则在选择是否拿第i件时，在之前已确定部分的基础上进行比较判断即可</li>
<li>申请一个二维数组dp[][]，用dp[i][j]来表示在物品数量为i，总重量为j的条件下能达到的最大价值，那么dp[i][j]的值为：<script type="math/tex; mode=display">dp[i][j]=Max
\begin{cases}
dp[i-1][j] &\mbox{不拿第i个，状态跟i-1一样}\\
dp[i-1][j-w[i]]+v[i]&\mbox{拿第i个，就用重量为j-w[i]的价值来加上第i个的价值v[i]}
\end{cases}</script>最后dp[n][V]即为答案</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=j)f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-w[i]]+v[i]);			</span><br><span class="line">        <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="comment">//f[i-1][j]没拿时的价值,f[i-1][j-a[i]]+b[i]拿了之后的价值 </span></span><br><span class="line">        <span class="comment">//i为前i个物体，j为剩余背包空间 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><blockquote>
<ul>
<li>前面的代码在时间复杂度上已经无法继续优化，但是在空间复杂度上，因为我们只需要最多取n个的答案，所以我们可以在dp[i][j]的基础上去掉物体数这一维，那么dp[j]的值就为：<script type="math/tex; mode=display">dp[j]=Max(dp[j] , dp[j-w[i]]+v[i])</script></li>
</ul>
</blockquote>
<h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=w[i];j--)</span><br><span class="line">        dp[j]=max(dp[j] , dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote>
<ul>
<li>在遍历重量的时候是V-&gt;w[i]，并不是w[i]-&gt;V，其原因是：<strong>第i个物体的状态只与i-1有关，我们在操作dp[j]的时候必须保证dp[j-w[i]]是上一次操作后的结果</strong>，如果从w[i]-&gt;V，那么dp[j-w[i]]的值在操作dp[j]之前就已经发生了改变，里面存的不是i-1时刻的值</li>
<li>数组dp的值要全部初始化为0</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>栈 队列与优先队列</title>
    <url>/STL%E2%80%94%E2%80%94%E6%A0%88-%E9%98%9F%E5%88%97%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>。。。。。。。。。。。。。<br><a id="more"></a></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt; <span class="keyword">int</span>&gt;s;</span><br><span class="line">入栈：push()；</span><br><span class="line">出栈：pop();</span><br><span class="line">取栈顶top()；</span><br></pre></td></tr></table></figure>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt; <span class="keyword">int</span>&gt;s;</span><br><span class="line">入队：push();</span><br><span class="line">出队：pop();</span><br><span class="line">取队首元素：front();(不删除)</span><br></pre></td></tr></table></figure>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt; <span class="keyword">int</span>&gt;pq;</span><br><span class="line">入队：push();    </span><br><span class="line">出队：pop();    </span><br><span class="line">取队首元素：top();(不删除) 这里取的队首元素是优先级最高的元素，pq是一个数越大优先级越高的优先对列  priority_queue&lt; <span class="keyword">int</span>,<span class="built_in">vector</span>&lt; <span class="keyword">int</span>&gt;,greater&lt; <span class="keyword">int</span>&gt; &gt;s; 这里s是一个数越小优先级越高的优先对列</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL——map</title>
    <url>/STL%E2%80%94%E2%80%94map/</url>
    <content><![CDATA[<p>。。。。。。。。。。。。。。。<br><a id="more"></a></p>
<h1 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1,typename2&gt;mp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的类型如果要用字符串的话只能用string，不能用char[]</p>
</blockquote>
<h1 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h1><ol>
<li><p>用insert函数插入pair数据 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///数据的插入--第一种：用insert函数插入pair数据  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;    </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));    </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));   </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));   </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;   </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="comment">///反向      </span></span><br><span class="line"><span class="comment">//    map&lt;int, string&gt;::reverse_iterator iter;   </span></span><br><span class="line"><span class="comment">//    for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)  </span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;iter-&gt;first&lt;&lt;"  "&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用nsert函数插入value_type数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"student_one"</span>));</span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">2</span>, <span class="string">"student_two"</span>));</span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">"student_three"</span>));</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接用数组方式插入数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">"student_one"</span>;</span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">"student_two"</span>;</span><br><span class="line">    mapStudent[<span class="number">3</span>] = <span class="string">"student_three"</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//        int nSize = mapStudent.size();</span></span><br><span class="line"><span class="comment">///此处应注意，应该是 for(int nindex = 1; nindex &lt;= nSize; nindex++)</span></span><br><span class="line"><span class="comment">///而不是 for(int nindex = 0; nindex &lt; nSize; nindex++)</span></span><br><span class="line"><span class="comment">//    for(int nindex = 1; nindex &lt;= nSize; nindex++)</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;mapStudent[nindex]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h1><blockquote>
<ol>
<li>用 <strong>count()</strong> 函数来判定 <strong>key</strong> 是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了</li>
<li>用 <strong>find</strong> 函数来定位 <strong>key</strong> 出现位置，它返回的一个 <strong>迭代器</strong>，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。</li>
</ol>
</blockquote>
<h1 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h1><blockquote>
<p>begin()                   返回指向map头部的迭代器</p>
<p>clear(）                  删除所有元素</p>
<p>count()                   返回指定元素出现的次数</p>
<p>empty()                   如果map为空则返回true</p>
<p>end()                     返回指向map末尾的迭代器</p>
<p>equal_range()             返回特殊条目的迭代器对</p>
<p>erase()                   删除一个元素</p>
<p>find()                    查找一个元素</p>
<p>get_allocator()           返回map的配置器</p>
<p>insert()                  插入元素</p>
<p>key_comp()                返回比较元素key的函数</p>
<p>lower_bound()             返回键值&gt;=给定元素的第一个位置</p>
<p>max_size()                返回可以容纳的最大元素个数</p>
<p>rbegin()                  返回一个指向map尾部的逆向迭代器</p>
<p>rend()                    返回一个指向map头部的逆向迭代器</p>
<p>size()                    返回map中元素的个数</p>
<p>swap()                    交换两个map</p>
<p>upper_bound()             返回键值&gt;给定元素的第一个位置</p>
<p>value_comp()              返回比较元素value的函数</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL——next_permutation</title>
    <url>/STL%E2%80%94%E2%80%94next_permutation/</url>
    <content><![CDATA[<p>这是一个求一个排序的下一个排列的函数，可以遍历全排列,要包含头文件<algorithm><br>与之完全相反的函数还有prev_permutation</algorithm></p>
<p>在STL中，除了next_permutation外，还有一个函数prev_permutation，两者都是用来计算排列组合的函数。</p>
<p>前者是求出下一个排列组合，而后者是求出上一个排列组合。所谓“下一个”和“上一个”，书中举了一个简单的例子：</p>
<p>对序列 {a, b, c}，每一个元素都比后面的小，按照字典序列，固定a之后，a比bc都小，c比b大，它的下一个序列即为{a, c, b}，而{a, c, b}的上一个序列即为{a, b, c}，同理可以推出所有的六个序列为：{a, b, c}、{a, c, b}、{b, a, c}、{b, c, a}、{c, a, b}、{c, b, a}，其中{a, b, c}没有上一个元素，{c, b, a}没有下一个元素。</p>
<h1 id="1-int-类型的next-permutation"><a href="#1-int-类型的next-permutation" class="headerlink" title="(1) int 类型的next_permutation"></a>(1) int 类型的next_permutation</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;a[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;a[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(a,a+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br> 1 2 3<br> 1 3 2<br> 2 1 3<br> 2 3 1<br> 3 1 2<br> 3 2 1<br>如果改成 while(next_permutation(a,a+2));<br>则输出：<br> 1 2 3<br> 2 1 3<br>只对前两个元素进行字典排序<br>显然，如果改成 while(next_permutation(a,a+1)); 则只输出：1 2 3</p>
<h1 id="1-char-类型的next-permutation"><a href="#1-char-类型的next-permutation" class="headerlink" title="(1) char 类型的next_permutation"></a>(1) char 类型的next_permutation</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">205</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    sort(ch,ch+<span class="built_in">strlen</span>(ch));</span><br><span class="line">    <span class="keyword">char</span> *first =ch;</span><br><span class="line">    <span class="keyword">char</span> *last=ch+<span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(first,last));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL——set</title>
    <url>/STL%E2%80%94%E2%80%94set/</url>
    <content><![CDATA[<p>。。。。。。。。。。。。。。。<br><a id="more"></a></p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p><strong>set即为集合，拥有集合的特征：元素不重复</strong></p>
<ul>
<li>不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素</li>
<li>不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取，而且从迭代器角度来看，元素值是常数</li>
</ul>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><ul>
<li><p>遍历：只能用迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=s.begin();it!=s.end();it++)</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向遍历：利用反向迭代器reverse_iterator。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit;</span><br><span class="line"><span class="keyword">for</span>(rit=s.rbegin();rit!=s.rend();rit++)</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入：insert()</p>
</li>
<li>删除：erase(2)</li>
<li>清空：clear()</li>
<li>查找：find()  若找到，返回该键值迭代器的位置，否则，返回最后一个元素后面一个位置。</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote>
<p>c++ stl容器set成员函数:begin()—返回指向第一个元素的迭代器;</p>
<p>c++ stl容器set成员函数:clear()—清除所有元素;</p>
<p>c++ stl容器set成员函数:count()—返回某个值元素的个数;</p>
<p>c++ stl容器set成员函数:empty()—如果集合为空，返回true;</p>
<p>c++ stl容器set成员函数:end()—返回指向最后一个元素的迭代器;</p>
<p>c++ stl容器set成员函数:equal_range()—返回集合中与给定值相等的上下限的两个迭代器;</p>
<p>c++ stl容器set成员函数:erase()—删除集合中的元素;</p>
<p>c++ stl容器set成员函数:find()—返回一个指向被查找到元素的迭代器;</p>
<p>c++ stl容器set成员函数:get_allocator()—返回集合的分配器;</p>
<p>c++ stl容器set成员函数:insert()—在集合中插入元素;</p>
<p>c++ stl容器set成员函数:lower_bound()—返回指向大于（或等于）某值的第一个元素的迭代器;</p>
<p>c++ stl容器set成员函数:key_comp()—返回一个用于元素间值比较的函数;</p>
<p>c++ stl容器set成员函数:max_size()—返回集合能容纳的元素的最大限值;</p>
<p>c++ stl容器set成员函数:rbegin()—返回指向集合中最后一个元素的反向迭代器;</p>
<p>c++ stl容器set成员函数:rend()—返回指向集合中第一个元素的反向迭代器;</p>
<p>c++ stl容器set成员函数:size()—集合中元素的数目;</p>
<p>c++ stl容器set成员函数:swap()—交换两个集合变量;</p>
<p>c++ stl容器set成员函数:upper_bound()—返回大于某个值元素的迭代器;</p>
<p>c++ stl容器set成员函数:value_comp()—返回一个用于比较元素间的值的函数;</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL——vector</title>
    <url>/STL%E2%80%94%E2%80%94vector/</url>
    <content><![CDATA[<p>。。。。。。。。。。。。。。。<br><a id="more"></a></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote>
<ul>
<li>int len = vec.size();</li>
<li>vec.push_back(temp);</li>
<li>vector::pop_back();     //删除最后一个元素</li>
<li>初始化vector：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;   <span class="comment">//初始化为空</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(v1);  <span class="comment">//用另一个vector来初始化，即构造一个副本</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(n, i); <span class="comment">//大小为n，并全部初始化为元素i （常用）</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n); <span class="comment">//构造大小为n的容器，没有初始化里面的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//构造大小为4，并初始化里面的各个元素</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>遍历容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++)&#123;</span><br><span class="line">    *it=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++)&#123;</span><br><span class="line">    vec[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入: vec.insert(vec.begin()+i,a);              //在第i个元素后面插入a;</p>
</li>
<li><p>删除: vec.erase(vec.begin()+2);                 //删除第3个元素</p>
<pre><code>  vec.erase(vec.begin()+i,vec.end()+j);    //删除区间[i,j-1];区间从0开始
</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++)&#123;</span><br><span class="line">    vec.erase(vec.begin()+i);</span><br><span class="line">    i--;                                          <span class="comment">//注意这里一定要i--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空：vec.clear()                                //清空之后，vec.size()为０</p>
</li>
<li>判空：vec.empty();                               //判断是否为空，为空返回true,否则返回false;</li>
<li>vec.resize(n+m);                                //调整vec的大小变为n+m</li>
<li>vec.capacity();                                 //获取容器分配的存储空间，区别于vec,size()</li>
<li>sort(vec.begin(),vec.end());</li>
<li>reverse(vec.begin(), vec.end());                //反转</li>
<li>swap(vec[i],vec[j]);</li>
</ul>
<h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><blockquote>
<p>与其他容器不同，其内存空间只会增长，不会减小。先来看看”C++ Primer”中怎么说：为了支持快速的随机访<br>问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。设想一下，当vector添加一个元素时，<br>为了满足连续存放这个特性，都需要重新分配空间、拷贝元素、撤销旧空间，这样性能难以接受。因此STL实现者在对<br>vector进行内存分配时，其实际分配的容量要比当前所需的空间多一些。就是说，vector容器预留了一些额外的存储<br>区，用于存放新添加的元素，这样就不必为每个新元素重新分配整个容器的内存空间。<br>关于vector的内存空间，有两个函数需要注意：size()成员指当前拥有的元素个数；capacity()成员指当前(容器必须分<br>配新存储空间之前)可以存储的元素个数。reserve()成员可以用来控制容器的预留空间。vector另外一个特性在于它的<br>内存空间会自增长，每当vector容器不得不分配新的存储空间时，会以加倍当前容量的分配策略实现重新分配。例如，<br>当前capacity为50，当添加第51个元素时，预留空间不够用了，vector容器会重新分配大小为100的内存空间，作为新<br>连续存储的位置。</p>
</blockquote>
<h1 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h1><blockquote>
<p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占<br>用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。<br>但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收，所以我们要用swap()。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(v);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">size:5</span></span><br><span class="line"><span class="comment">capacity:6</span></span><br><span class="line"><span class="comment">after swap size:0</span></span><br><span class="line"><span class="comment">after swap capacity:0*/</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>或者shrink_to_fit();<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.clear();</span><br><span class="line">    v.shrink_to_fit();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">size:5</span></span><br><span class="line"><span class="comment">capacity:6</span></span><br><span class="line"><span class="comment">after swap size:0</span></span><br><span class="line"><span class="comment">after swap capacity:0*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数论概述</title>
    <url>/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>。。。。。。。。。。。。。。<br><a id="more"></a></p>
<h1 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ex-gcd"><a href="#ex-gcd" class="headerlink" title="ex_gcd"></a>ex_gcd</h1><blockquote>
<p>前面我们用欧几里得算法gcd（a，b）=gcd（b，a%b）求得a，b的最大公约数，而扩展欧几里得算法可求得ax+by=gcd（a，b）的解，进一步可得到ax+by=c的解。<br>原理如下：<br>设a&gt;b</p>
<ul>
<li>当b=0时，显然有一对整数x=1，y=0，使得<code>a*1+0*0=gcd(a,0)</code>;</li>
<li>当b&gt;0,则gcd(a,b)=gcd(b,a mod b)。假设存在一对整数x,y，满足<code>b*x+(a mod b)*y=gcd(b,a mod b)</code>，因为<code>bx+(a mod b)y=bx+(a-b(a/b))y=ay+b(x-(a/b)y)</code>，所以令x’=y,y’=x-(a/b)y，就得到了ax’+by’=gcd(a,b)。</li>
<li>对于更为一般的方程ax+by=c，它有解<strong>当且仅当d|c</strong>。我们先求出ax+by=d的一组特解x0,y0，然后同时乘上c/d，就得到了ax+by=c的一组特解(c/d)x0,(c/d)y0。<br> 事实上，方程ax+by=c的通解可以表示为x=(c/d)x0+k(b/d),y=(c/d)y0-k(a/d) (k∈Z)。<br> 其中k取遍整个整数集合，d=gcd(a,b)，x0,y0是ax+by=gcd(a,b)的一组特解。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span> <span class="comment">//扩展欧几里得算法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    LL ret=exgcd(b,a%b,x,y);</span><br><span class="line">    ll z=x;x=y;y=z-y*(a/b);</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回值为gcd(a,b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><blockquote>
<p>寻找0到n中的质数个数，i从2到sqrt（n）依次取未被标记数j，每次从j*j到n将j（当前质数）的倍数进行标记，最后剩下全为质数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *prime=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) </span><br><span class="line">        prime[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;=n; j+=i) </span><br><span class="line">            prime[j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m; i&lt;=n; i++) </span><br><span class="line">        num+=prime[i];</span><br><span class="line">    <span class="keyword">delete</span> []prime;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;isprime(m,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">quickpow</span><span class="params">(LL x,LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">    x%=Mod;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=(ans*x)%Mod;   <span class="comment">//n%2==1 			</span></span><br><span class="line">		x=(x*x)%Mod;</span><br><span class="line">		n/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N=∏pi^ci;</span></span><br><span class="line"><span class="comment">//N的所有约数和为：∏(1+pi+pi^2+...+pi^ci)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            p[++m]=i;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">                n/=i,c[m]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1l</span>l) p[++m]=n,c[m]=<span class="number">1l</span>l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归求等比数列和取模"><a href="#递归求等比数列和取模" class="headerlink" title="递归求等比数列和取模"></a>递归求等比数列和取模</h1><blockquote>
<p><code>Sum(p,c)=1+p+p^2+...+p^c</code><br>若p为奇数:<code>sum(p,c)=qpow(p, (c + 1) / 2) + 1) * sum(p, c / 2)</code>;<br>若p为偶数：<code>sum(p,c)=(qpow(p, c / 2) + 1) * sum(p, c / 2 - 1) + qpow(p, c)</code>;</p>
</blockquote>
<h1 id="斯特林公式"><a href="#斯特林公式" class="headerlink" title="斯特林公式"></a>斯特林公式</h1><blockquote>
<p>普通计算时：<code>N！=1*2*3*4*5* ............*N</code>；<br>如果要计算N！后得到的数字，则我们可以知道其等于lgN！+1<br><code>lgN！=lg1+lg2+lg3+lg4+lg5+....................+lgN</code>;<br>但是当N很大的时候，我们可以通过数学公式进行优化：（即Stirling公式）<br><code>N！=sqrt(2*pi*N)*(N/e)^N；(pi=3.1415926=acos(-1.0)，e=2.718)lgN！=(lg(2*pi)+lgN)/2+N*(lgN-lge)</code>;<br>斯特林公式可以用来估算某数的大小结合lg可以估算某数的位数，或者可以估算某数的阶乘是另一个数的倍数。</p>
</blockquote>
<h1 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h1><blockquote>
<p>当且仅当p为质数时，(p-1)!≡-1 (mod p)</p>
</blockquote>
<h1 id="判断一个组合数的奇偶性"><a href="#判断一个组合数的奇偶性" class="headerlink" title="判断一个组合数的奇偶性"></a>判断一个组合数的奇偶性</h1><blockquote>
<p>C(n,k)为奇数时<br>n&amp;k==k     //n和k进行&amp;位运算后还等于k</p>
</blockquote>
<h1 id="判断2的次方数"><a href="#判断2的次方数" class="headerlink" title="判断2的次方数"></a>判断2的次方数</h1><blockquote>
<p>我们可以发现2的次方数n和n-1的二进制对应如下：<br>         2               10             01<br>         4               100            011<br>         8               1000          0111<br>         16              10000        01111<br>        。。。。。。。。。。。。。。。<br>即n&amp;(n-1)=0<br>而要确定n是2的几次方则直接数&gt;&gt;1右移次数即可</p>
</blockquote>
<h1 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h1><blockquote>
<ul>
<li>原码就是符号位加上真值的绝对值， 即用第一位表示符号， 其余位表示值。</li>
<li>反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上， 符号位不变，其余各个位取反。</li>
<li>补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上， 符号位不变， 其余各位取反， 最后+1。 (即在反码的基础上+1)</li>
</ul>
</blockquote>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><blockquote>
<p><a href="http://bamboo-rat.cn/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8%E3%80%81%E8%AF%81%E6%98%8E%E5%8F%8A%E6%B1%82%E6%B3%95/" target="_blank" rel="noopener">欧拉函数</a><br>φ(n)表示1~n中与n互质的数的个数</p>
</blockquote>
<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><blockquote>
<ul>
<li>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理</li>
<li>即 <code>A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C</code><br><img src="../image/容斥.jpg" alt=""></li>
</ul>
</blockquote>
<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><blockquote>
<ul>
<li>当n,a为正整数，且a和n互质时，a^φ(n)≡1(mod n);( 即[a^φ(n)]%n≡1%n )</li>
<li>应用：首先看一个基本的例子。令a = 3，n = 5，这两个数是互素的。比5小的正整数中与5互素的数有1、2、3和4，所以φ(5)=4。计算:a^φ(n) = 3^4 =81，而81 Ξ 1 （mod 5）。与定理结果相符。<br>这个定理可以用来简化幂的模运算。比如计算7^222的个位数，实际是求7^222被10除的余数。7和10互质，且φ(10)=4。由欧拉定理知7^4Ξ1(mod 10)。所以<code>7^222=(7^4)^55 * (7^2) Ξ 1^55 * 7^2 Ξ 49 Ξ 9 (mod 10)</code>。</li>
</ul>
</blockquote>
<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<ul>
<li>a是不能被质数p整除的正整数，则有 a^(p-1) ≡ 1 (mod p)</li>
<li>证明这个定理非常简单，由于p是质数，所以有φ(p) = p-1，代入欧拉定理即可证明。推论：对于任意正整数a，有a^p ≡ a (mod p)，因为a能被p整除时结论显然成立。</li>
</ul>
</blockquote>
<h1 id="费马大定理"><a href="#费马大定理" class="headerlink" title="费马大定理"></a>费马大定理</h1><blockquote>
<p>当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^n 没有正整数解。</p>
</blockquote>
<h1 id="哥德巴赫猜想"><a href="#哥德巴赫猜想" class="headerlink" title="哥德巴赫猜想"></a>哥德巴赫猜想</h1><blockquote>
<p>任意一个大于2的偶数，都可以写成两个质数的和</p>
</blockquote>
<h1 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h1><blockquote>
<ul>
<li>当求解公式：(a/b)%m 时，因b可能会过大，会出现爆精度的情况，所以需变除法为乘法：<br>设c是b的逆元，则有<code>b*c≡1(mod m)</code>；<br>则<code>(a/b)%m = (a/b)*1 %m = (a/b)*b*c %m = a*c(mod m)</code>;<br>即a/b的模等于a*c的模；</li>
<li><a href="http://bamboo-rat.cn/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E5%85%B7%E4%BD%93%E6%B1%82%E6%B3%95/" target="_blank" rel="noopener">具体求法</a></li>
</ul>
</blockquote>
<h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><blockquote>
<ul>
<li><a href="https://blog.csdn.net/pengwill97/article/details/77200372" target="_blank" rel="noopener">原理（转载自CSDN）</a></li>
<li><a href="http://bamboo-rat.cn/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%A8%A1%E6%9D%BF/" target="_blank" rel="noopener">模板</a></li>
</ul>
</blockquote>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><blockquote>
<ul>
<li>通项公式: <img src="../image/斐波那契.jpg" alt=""></li>
<li>任意两相邻斐波那契数互质</li>
<li>gcd(F(a),F(b))==F(gcd(a,b))</li>
<li>矩阵快速幂求法<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for(int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,n) for(int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a,x) memset(a,x,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    Mat()&#123;CRL(data,<span class="number">0</span>);&#125; <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    Mat <span class="keyword">operator</span>*(<span class="keyword">const</span> Mat &amp;h)&#123;     <span class="comment">//重载乘号</span></span><br><span class="line">        Mat c;</span><br><span class="line">        rep(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            rep(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                rep(k,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">                    c.data[i][j]=(c.data[i][j]+data[i][k]%mod*h.data[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Fn,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mat_qpow</span><span class="params">(Mat &amp;Fn,<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//矩阵快速幂 实际上是c的n次方</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) Fn=Fn*c;</span><br><span class="line">        c=c*c;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;~n)&#123;</span><br><span class="line">        Fn.data[<span class="number">0</span>][<span class="number">0</span>]=Fn.data[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;Fn.data[<span class="number">0</span>][<span class="number">1</span>]=Fn.data[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//单位阵初始化</span></span><br><span class="line">         c.data[<span class="number">0</span>][<span class="number">0</span>]= c.data[<span class="number">0</span>][<span class="number">1</span>]=c.data[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;c.data[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//常数阵初始化</span></span><br><span class="line">        Mat_qpow(Fn,n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;Fn.data[<span class="number">0</span>][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Color the ball(差分入门)</title>
    <url>/Color-the-ball-%E5%B7%AE%E5%88%86%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="传送门：HDU-1556"><a href="#传送门：HDU-1556" class="headerlink" title="传送门：HDU 1556"></a>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1556" target="_blank" rel="noopener">HDU 1556</a></h1><h1 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h1><blockquote>
<p>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？<br><a id="more"></a></p>
</blockquote>
<h1 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h1><blockquote>
<p>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>当N = 0，输入结束。</p>
</blockquote>
<h1 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h1><blockquote>
<p>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p>
</blockquote>
<h1 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h1><blockquote>
<ul>
<li>Input<br>3<br>1 1<br>2 2<br>3 3<br>3<br>1 1<br>1 2<br>1 3<br>0</li>
<li>Output<br>1 1 1<br>3 2 1</li>
<li>分析<br>区间修改  每次+1</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>暴力修改是会超时间复杂度的，一般是用线段树或者树状数组来做，这里介绍一下差分数组：<br>对于数组a[i]，我们令d[i]=a[i]-a[i-1] (d[1]=a[1])，则d[i]为一个差分数组，我们发现统计d数组的前缀和sum数组，则有：<br>sum[i]=d[1]+d[2]+d[3]+…+d[i]=a[1]+a[2]-a[1]+a[3]-a[2]+…+a[i]-a[i-1]=a[i],即前缀和sum[i]=a[i]；<br>因此每次在区间[l,r]增减x只需要令d[l]+x,d[r+1]-x，就可以保证[l,r]增加了x，而对[1,l-1]和[r+1,n]无影响。复杂度则是O(n)的</p>
</blockquote>
<h1 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0xfffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN -0xfffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>); </span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">            N[a]++;</span><br><span class="line">            N[b+<span class="number">1</span>]--;			</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            N[i]+=N[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;N[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;N[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title>哈特13的字符串(差分)</title>
    <url>/%E5%93%88%E7%89%B913%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="传送门：Swust-oj-1119"><a href="#传送门：Swust-oj-1119" class="headerlink" title="传送门：Swust oj 1119"></a>传送门：<a href="http://acm.swust.edu.cn/#/Problems/1119/-1?_k=1pwkhx" target="_blank" rel="noopener">Swust oj 1119</a></h1><h1 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h1><blockquote>
<p>哈特13非常嫌弃字符串，现在他有一个长度为n的字符串，由于嫌弃，所以他要将字符串进行一系列的更改。每次更改选择一个点ai，表示选中它从ai开始到n-ai+1的子串，然后将其首尾翻转，就这样一共翻转了m次，现在他想知道字符串被他玩成什么样子了。<br>但是他自己太笨并不知道，所以向你求助。<br>No zuo no die<br><a id="more"></a></p>
</blockquote>
<h1 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h1><blockquote>
<p>多组输入,直到文件末尾<br>每组数据第一行为字符串，长度1&lt;=n&lt;=100000<br>第二行为翻转数m，0&lt;=m&lt;=100000<br>接下来m个数字，每个数字表示翻转起点。</p>
</blockquote>
<h1 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h1><blockquote>
<p>翻转之后的字符串</p>
</blockquote>
<h1 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h1><blockquote>
<ul>
<li>Input<br>xcemt<br>2<br>1 2</li>
<li>Output<br>tcemx</li>
<li>分析<br>xcemt -&gt; tmecx -&gt; tcemx</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>直接一步一步暴力交换字符必然是会炸的，从题目上面我们可以看出来字符串每一次翻转都是关于中心点对称交换的，所以我们直接统计每一个点需要翻转多少次，最后再O(N)处理即可（奇翻偶不翻）。很容易想到每一次翻转就把m到n-m-1的计数器都+1，但是这样的话时间复杂度一样是 $N^2$,所以这里使用差分进行区间修改（<a href="https://aaaaalen.github.io/Color-the-ball-%E5%B7%AE%E5%88%86%E5%85%A5%E9%97%A8/#more">关于差分的运用在这一篇博客有详解</a>）。</p>
</blockquote>
<h1 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,b,a) for(int i=b-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="comment">//b——0,-1,128,0x3f,127 ,字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN=<span class="number">-0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        INIT(num,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> m,ai;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> len=str.size();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ai;</span><br><span class="line">            <span class="keyword">if</span>(ai<span class="number">-1</span>&lt;=len-ai)&#123;</span><br><span class="line">                num[ai<span class="number">-1</span>]++;</span><br><span class="line">                num[len-ai+<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num[ai]--;</span><br><span class="line">                num[len-ai]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> Str[<span class="number">100005</span>];INIT(Str,<span class="string">'\0'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">            num[i]+=num[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;			</span><br><span class="line">            <span class="keyword">if</span>(num[i]%<span class="number">2</span>==<span class="number">0</span>)Str[i]=str[i];</span><br><span class="line">            <span class="keyword">else</span> Str[i]=str[len-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;Str&lt;&lt;<span class="string">"\r\n"</span>;</span><br><span class="line">    &#125; 	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title>A+B Problem</title>
    <url>/A-B-Problem/</url>
    <content><![CDATA[<h1 id="传送门：Swust-oj-1206"><a href="#传送门：Swust-oj-1206" class="headerlink" title="传送门：Swust oj 1206"></a>传送门：<a href="http://acm.swust.edu.cn/#/problems/1206/-1?_k=jvv9ob" target="_blank" rel="noopener">Swust oj 1206</a></h1><h1 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h1><p>有两个数组A, B，其中数组A含有n个数，数组B含有m个数 ( m ≤ n ) 。 现在要对A数组进行n-m+1次操作： 对第一次操作：A1=A1+B1 , A2=A2+B2 , … ,Am=Am+Bm 对第二次操作：A2=A2+B1 , A3=A3+B2 , … , Am+1=Am+1+Bm 对第i次操作(1 ≤ i ≤ n-m+1)：Ai=Ai+B1 , Ai+1=Ai+1+B2 , … , Ai+m-1=Ai+m-1+Bm 现在你的任务是求出进行上述操作后的A数组。<br><a id="more"></a></p>
<h1 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h1><blockquote>
<p>多组测试数据<br> 第一行一个整数T (T ≤ 40)，表示有T组测试数据。<br> 每组测试数据有三行，第一行两个整 数n，m ( 1 ≤ m ≤ n ≤ $10^5$ ) ，分别表示<br> A，B数组的元素个数。<br> 第二行为n个整数Ai ( 1 ≤ Ai ≤ $10^5$ )<br>第二行为m个整数Bi ( 1 ≤ Bi ≤ $10^5$ )</p>
</blockquote>
<h1 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h1><blockquote>
<p>输出进行操作操作后的A数组n个整数，用空格隔开。</p>
</blockquote>
<h1 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h1><blockquote>
<ul>
<li><p>Input<br>4 2<br>1 1 1 1<br>1 1</p>
</li>
<li><p>Output<br>2 3 3 2</p>
</li>
<li><p>分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  1  1  1</span><br><span class="line">+1 +1</span><br><span class="line">   +1 +1</span><br><span class="line">      +1 +1</span><br><span class="line">2  3  3  2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>通过数据范围我们可以看出采用O(N*M)的方法是会超时的，所以我们先求出B数组的前缀和，然后O(N)处理A数组<br>当 i ≤ m 时，如果i&lt;=(n-m+1)，a[i]+=b[i]，否则a[i]+=(b[i]-b[i-n+m-1])；<br>当 i&gt;m &amp;&amp; i ≤ n-m 时，a[i]+=b[m]；<br>否则的话 a[i]+=(b[m]-b[i-n+m-1])；</p>
</blockquote>
<p><em>具体原因可以在纸上推导一下</em></p>
<h1 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL a[<span class="number">100005</span>],b[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> t;<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="keyword">int</span> n,m;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">                b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=m)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;=(n-m+<span class="number">1</span>))a[i]+=b[i];</span><br><span class="line">                    <span class="keyword">else</span> a[i]+=(b[i]-b[i-n+m<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;m&amp;&amp;i&lt;=n-m)a[i]+=b[m];</span><br><span class="line">                <span class="keyword">else</span> a[i]+=(b[m]-b[i-n+m<span class="number">-1</span>]);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" \n"</span>[i==n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法测试</title>
    <url>/Markdown%E8%AF%AD%E6%B3%95%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>用于Markdown语法学习和测试<br><a id="more"></a></p>
<h1 id="这是一级标题-一个"><a href="#这是一级标题-一个" class="headerlink" title="这是一级标题 一个#"></a>这是一级标题 一个<code>#</code></h1><h2 id="这是二级标题-两个"><a href="#这是二级标题-两个" class="headerlink" title="这是二级标题 两个#"></a>这是二级标题 两个<code>#</code></h2><h3 id="这是三级标题-三个"><a href="#这是三级标题-三个" class="headerlink" title="这是三级标题 三个#"></a>这是三级标题 三个<code>#</code></h3><h4 id="这是四级标题-四个"><a href="#这是四级标题-四个" class="headerlink" title="这是四级标题 四个#"></a>这是四级标题 四个<code>#</code></h4><h5 id="这是五级标题-五个"><a href="#这是五级标题-五个" class="headerlink" title="这是五级标题 五个#"></a>这是五级标题 五个<code>#</code></h5><h6 id="这是六级标题-六个"><a href="#这是六级标题-六个" class="headerlink" title="这是六级标题 六个#"></a>这是六级标题 六个<code>#</code></h6><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p><strong>这是加粗的字体（首尾两个<code>*</code>）</strong></p>
<h2 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h2><p><em>这是倾斜的字体（首尾一个`</em>`）*</p>
<h2 id="倾斜加粗"><a href="#倾斜加粗" class="headerlink" title="倾斜加粗"></a>倾斜加粗</h2><p><strong><em>这是斜体加粗的字体（首尾三个`</em>`）*</strong></p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是加删除线的字体（首尾两个<code>~</code>）</del></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p>这是引用的内容（一个&gt;）</p>
<blockquote>
<p>这也是引用的内容（两个&gt;）</p>
</blockquote>
</blockquote>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>三个或三个以上的-或*都可以</p>
<p>-</p>
<hr>
<p>*</p>
<hr>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</code></p>
<p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p>
<p><img src="https://wx1.sinaimg.cn/mw690/006bDeXUgy1fton0fbrbhj30e80e8aau.jpg" alt="Alan"></p>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p><code>[超链接名](超链接地址 &quot;超链接title&quot;)</code><br><code>title可加可不加</code></p>
<p><a href="https://blog.csdn.net/acdalao" target="_blank" rel="noopener">MyCSDN</a></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表用 - + * 任何一种都可以<br>如： </p>
<pre><code>- 列表内容
+ 列表内容
* 列表内容
</code></pre><p>效果如下：</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>数字加点,点和内容间要有空格<br>如：<br>  <code>1. 列表内容</code><br>  <code>2. 列表内容</code><br>  <code>3. 列表内容</code><br>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>上一级和下一极之间敲三个空格即可<br><code>+ 一级无序</code><br>   <code>+ 二级无序1</code><br>   <code>+ 二级无序2</code><br>   <code>+ 二级无序3</code></p>
<p><code>+ 一级无序</code><br>   <code>1. 二级有序1</code><br>   <code>2. 二级有序2</code><br>   <code>3. 二级有序3</code></p>
<p><code>1. 一级有序1</code><br>   <code>+ 二级无序1</code><br>   <code>+ 二级无序2</code><br>   <code>+ 二级无序3</code></p>
<p><code>2. 一级有序2</code><br>   <code>1. 二级有序1</code><br>   <code>2. 二级有序2</code><br>   <code>3. 二级有序3</code></p>
<ul>
<li><p>一级无序</p>
<ul>
<li>二级无序1</li>
<li>二级无序2</li>
<li>二级无序3</li>
</ul>
</li>
<li><p>一级无序</p>
<ol>
<li>二级有序1</li>
<li>二级有序2</li>
<li>二级有序3</li>
</ol>
</li>
</ul>
<ol>
<li><p>一级有序1</p>
<ul>
<li>二级无序1</li>
<li>二级无序2</li>
<li>二级无序3</li>
</ul>
</li>
<li><p>一级有序2</p>
<ol>
<li>二级有序1</li>
<li>二级有序2</li>
<li>二级有序3<br><strong>可以看到在无序下面套上有序的话，有序列表会变成无序列表</strong></li>
</ol>
</li>
</ol>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><code>表头|表头|表头</code><br><code>---|:--:|---:</code><br><code>内容|内容|内容</code><br><code>内容|内容|内容</code></p>
<p><strong><code>第二行分割表头和内容。</code></strong><br><strong><code>- 有一个就行，为了对齐，多加了几个</code></strong><br><strong><code>文字默认居左</code></strong><br><strong><code>-两边加：表示文字居中</code></strong><br><strong><code>-右边加：表示文字居右</code></strong><br><strong><code>注：原生的语法两边都要用 | 包起来。此处省略</code></strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>姓名</th>
<th style="text-align:center">技能</th>
<th style="text-align:right">排行</th>
</tr>
</thead>
<tbody>
<tr>
<td>刘备</td>
<td style="text-align:center">哭</td>
<td style="text-align:right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td style="text-align:center">打</td>
<td style="text-align:right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td style="text-align:center">骂</td>
<td style="text-align:right">三弟</td>
</tr>
</tbody>
</table>
</div>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>单行：首尾`</p>
<p>多行：上下三个`</p>
]]></content>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/Welcome/</url>
    <content><![CDATA[<p>Welcome to Nick’s Bolg<br><a id="more"></a></p>
<hr>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试flash插件"><a href="#测试flash插件" class="headerlink" title="测试flash插件"></a>测试flash插件</h2><embed src="//music.163.com/style/swf/widget.swf?sid=5310505&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all">

<h2 id="测试插入代码"><a href="#测试插入代码" class="headerlink" title="测试插入代码"></a>测试插入代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello world!"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//测试注释</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试链接"><a href="#测试链接" class="headerlink" title="测试链接"></a>测试链接</h2><p><a href="https://paste.ubuntu.com/" target="_blank" rel="noopener">分享代码</a></p>
<h2 id="测试公式"><a href="#测试公式" class="headerlink" title="测试公式"></a>测试公式</h2><p>质能守恒方程可以用一$r=a-k*b r\div d-k*b\div d$个很简洁的方程式 $E=mc^2$ 来表达。</p>
<script type="math/tex; mode=display">\ sum_{i=1}^n a_i=0</script><script type="math/tex; mode=display">f (x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2</script><script type="math/tex; mode=display">\ sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}</script><h2 id="测试表格"><a href="#测试表格" class="headerlink" title="测试表格"></a>测试表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>蒟蒻</td>
<td>59</td>
</tr>
<tr>
<td>神犇</td>
<td>100</td>
</tr>
</tbody>
</table>
</div>
<h2 id="测试矩阵"><a href="#测试矩阵" class="headerlink" title="测试矩阵"></a>测试矩阵</h2><script type="math/tex; mode=display">
\begin{matrix}
    1 & x & x^2 \\
    1 & y & y^2 \\
    1 & z & z^2 \\
\end{matrix}</script><script type="math/tex; mode=display">
\begin{pmatrix}
    1 & x & x^2 \\
    1 & y & y^2 \\
    1 & z & z^2 \\
\end{pmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
    1 & x & x^2 \\
    1 & y & y^2 \\
    1 & z & z^2 \\
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{vmatrix}
    1 & x & x^2 \\\
    1 & y & y^2 \\\
    1 & z & z^2 
\end{vmatrix}</script><blockquote>
<script type="math/tex; mode=display">
\mu (d)=
\begin{cases}
  1 &\mbox{d=1} \\
  (-1)^k &\mbox{$d= p_1*p_2*p_3*...*p_k,p_i$是互异素数}\\
  0 &\mbox{其余情况}\\
  \end{cases}</script><script type="math/tex; mode=display">
dp[i][j]=Max
\begin{cases}
  dp[i-1][j] &\mbox{不拿第i个，状态跟i-1一样}\\
  dp[i-1][j-cost[i]]+valum[i] &\mbox{i^2拿第i个，那么就把前cost[i]体积的物品拿走再放}
  \end{cases}</script></blockquote>
]]></content>
  </entry>
  <entry>
    <title>Soldiers</title>
    <url>/Soldiers/</url>
    <content><![CDATA[<h1 id="传送门SwustOj696"><a href="#传送门SwustOj696" class="headerlink" title="传送门SwustOj696"></a>传送门<a href="http://acm.swust.edu.cn/#/problem/696/433" target="_blank" rel="noopener">SwustOj696</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>在一个划分成网格的操场上，n个士兵散乱地站在网格点上。网格点由整数坐标(x,y)表示。士兵们可以沿网格边上、下、左、右移动一步，但在同一时刻任一网格点上只能有一名士兵。按照军官的命令，士兵们要整齐地列成一个水平队列，即排列成(x,y),(x+1,y),…,(x+n-1,y)。如何选择x 和y的值才能使士兵们以最少的总移动步数排成一列。计算使所有士兵排成一行需要的最少移动步数。<br><a id="more"></a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>第1 行是士兵数n，1&lt; =n&lt; =10000。接下来n 行是士兵的位置，每行2个整数x和y，-10000&lt; =x，y&lt; =10000。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>第1 行中的数是士兵排成一行需要的最少移动步数。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>5<br>1 2<br>2 2<br>1 3<br>3 -2<br>3 3</li>
</ul>
</blockquote>
<ul>
<li>Output<br>8</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<ul>
<li>显然y轴求中位数</li>
<li>对于x轴，设排好队后的第一个位置为X，则每个士兵移动的步数为<code>x[i]-(X+i)</code>，总距离为<code>|x0-X|+|x1-X-1|+|x2-X-2|+...+|x(n-1)-X-n+1|</code>,要使得他们的和最小，我们需要求<code>x[i]-i（0 &lt;= i &lt;= n-1）</code>的中位数,即为最优的X。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="built_in">exp</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x[maxn],y[maxn],xx[maxn];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    sort(x,x+n);sort(y,y+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        xx[i]=x[i]-i;</span><br><span class="line">    sort(xx,xx+n);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,resx=xx[n/<span class="number">2</span>],resy=y[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">abs</span>(xx[i]-resx);</span><br><span class="line">        ans+=<span class="built_in">abs</span>(y[i]-resy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title>Coin Changing——多重背包</title>
    <url>/Coin-Changing%E2%80%94%E2%80%94%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="传送门SwustOj575"><a href="#传送门SwustOj575" class="headerlink" title="传送门SwustOj575"></a>传送门<a href="http://acm.swust.edu.cn/#/problem/575/417" target="_blank" rel="noopener">SwustOj575</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>设有n 种不同面值的硬币，各硬币的面值存于数组T［1:n］中。现要用这些面值的硬币来找钱。可以使用的各种面值的硬币个数存于数组Coins［1:n］中。 对于给定的1≤n≤10，硬币面值数组T和可以使用的各种面值的硬币个数数组Coins，以及钱数m，0≤m≤20001，编程计算找钱m的最少硬币数。<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>第一行中只有1 个整数给出n的值,第2 行起每行2 个数，分别是T[j]和Coins[j]。最后1 行是要找的钱数m。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>最少硬币数,无解时输出-1</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>3<br>1 3<br>2 3<br>5 3<br>18</li>
<li>Output<br>5</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>三层直接裸</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,t[<span class="number">20</span>],coin[<span class="number">20</span>];</span><br><span class="line">    INIT(dp,inf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t[i],&amp;coin[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=coin[i];k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=t[i];j--)&#123;</span><br><span class="line">                dp[j]=min(dp[j],dp[j-t[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[m]==inf) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Buyer——o1背包路径查询</title>
    <url>/Buyer%E2%80%94%E2%80%94o1%E8%83%8C%E5%8C%85%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="传送门SwustOj195"><a href="#传送门SwustOj195" class="headerlink" title="传送门SwustOj195"></a>传送门<a href="http://acm.swust.edu.cn/#/problem/195/417" target="_blank" rel="noopener">SwustOj195</a></h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>哆啦A梦班级举办个party，当然吃的东西必不可少，哆啦A梦负责采购任务，他得到了一份清单，上面注明不同食品的受欢迎程度，哆啦A梦需要用一定的价钱尽可能达到的更大的受欢迎程度！例如，瓜子的受欢迎程度为20，瓜子的价钱是50元，那么如果哆啦A梦选择买瓜子，将花费50元，但受欢迎程度增加了20。为了避免食品单调性，每种食品只能买一份，不能重复购买。 现在哆啦A梦需要知道如何采购才能达到最大的受欢迎程度，你能帮助他吗？<br><a id="more"></a></p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>输入数据为多组，每组输入的第一行有两个正整数M和N(M&lt;100&amp;&amp;N&lt;1000)，分别为哆啦A梦可以支配的钱数和清单上的可选择的物品种类。 接下来的N行每行有两个正整数,分别为每种物品的价钱和它的受欢迎程度（编号为1到N）。</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>如果存在物品购买，那么输出的第一行为能够达到的最大的受欢迎程度。第二行为需要购买的物品的编号（如果有多种可能，输出字典序靠前的那种），空格分隔每个数字；如没有物品可以购买，输出只有一行，为数字0。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><blockquote>
<ul>
<li>Input<br>10 4<br>100 5<br>5 5<br>5 5<br>10 10</li>
<li>Output<br>10<br>2 3</li>
</ul>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>用二维存储状态，从最终结果往前推，如果dp[i][j]!=dp[i-1][j]，说明取了物体i，j-=w[i]，然后继续。</li>
</ul>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,w[maxn],v[maxn],dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sta[maxn],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        INIT(dp,<span class="number">0</span>);tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(w[i]&gt;j)dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n,j=m;i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&gt;dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                sta[++tot]=i;</span><br><span class="line">                j-=w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][m]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,sta[i],<span class="string">" \n"</span>[i==<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
</search>
